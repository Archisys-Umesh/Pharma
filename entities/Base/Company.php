<?php

namespace entities\Base;

use \Exception;
use \PDO;
use Propel\Runtime\Propel;
use Propel\Runtime\ActiveQuery\Criteria;
use Propel\Runtime\ActiveQuery\ModelCriteria;
use Propel\Runtime\ActiveRecord\ActiveRecordInterface;
use Propel\Runtime\Collection\Collection;
use Propel\Runtime\Collection\ObjectCollection;
use Propel\Runtime\Connection\ConnectionInterface;
use Propel\Runtime\Exception\BadMethodCallException;
use Propel\Runtime\Exception\LogicException;
use Propel\Runtime\Exception\PropelException;
use Propel\Runtime\Map\TableMap;
use Propel\Runtime\Parser\AbstractParser;
use entities\Agendatypes as ChildAgendatypes;
use entities\AgendatypesQuery as ChildAgendatypesQuery;
use entities\Announcements as ChildAnnouncements;
use entities\AnnouncementsQuery as ChildAnnouncementsQuery;
use entities\ApiKeys as ChildApiKeys;
use entities\ApiKeysQuery as ChildApiKeysQuery;
use entities\Attendance as ChildAttendance;
use entities\AttendanceQuery as ChildAttendanceQuery;
use entities\BeatOutlets as ChildBeatOutlets;
use entities\BeatOutletsQuery as ChildBeatOutletsQuery;
use entities\Beats as ChildBeats;
use entities\BeatsQuery as ChildBeatsQuery;
use entities\Branch as ChildBranch;
use entities\BranchQuery as ChildBranchQuery;
use entities\BrandCampiagn as ChildBrandCampiagn;
use entities\BrandCampiagnDoctors as ChildBrandCampiagnDoctors;
use entities\BrandCampiagnDoctorsQuery as ChildBrandCampiagnDoctorsQuery;
use entities\BrandCampiagnQuery as ChildBrandCampiagnQuery;
use entities\BrandCampiagnVisitPlan as ChildBrandCampiagnVisitPlan;
use entities\BrandCampiagnVisitPlanQuery as ChildBrandCampiagnVisitPlanQuery;
use entities\BrandCompetition as ChildBrandCompetition;
use entities\BrandCompetitionQuery as ChildBrandCompetitionQuery;
use entities\BrandRcpa as ChildBrandRcpa;
use entities\BrandRcpaQuery as ChildBrandRcpaQuery;
use entities\Brands as ChildBrands;
use entities\BrandsQuery as ChildBrandsQuery;
use entities\BudgetGroup as ChildBudgetGroup;
use entities\BudgetGroupQuery as ChildBudgetGroupQuery;
use entities\Categories as ChildCategories;
use entities\CategoriesQuery as ChildCategoriesQuery;
use entities\CheckinoutOutcomes as ChildCheckinoutOutcomes;
use entities\CheckinoutOutcomesQuery as ChildCheckinoutOutcomesQuery;
use entities\Citycategory as ChildCitycategory;
use entities\CitycategoryQuery as ChildCitycategoryQuery;
use entities\Classification as ChildClassification;
use entities\ClassificationQuery as ChildClassificationQuery;
use entities\Company as ChildCompany;
use entities\CompanyQuery as ChildCompanyQuery;
use entities\CompetitionMapping as ChildCompetitionMapping;
use entities\CompetitionMappingQuery as ChildCompetitionMappingQuery;
use entities\Competitor as ChildCompetitor;
use entities\CompetitorQuery as ChildCompetitorQuery;
use entities\Configuration as ChildConfiguration;
use entities\ConfigurationQuery as ChildConfigurationQuery;
use entities\CronCommandLogs as ChildCronCommandLogs;
use entities\CronCommandLogsQuery as ChildCronCommandLogsQuery;
use entities\CronCommands as ChildCronCommands;
use entities\CronCommandsQuery as ChildCronCommandsQuery;
use entities\Currencies as ChildCurrencies;
use entities\CurrenciesQuery as ChildCurrenciesQuery;
use entities\Dailycalls as ChildDailycalls;
use entities\DailycallsQuery as ChildDailycallsQuery;
use entities\DailycallsSgpiout as ChildDailycallsSgpiout;
use entities\DailycallsSgpioutQuery as ChildDailycallsSgpioutQuery;
use entities\DataExceptionLogs as ChildDataExceptionLogs;
use entities\DataExceptionLogsQuery as ChildDataExceptionLogsQuery;
use entities\DataExceptions as ChildDataExceptions;
use entities\DataExceptionsQuery as ChildDataExceptionsQuery;
use entities\Designations as ChildDesignations;
use entities\DesignationsQuery as ChildDesignationsQuery;
use entities\EdFeedbacks as ChildEdFeedbacks;
use entities\EdFeedbacksQuery as ChildEdFeedbacksQuery;
use entities\EdPlaylist as ChildEdPlaylist;
use entities\EdPlaylistQuery as ChildEdPlaylistQuery;
use entities\EdPresentations as ChildEdPresentations;
use entities\EdPresentationsQuery as ChildEdPresentationsQuery;
use entities\EdSession as ChildEdSession;
use entities\EdSessionQuery as ChildEdSessionQuery;
use entities\EdStats as ChildEdStats;
use entities\EdStatsQuery as ChildEdStatsQuery;
use entities\Employee as ChildEmployee;
use entities\EmployeeIncentive as ChildEmployeeIncentive;
use entities\EmployeeIncentiveQuery as ChildEmployeeIncentiveQuery;
use entities\EmployeeQuery as ChildEmployeeQuery;
use entities\EventTypes as ChildEventTypes;
use entities\EventTypesQuery as ChildEventTypesQuery;
use entities\Events as ChildEvents;
use entities\EventsQuery as ChildEventsQuery;
use entities\ExpenseList as ChildExpenseList;
use entities\ExpenseListQuery as ChildExpenseListQuery;
use entities\ExpenseMaster as ChildExpenseMaster;
use entities\ExpenseMasterQuery as ChildExpenseMasterQuery;
use entities\ExpensePayments as ChildExpensePayments;
use entities\ExpensePaymentsQuery as ChildExpensePaymentsQuery;
use entities\Expenses as ChildExpenses;
use entities\ExpensesQuery as ChildExpensesQuery;
use entities\FtpConfigs as ChildFtpConfigs;
use entities\FtpConfigsQuery as ChildFtpConfigsQuery;
use entities\FtpExportBatches as ChildFtpExportBatches;
use entities\FtpExportBatchesQuery as ChildFtpExportBatchesQuery;
use entities\FtpExportLogs as ChildFtpExportLogs;
use entities\FtpExportLogsQuery as ChildFtpExportLogsQuery;
use entities\FtpImportBatches as ChildFtpImportBatches;
use entities\FtpImportBatchesQuery as ChildFtpImportBatchesQuery;
use entities\FtpImportLogs as ChildFtpImportLogs;
use entities\FtpImportLogsQuery as ChildFtpImportLogsQuery;
use entities\GradeMaster as ChildGradeMaster;
use entities\GradeMasterQuery as ChildGradeMasterQuery;
use entities\Holidays as ChildHolidays;
use entities\HolidaysQuery as ChildHolidaysQuery;
use entities\IntegrationApiLogs as ChildIntegrationApiLogs;
use entities\IntegrationApiLogsQuery as ChildIntegrationApiLogsQuery;
use entities\LeaveRequest as ChildLeaveRequest;
use entities\LeaveRequestQuery as ChildLeaveRequestQuery;
use entities\LeaveType as ChildLeaveType;
use entities\LeaveTypeQuery as ChildLeaveTypeQuery;
use entities\Leaves as ChildLeaves;
use entities\LeavesQuery as ChildLeavesQuery;
use entities\MaterialFolders as ChildMaterialFolders;
use entities\MaterialFoldersQuery as ChildMaterialFoldersQuery;
use entities\MediaFiles as ChildMediaFiles;
use entities\MediaFilesQuery as ChildMediaFilesQuery;
use entities\MediaFolders as ChildMediaFolders;
use entities\MediaFoldersQuery as ChildMediaFoldersQuery;
use entities\Mtp as ChildMtp;
use entities\MtpDay as ChildMtpDay;
use entities\MtpDayQuery as ChildMtpDayQuery;
use entities\MtpLogs as ChildMtpLogs;
use entities\MtpLogsQuery as ChildMtpLogsQuery;
use entities\MtpQuery as ChildMtpQuery;
use entities\NotificationConfiguration as ChildNotificationConfiguration;
use entities\NotificationConfigurationQuery as ChildNotificationConfigurationQuery;
use entities\Offers as ChildOffers;
use entities\OffersQuery as ChildOffersQuery;
use entities\OnBoardRequest as ChildOnBoardRequest;
use entities\OnBoardRequestAddress as ChildOnBoardRequestAddress;
use entities\OnBoardRequestAddressQuery as ChildOnBoardRequestAddressQuery;
use entities\OnBoardRequestQuery as ChildOnBoardRequestQuery;
use entities\OnBoardRequiredFields as ChildOnBoardRequiredFields;
use entities\OnBoardRequiredFieldsQuery as ChildOnBoardRequiredFieldsQuery;
use entities\OrderLog as ChildOrderLog;
use entities\OrderLogQuery as ChildOrderLogQuery;
use entities\Orderlines as ChildOrderlines;
use entities\OrderlinesQuery as ChildOrderlinesQuery;
use entities\Orders as ChildOrders;
use entities\OrdersQuery as ChildOrdersQuery;
use entities\OrgUnit as ChildOrgUnit;
use entities\OrgUnitQuery as ChildOrgUnitQuery;
use entities\OtpRequests as ChildOtpRequests;
use entities\OtpRequestsQuery as ChildOtpRequestsQuery;
use entities\OutletAddress as ChildOutletAddress;
use entities\OutletAddressQuery as ChildOutletAddressQuery;
use entities\OutletOrgData as ChildOutletOrgData;
use entities\OutletOrgDataKeys as ChildOutletOrgDataKeys;
use entities\OutletOrgDataKeysQuery as ChildOutletOrgDataKeysQuery;
use entities\OutletOrgDataQuery as ChildOutletOrgDataQuery;
use entities\OutletOrgNotes as ChildOutletOrgNotes;
use entities\OutletOrgNotesQuery as ChildOutletOrgNotesQuery;
use entities\OutletOutcomes as ChildOutletOutcomes;
use entities\OutletOutcomesQuery as ChildOutletOutcomesQuery;
use entities\OutletStock as ChildOutletStock;
use entities\OutletStockOtherSummary as ChildOutletStockOtherSummary;
use entities\OutletStockOtherSummaryQuery as ChildOutletStockOtherSummaryQuery;
use entities\OutletStockQuery as ChildOutletStockQuery;
use entities\OutletStockSummary as ChildOutletStockSummary;
use entities\OutletStockSummaryQuery as ChildOutletStockSummaryQuery;
use entities\OutletTags as ChildOutletTags;
use entities\OutletTagsQuery as ChildOutletTagsQuery;
use entities\OutletType as ChildOutletType;
use entities\OutletTypeQuery as ChildOutletTypeQuery;
use entities\Outlets as ChildOutlets;
use entities\OutletsQuery as ChildOutletsQuery;
use entities\PolicyMaster as ChildPolicyMaster;
use entities\PolicyMasterQuery as ChildPolicyMasterQuery;
use entities\Policykeys as ChildPolicykeys;
use entities\PolicykeysQuery as ChildPolicykeysQuery;
use entities\Positions as ChildPositions;
use entities\PositionsQuery as ChildPositionsQuery;
use entities\Pricebooklines as ChildPricebooklines;
use entities\PricebooklinesQuery as ChildPricebooklinesQuery;
use entities\Pricebooks as ChildPricebooks;
use entities\PricebooksQuery as ChildPricebooksQuery;
use entities\Products as ChildProducts;
use entities\ProductsQuery as ChildProductsQuery;
use entities\Reminders as ChildReminders;
use entities\RemindersQuery as ChildRemindersQuery;
use entities\SgpiAccounts as ChildSgpiAccounts;
use entities\SgpiAccountsQuery as ChildSgpiAccountsQuery;
use entities\SgpiMaster as ChildSgpiMaster;
use entities\SgpiMasterQuery as ChildSgpiMasterQuery;
use entities\SgpiTrans as ChildSgpiTrans;
use entities\SgpiTransQuery as ChildSgpiTransQuery;
use entities\ShiftTypes as ChildShiftTypes;
use entities\ShiftTypesQuery as ChildShiftTypesQuery;
use entities\Shippinglines as ChildShippinglines;
use entities\ShippinglinesQuery as ChildShippinglinesQuery;
use entities\Shippingorder as ChildShippingorder;
use entities\ShippingorderQuery as ChildShippingorderQuery;
use entities\StockTransaction as ChildStockTransaction;
use entities\StockTransactionQuery as ChildStockTransactionQuery;
use entities\StockVoucher as ChildStockVoucher;
use entities\StockVoucherQuery as ChildStockVoucherQuery;
use entities\Stp as ChildStp;
use entities\StpQuery as ChildStpQuery;
use entities\StpWeek as ChildStpWeek;
use entities\StpWeekQuery as ChildStpWeekQuery;
use entities\Survey as ChildSurvey;
use entities\SurveyCategory as ChildSurveyCategory;
use entities\SurveyCategoryQuery as ChildSurveyCategoryQuery;
use entities\SurveyQuery as ChildSurveyQuery;
use entities\SurveyQuestion as ChildSurveyQuestion;
use entities\SurveyQuestionQuery as ChildSurveyQuestionQuery;
use entities\SurveySubmited as ChildSurveySubmited;
use entities\SurveySubmitedQuery as ChildSurveySubmitedQuery;
use entities\TaConfiguration as ChildTaConfiguration;
use entities\TaConfigurationQuery as ChildTaConfigurationQuery;
use entities\Tags as ChildTags;
use entities\TagsQuery as ChildTagsQuery;
use entities\Territories as ChildTerritories;
use entities\TerritoriesQuery as ChildTerritoriesQuery;
use entities\TerritoryTowns as ChildTerritoryTowns;
use entities\TerritoryTownsQuery as ChildTerritoryTownsQuery;
use entities\TicketReplies as ChildTicketReplies;
use entities\TicketRepliesQuery as ChildTicketRepliesQuery;
use entities\TicketType as ChildTicketType;
use entities\TicketTypeQuery as ChildTicketTypeQuery;
use entities\Tickets as ChildTickets;
use entities\TicketsQuery as ChildTicketsQuery;
use entities\Tourplans as ChildTourplans;
use entities\TourplansQuery as ChildTourplansQuery;
use entities\Transactions as ChildTransactions;
use entities\TransactionsQuery as ChildTransactionsQuery;
use entities\Users as ChildUsers;
use entities\UsersQuery as ChildUsersQuery;
use entities\WdbSyncLog as ChildWdbSyncLog;
use entities\WdbSyncLogQuery as ChildWdbSyncLogQuery;
use entities\WfRequests as ChildWfRequests;
use entities\WfRequestsQuery as ChildWfRequestsQuery;
use entities\Map\AgendatypesTableMap;
use entities\Map\AnnouncementsTableMap;
use entities\Map\ApiKeysTableMap;
use entities\Map\AttendanceTableMap;
use entities\Map\BeatOutletsTableMap;
use entities\Map\BeatsTableMap;
use entities\Map\BranchTableMap;
use entities\Map\BrandCampiagnDoctorsTableMap;
use entities\Map\BrandCampiagnTableMap;
use entities\Map\BrandCampiagnVisitPlanTableMap;
use entities\Map\BrandCompetitionTableMap;
use entities\Map\BrandRcpaTableMap;
use entities\Map\BrandsTableMap;
use entities\Map\BudgetGroupTableMap;
use entities\Map\CategoriesTableMap;
use entities\Map\CheckinoutOutcomesTableMap;
use entities\Map\CitycategoryTableMap;
use entities\Map\ClassificationTableMap;
use entities\Map\CompanyTableMap;
use entities\Map\CompetitionMappingTableMap;
use entities\Map\CompetitorTableMap;
use entities\Map\ConfigurationTableMap;
use entities\Map\CronCommandLogsTableMap;
use entities\Map\CronCommandsTableMap;
use entities\Map\DailycallsSgpioutTableMap;
use entities\Map\DailycallsTableMap;
use entities\Map\DataExceptionLogsTableMap;
use entities\Map\DataExceptionsTableMap;
use entities\Map\DesignationsTableMap;
use entities\Map\EdFeedbacksTableMap;
use entities\Map\EdPlaylistTableMap;
use entities\Map\EdPresentationsTableMap;
use entities\Map\EdSessionTableMap;
use entities\Map\EdStatsTableMap;
use entities\Map\EmployeeIncentiveTableMap;
use entities\Map\EmployeeTableMap;
use entities\Map\EventTypesTableMap;
use entities\Map\EventsTableMap;
use entities\Map\ExpenseListTableMap;
use entities\Map\ExpenseMasterTableMap;
use entities\Map\ExpensePaymentsTableMap;
use entities\Map\ExpensesTableMap;
use entities\Map\FtpConfigsTableMap;
use entities\Map\FtpExportBatchesTableMap;
use entities\Map\FtpExportLogsTableMap;
use entities\Map\FtpImportBatchesTableMap;
use entities\Map\FtpImportLogsTableMap;
use entities\Map\GradeMasterTableMap;
use entities\Map\HolidaysTableMap;
use entities\Map\IntegrationApiLogsTableMap;
use entities\Map\LeaveRequestTableMap;
use entities\Map\LeaveTypeTableMap;
use entities\Map\LeavesTableMap;
use entities\Map\MaterialFoldersTableMap;
use entities\Map\MediaFilesTableMap;
use entities\Map\MediaFoldersTableMap;
use entities\Map\MtpDayTableMap;
use entities\Map\MtpLogsTableMap;
use entities\Map\MtpTableMap;
use entities\Map\NotificationConfigurationTableMap;
use entities\Map\OffersTableMap;
use entities\Map\OnBoardRequestAddressTableMap;
use entities\Map\OnBoardRequestTableMap;
use entities\Map\OnBoardRequiredFieldsTableMap;
use entities\Map\OrderLogTableMap;
use entities\Map\OrderlinesTableMap;
use entities\Map\OrdersTableMap;
use entities\Map\OrgUnitTableMap;
use entities\Map\OtpRequestsTableMap;
use entities\Map\OutletAddressTableMap;
use entities\Map\OutletOrgDataKeysTableMap;
use entities\Map\OutletOrgDataTableMap;
use entities\Map\OutletOrgNotesTableMap;
use entities\Map\OutletOutcomesTableMap;
use entities\Map\OutletStockOtherSummaryTableMap;
use entities\Map\OutletStockSummaryTableMap;
use entities\Map\OutletStockTableMap;
use entities\Map\OutletTagsTableMap;
use entities\Map\OutletTypeTableMap;
use entities\Map\OutletsTableMap;
use entities\Map\PolicyMasterTableMap;
use entities\Map\PolicykeysTableMap;
use entities\Map\PositionsTableMap;
use entities\Map\PricebooklinesTableMap;
use entities\Map\PricebooksTableMap;
use entities\Map\ProductsTableMap;
use entities\Map\RemindersTableMap;
use entities\Map\SgpiAccountsTableMap;
use entities\Map\SgpiMasterTableMap;
use entities\Map\SgpiTransTableMap;
use entities\Map\ShiftTypesTableMap;
use entities\Map\ShippinglinesTableMap;
use entities\Map\ShippingorderTableMap;
use entities\Map\StockTransactionTableMap;
use entities\Map\StockVoucherTableMap;
use entities\Map\StpTableMap;
use entities\Map\StpWeekTableMap;
use entities\Map\SurveyCategoryTableMap;
use entities\Map\SurveyQuestionTableMap;
use entities\Map\SurveySubmitedTableMap;
use entities\Map\SurveyTableMap;
use entities\Map\TaConfigurationTableMap;
use entities\Map\TagsTableMap;
use entities\Map\TerritoriesTableMap;
use entities\Map\TerritoryTownsTableMap;
use entities\Map\TicketRepliesTableMap;
use entities\Map\TicketTypeTableMap;
use entities\Map\TicketsTableMap;
use entities\Map\TourplansTableMap;
use entities\Map\TransactionsTableMap;
use entities\Map\UsersTableMap;
use entities\Map\WdbSyncLogTableMap;
use entities\Map\WfRequestsTableMap;

/**
 * Base class that represents a row from the 'company' table.
 *
 *
 *
 * @package    propel.generator.entities.Base
 */
abstract class Company implements ActiveRecordInterface
{
    /**
     * TableMap class name
     *
     * @var string
     */
    public const TABLE_MAP = '\\entities\\Map\\CompanyTableMap';


    /**
     * attribute to determine if this object has previously been saved.
     * @var bool
     */
    protected $new = true;

    /**
     * attribute to determine whether this object has been deleted.
     * @var bool
     */
    protected $deleted = false;

    /**
     * The columns that have been modified in current object.
     * Tracking modified columns allows us to only update modified columns.
     * @var array
     */
    protected $modifiedColumns = [];

    /**
     * The (virtual) columns that are added at runtime
     * The formatters can add supplementary columns based on a resultset
     * @var array
     */
    protected $virtualColumns = [];

    /**
     * The value for the company_id field.
     *
     * @var        int
     */
    protected $company_id;

    /**
     * The value for the company_code field.
     *
     * Note: this column has a database default value of: '0'
     * @var        string
     */
    protected $company_code;

    /**
     * The value for the company_name field.
     *
     * @var        string|null
     */
    protected $company_name;

    /**
     * The value for the owner_name field.
     *
     * @var        string|null
     */
    protected $owner_name;

    /**
     * The value for the company_phone_number field.
     *
     * @var        string|null
     */
    protected $company_phone_number;

    /**
     * The value for the company_contact_number field.
     *
     * @var        string|null
     */
    protected $company_contact_number;

    /**
     * The value for the company_logo field.
     *
     * @var        string|null
     */
    protected $company_logo;

    /**
     * The value for the company_address_1 field.
     *
     * @var        string|null
     */
    protected $company_address_1;

    /**
     * The value for the company_address_2 field.
     *
     * @var        string|null
     */
    protected $company_address_2;

    /**
     * The value for the company_default_currency field.
     *
     * @var        int|null
     */
    protected $company_default_currency;

    /**
     * The value for the timezone field.
     *
     * @var        string|null
     */
    protected $timezone;

    /**
     * The value for the company_first_setup field.
     *
     * Note: this column has a database default value of: 0
     * @var        int|null
     */
    protected $company_first_setup;

    /**
     * The value for the owner_email field.
     *
     * Note: this column has a database default value of: '0'
     * @var        string|null
     */
    protected $owner_email;

    /**
     * The value for the expense_reminder field.
     *
     * Note: this column has a database default value of: 0
     * @var        int|null
     */
    protected $expense_reminder;

    /**
     * The value for the currentmonthsubmit field.
     *
     * Note: this column has a database default value of: 1
     * @var        int|null
     */
    protected $currentmonthsubmit;

    /**
     * The value for the tripapprovalreq field.
     *
     * Note: this column has a database default value of: 1
     * @var        int|null
     */
    protected $tripapprovalreq;

    /**
     * The value for the expenseonlyontrip field.
     *
     * Note: this column has a database default value of: 0
     * @var        int
     */
    protected $expenseonlyontrip;

    /**
     * The value for the allowbackdatedtrip field.
     *
     * Note: this column has a database default value of: 1
     * @var        int
     */
    protected $allowbackdatedtrip;

    /**
     * The value for the paymentsystem field.
     *
     * Note: this column has a database default value of: 1
     * @var        int
     */
    protected $paymentsystem;

    /**
     * The value for the auto_settle field.
     *
     * Note: this column has a database default value of: 1
     * @var        int
     */
    protected $auto_settle;

    /**
     * The value for the allowradius field.
     *
     * Note: this column has a database default value of: 1
     * @var        int|null
     */
    protected $allowradius;

    /**
     * The value for the order_seq field.
     *
     * Note: this column has a database default value of: '1'
     * @var        string
     */
    protected $order_seq;

    /**
     * The value for the shippingorder_seq field.
     *
     * Note: this column has a database default value of: '1'
     * @var        string
     */
    protected $shippingorder_seq;

    /**
     * The value for the googlemapkey field.
     *
     * @var        string|null
     */
    protected $googlemapkey;

    /**
     * The value for the workingdaysinweek field.
     *
     * Note: this column has a database default value of: 6
     * @var        int|null
     */
    protected $workingdaysinweek;

    /**
     * The value for the auto_calculated_ta field.
     *
     * @var        int|null
     */
    protected $auto_calculated_ta;

    /**
     * The value for the reporting_days field.
     *
     * @var        string|null
     */
    protected $reporting_days;

    /**
     * The value for the expense_months field.
     *
     * Note: this column has a database default value of: 3
     * @var        int
     */
    protected $expense_months;

    /**
     * @var        ChildExpenseMaster
     */
    protected $aExpenseMasterRelatedByAutoCalculatedTa;

    /**
     * @var        ChildCurrencies
     */
    protected $aCurrencies;

    /**
     * @var        ObjectCollection|ChildAgendatypes[] Collection to store aggregation of ChildAgendatypes objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildAgendatypes> Collection to store aggregation of ChildAgendatypes objects.
     */
    protected $collAgendatypess;
    protected $collAgendatypessPartial;

    /**
     * @var        ObjectCollection|ChildAnnouncements[] Collection to store aggregation of ChildAnnouncements objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildAnnouncements> Collection to store aggregation of ChildAnnouncements objects.
     */
    protected $collAnnouncementss;
    protected $collAnnouncementssPartial;

    /**
     * @var        ObjectCollection|ChildApiKeys[] Collection to store aggregation of ChildApiKeys objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildApiKeys> Collection to store aggregation of ChildApiKeys objects.
     */
    protected $collApiKeyss;
    protected $collApiKeyssPartial;

    /**
     * @var        ObjectCollection|ChildAttendance[] Collection to store aggregation of ChildAttendance objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildAttendance> Collection to store aggregation of ChildAttendance objects.
     */
    protected $collAttendances;
    protected $collAttendancesPartial;

    /**
     * @var        ObjectCollection|ChildBeatOutlets[] Collection to store aggregation of ChildBeatOutlets objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBeatOutlets> Collection to store aggregation of ChildBeatOutlets objects.
     */
    protected $collBeatOutletss;
    protected $collBeatOutletssPartial;

    /**
     * @var        ObjectCollection|ChildBeats[] Collection to store aggregation of ChildBeats objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBeats> Collection to store aggregation of ChildBeats objects.
     */
    protected $collBeatss;
    protected $collBeatssPartial;

    /**
     * @var        ObjectCollection|ChildBranch[] Collection to store aggregation of ChildBranch objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBranch> Collection to store aggregation of ChildBranch objects.
     */
    protected $collBranches;
    protected $collBranchesPartial;

    /**
     * @var        ObjectCollection|ChildBrandCampiagn[] Collection to store aggregation of ChildBrandCampiagn objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandCampiagn> Collection to store aggregation of ChildBrandCampiagn objects.
     */
    protected $collBrandCampiagns;
    protected $collBrandCampiagnsPartial;

    /**
     * @var        ObjectCollection|ChildBrandCampiagnDoctors[] Collection to store aggregation of ChildBrandCampiagnDoctors objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandCampiagnDoctors> Collection to store aggregation of ChildBrandCampiagnDoctors objects.
     */
    protected $collBrandCampiagnDoctorss;
    protected $collBrandCampiagnDoctorssPartial;

    /**
     * @var        ObjectCollection|ChildBrandCampiagnVisitPlan[] Collection to store aggregation of ChildBrandCampiagnVisitPlan objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandCampiagnVisitPlan> Collection to store aggregation of ChildBrandCampiagnVisitPlan objects.
     */
    protected $collBrandCampiagnVisitPlans;
    protected $collBrandCampiagnVisitPlansPartial;

    /**
     * @var        ObjectCollection|ChildBrandCompetition[] Collection to store aggregation of ChildBrandCompetition objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandCompetition> Collection to store aggregation of ChildBrandCompetition objects.
     */
    protected $collBrandCompetitions;
    protected $collBrandCompetitionsPartial;

    /**
     * @var        ObjectCollection|ChildBrandRcpa[] Collection to store aggregation of ChildBrandRcpa objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandRcpa> Collection to store aggregation of ChildBrandRcpa objects.
     */
    protected $collBrandRcpas;
    protected $collBrandRcpasPartial;

    /**
     * @var        ObjectCollection|ChildBrands[] Collection to store aggregation of ChildBrands objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBrands> Collection to store aggregation of ChildBrands objects.
     */
    protected $collBrandss;
    protected $collBrandssPartial;

    /**
     * @var        ObjectCollection|ChildBudgetGroup[] Collection to store aggregation of ChildBudgetGroup objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildBudgetGroup> Collection to store aggregation of ChildBudgetGroup objects.
     */
    protected $collBudgetGroups;
    protected $collBudgetGroupsPartial;

    /**
     * @var        ObjectCollection|ChildCategories[] Collection to store aggregation of ChildCategories objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildCategories> Collection to store aggregation of ChildCategories objects.
     */
    protected $collCategoriess;
    protected $collCategoriessPartial;

    /**
     * @var        ObjectCollection|ChildCheckinoutOutcomes[] Collection to store aggregation of ChildCheckinoutOutcomes objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildCheckinoutOutcomes> Collection to store aggregation of ChildCheckinoutOutcomes objects.
     */
    protected $collCheckinoutOutcomess;
    protected $collCheckinoutOutcomessPartial;

    /**
     * @var        ObjectCollection|ChildCitycategory[] Collection to store aggregation of ChildCitycategory objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildCitycategory> Collection to store aggregation of ChildCitycategory objects.
     */
    protected $collCitycategories;
    protected $collCitycategoriesPartial;

    /**
     * @var        ObjectCollection|ChildClassification[] Collection to store aggregation of ChildClassification objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildClassification> Collection to store aggregation of ChildClassification objects.
     */
    protected $collClassifications;
    protected $collClassificationsPartial;

    /**
     * @var        ObjectCollection|ChildCompetitionMapping[] Collection to store aggregation of ChildCompetitionMapping objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildCompetitionMapping> Collection to store aggregation of ChildCompetitionMapping objects.
     */
    protected $collCompetitionMappings;
    protected $collCompetitionMappingsPartial;

    /**
     * @var        ObjectCollection|ChildCompetitor[] Collection to store aggregation of ChildCompetitor objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildCompetitor> Collection to store aggregation of ChildCompetitor objects.
     */
    protected $collCompetitors;
    protected $collCompetitorsPartial;

    /**
     * @var        ObjectCollection|ChildConfiguration[] Collection to store aggregation of ChildConfiguration objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildConfiguration> Collection to store aggregation of ChildConfiguration objects.
     */
    protected $collConfigurations;
    protected $collConfigurationsPartial;

    /**
     * @var        ObjectCollection|ChildCronCommandLogs[] Collection to store aggregation of ChildCronCommandLogs objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildCronCommandLogs> Collection to store aggregation of ChildCronCommandLogs objects.
     */
    protected $collCronCommandLogss;
    protected $collCronCommandLogssPartial;

    /**
     * @var        ObjectCollection|ChildCronCommands[] Collection to store aggregation of ChildCronCommands objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildCronCommands> Collection to store aggregation of ChildCronCommands objects.
     */
    protected $collCronCommandss;
    protected $collCronCommandssPartial;

    /**
     * @var        ObjectCollection|ChildDailycalls[] Collection to store aggregation of ChildDailycalls objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildDailycalls> Collection to store aggregation of ChildDailycalls objects.
     */
    protected $collDailycallss;
    protected $collDailycallssPartial;

    /**
     * @var        ObjectCollection|ChildDailycallsSgpiout[] Collection to store aggregation of ChildDailycallsSgpiout objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildDailycallsSgpiout> Collection to store aggregation of ChildDailycallsSgpiout objects.
     */
    protected $collDailycallsSgpiouts;
    protected $collDailycallsSgpioutsPartial;

    /**
     * @var        ObjectCollection|ChildDataExceptionLogs[] Collection to store aggregation of ChildDataExceptionLogs objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildDataExceptionLogs> Collection to store aggregation of ChildDataExceptionLogs objects.
     */
    protected $collDataExceptionLogss;
    protected $collDataExceptionLogssPartial;

    /**
     * @var        ObjectCollection|ChildDataExceptions[] Collection to store aggregation of ChildDataExceptions objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildDataExceptions> Collection to store aggregation of ChildDataExceptions objects.
     */
    protected $collDataExceptionss;
    protected $collDataExceptionssPartial;

    /**
     * @var        ObjectCollection|ChildDesignations[] Collection to store aggregation of ChildDesignations objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildDesignations> Collection to store aggregation of ChildDesignations objects.
     */
    protected $collDesignationss;
    protected $collDesignationssPartial;

    /**
     * @var        ObjectCollection|ChildEdFeedbacks[] Collection to store aggregation of ChildEdFeedbacks objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEdFeedbacks> Collection to store aggregation of ChildEdFeedbacks objects.
     */
    protected $collEdFeedbackss;
    protected $collEdFeedbackssPartial;

    /**
     * @var        ObjectCollection|ChildEdPlaylist[] Collection to store aggregation of ChildEdPlaylist objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEdPlaylist> Collection to store aggregation of ChildEdPlaylist objects.
     */
    protected $collEdPlaylists;
    protected $collEdPlaylistsPartial;

    /**
     * @var        ObjectCollection|ChildEdPresentations[] Collection to store aggregation of ChildEdPresentations objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEdPresentations> Collection to store aggregation of ChildEdPresentations objects.
     */
    protected $collEdPresentationss;
    protected $collEdPresentationssPartial;

    /**
     * @var        ObjectCollection|ChildEdSession[] Collection to store aggregation of ChildEdSession objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEdSession> Collection to store aggregation of ChildEdSession objects.
     */
    protected $collEdSessions;
    protected $collEdSessionsPartial;

    /**
     * @var        ObjectCollection|ChildEdStats[] Collection to store aggregation of ChildEdStats objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEdStats> Collection to store aggregation of ChildEdStats objects.
     */
    protected $collEdStatss;
    protected $collEdStatssPartial;

    /**
     * @var        ObjectCollection|ChildEmployee[] Collection to store aggregation of ChildEmployee objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEmployee> Collection to store aggregation of ChildEmployee objects.
     */
    protected $collEmployees;
    protected $collEmployeesPartial;

    /**
     * @var        ObjectCollection|ChildEmployeeIncentive[] Collection to store aggregation of ChildEmployeeIncentive objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEmployeeIncentive> Collection to store aggregation of ChildEmployeeIncentive objects.
     */
    protected $collEmployeeIncentives;
    protected $collEmployeeIncentivesPartial;

    /**
     * @var        ObjectCollection|ChildEventTypes[] Collection to store aggregation of ChildEventTypes objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEventTypes> Collection to store aggregation of ChildEventTypes objects.
     */
    protected $collEventTypess;
    protected $collEventTypessPartial;

    /**
     * @var        ObjectCollection|ChildEvents[] Collection to store aggregation of ChildEvents objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildEvents> Collection to store aggregation of ChildEvents objects.
     */
    protected $collEventss;
    protected $collEventssPartial;

    /**
     * @var        ObjectCollection|ChildExpenseList[] Collection to store aggregation of ChildExpenseList objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildExpenseList> Collection to store aggregation of ChildExpenseList objects.
     */
    protected $collExpenseLists;
    protected $collExpenseListsPartial;

    /**
     * @var        ObjectCollection|ChildExpenseMaster[] Collection to store aggregation of ChildExpenseMaster objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildExpenseMaster> Collection to store aggregation of ChildExpenseMaster objects.
     */
    protected $collExpenseMastersRelatedByCompanyId;
    protected $collExpenseMastersRelatedByCompanyIdPartial;

    /**
     * @var        ObjectCollection|ChildExpensePayments[] Collection to store aggregation of ChildExpensePayments objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildExpensePayments> Collection to store aggregation of ChildExpensePayments objects.
     */
    protected $collExpensePaymentss;
    protected $collExpensePaymentssPartial;

    /**
     * @var        ObjectCollection|ChildExpenses[] Collection to store aggregation of ChildExpenses objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildExpenses> Collection to store aggregation of ChildExpenses objects.
     */
    protected $collExpensess;
    protected $collExpensessPartial;

    /**
     * @var        ObjectCollection|ChildFtpConfigs[] Collection to store aggregation of ChildFtpConfigs objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpConfigs> Collection to store aggregation of ChildFtpConfigs objects.
     */
    protected $collFtpConfigss;
    protected $collFtpConfigssPartial;

    /**
     * @var        ObjectCollection|ChildFtpExportBatches[] Collection to store aggregation of ChildFtpExportBatches objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpExportBatches> Collection to store aggregation of ChildFtpExportBatches objects.
     */
    protected $collFtpExportBatchess;
    protected $collFtpExportBatchessPartial;

    /**
     * @var        ObjectCollection|ChildFtpExportLogs[] Collection to store aggregation of ChildFtpExportLogs objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpExportLogs> Collection to store aggregation of ChildFtpExportLogs objects.
     */
    protected $collFtpExportLogss;
    protected $collFtpExportLogssPartial;

    /**
     * @var        ObjectCollection|ChildFtpImportBatches[] Collection to store aggregation of ChildFtpImportBatches objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpImportBatches> Collection to store aggregation of ChildFtpImportBatches objects.
     */
    protected $collFtpImportBatchess;
    protected $collFtpImportBatchessPartial;

    /**
     * @var        ObjectCollection|ChildFtpImportLogs[] Collection to store aggregation of ChildFtpImportLogs objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpImportLogs> Collection to store aggregation of ChildFtpImportLogs objects.
     */
    protected $collFtpImportLogss;
    protected $collFtpImportLogssPartial;

    /**
     * @var        ObjectCollection|ChildGradeMaster[] Collection to store aggregation of ChildGradeMaster objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildGradeMaster> Collection to store aggregation of ChildGradeMaster objects.
     */
    protected $collGradeMasters;
    protected $collGradeMastersPartial;

    /**
     * @var        ObjectCollection|ChildHolidays[] Collection to store aggregation of ChildHolidays objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildHolidays> Collection to store aggregation of ChildHolidays objects.
     */
    protected $collHolidayss;
    protected $collHolidayssPartial;

    /**
     * @var        ObjectCollection|ChildIntegrationApiLogs[] Collection to store aggregation of ChildIntegrationApiLogs objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildIntegrationApiLogs> Collection to store aggregation of ChildIntegrationApiLogs objects.
     */
    protected $collIntegrationApiLogss;
    protected $collIntegrationApiLogssPartial;

    /**
     * @var        ObjectCollection|ChildLeaveRequest[] Collection to store aggregation of ChildLeaveRequest objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildLeaveRequest> Collection to store aggregation of ChildLeaveRequest objects.
     */
    protected $collLeaveRequests;
    protected $collLeaveRequestsPartial;

    /**
     * @var        ObjectCollection|ChildLeaves[] Collection to store aggregation of ChildLeaves objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildLeaves> Collection to store aggregation of ChildLeaves objects.
     */
    protected $collLeavess;
    protected $collLeavessPartial;

    /**
     * @var        ObjectCollection|ChildMaterialFolders[] Collection to store aggregation of ChildMaterialFolders objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildMaterialFolders> Collection to store aggregation of ChildMaterialFolders objects.
     */
    protected $collMaterialFolderss;
    protected $collMaterialFolderssPartial;

    /**
     * @var        ObjectCollection|ChildMediaFiles[] Collection to store aggregation of ChildMediaFiles objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildMediaFiles> Collection to store aggregation of ChildMediaFiles objects.
     */
    protected $collMediaFiless;
    protected $collMediaFilessPartial;

    /**
     * @var        ObjectCollection|ChildMediaFolders[] Collection to store aggregation of ChildMediaFolders objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildMediaFolders> Collection to store aggregation of ChildMediaFolders objects.
     */
    protected $collMediaFolderss;
    protected $collMediaFolderssPartial;

    /**
     * @var        ObjectCollection|ChildMtp[] Collection to store aggregation of ChildMtp objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildMtp> Collection to store aggregation of ChildMtp objects.
     */
    protected $collMtps;
    protected $collMtpsPartial;

    /**
     * @var        ObjectCollection|ChildMtpDay[] Collection to store aggregation of ChildMtpDay objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildMtpDay> Collection to store aggregation of ChildMtpDay objects.
     */
    protected $collMtpDays;
    protected $collMtpDaysPartial;

    /**
     * @var        ObjectCollection|ChildMtpLogs[] Collection to store aggregation of ChildMtpLogs objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildMtpLogs> Collection to store aggregation of ChildMtpLogs objects.
     */
    protected $collMtpLogss;
    protected $collMtpLogssPartial;

    /**
     * @var        ObjectCollection|ChildOffers[] Collection to store aggregation of ChildOffers objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOffers> Collection to store aggregation of ChildOffers objects.
     */
    protected $collOfferss;
    protected $collOfferssPartial;

    /**
     * @var        ObjectCollection|ChildOnBoardRequest[] Collection to store aggregation of ChildOnBoardRequest objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOnBoardRequest> Collection to store aggregation of ChildOnBoardRequest objects.
     */
    protected $collOnBoardRequests;
    protected $collOnBoardRequestsPartial;

    /**
     * @var        ObjectCollection|ChildOnBoardRequestAddress[] Collection to store aggregation of ChildOnBoardRequestAddress objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOnBoardRequestAddress> Collection to store aggregation of ChildOnBoardRequestAddress objects.
     */
    protected $collOnBoardRequestAddresses;
    protected $collOnBoardRequestAddressesPartial;

    /**
     * @var        ObjectCollection|ChildOnBoardRequiredFields[] Collection to store aggregation of ChildOnBoardRequiredFields objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOnBoardRequiredFields> Collection to store aggregation of ChildOnBoardRequiredFields objects.
     */
    protected $collOnBoardRequiredFieldss;
    protected $collOnBoardRequiredFieldssPartial;

    /**
     * @var        ObjectCollection|ChildOrderLog[] Collection to store aggregation of ChildOrderLog objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOrderLog> Collection to store aggregation of ChildOrderLog objects.
     */
    protected $collOrderLogs;
    protected $collOrderLogsPartial;

    /**
     * @var        ObjectCollection|ChildOrderlines[] Collection to store aggregation of ChildOrderlines objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOrderlines> Collection to store aggregation of ChildOrderlines objects.
     */
    protected $collOrderliness;
    protected $collOrderlinessPartial;

    /**
     * @var        ObjectCollection|ChildOrders[] Collection to store aggregation of ChildOrders objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOrders> Collection to store aggregation of ChildOrders objects.
     */
    protected $collOrderss;
    protected $collOrderssPartial;

    /**
     * @var        ObjectCollection|ChildOrgUnit[] Collection to store aggregation of ChildOrgUnit objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOrgUnit> Collection to store aggregation of ChildOrgUnit objects.
     */
    protected $collOrgUnits;
    protected $collOrgUnitsPartial;

    /**
     * @var        ObjectCollection|ChildOtpRequests[] Collection to store aggregation of ChildOtpRequests objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOtpRequests> Collection to store aggregation of ChildOtpRequests objects.
     */
    protected $collOtpRequestss;
    protected $collOtpRequestssPartial;

    /**
     * @var        ObjectCollection|ChildOutletAddress[] Collection to store aggregation of ChildOutletAddress objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletAddress> Collection to store aggregation of ChildOutletAddress objects.
     */
    protected $collOutletAddresses;
    protected $collOutletAddressesPartial;

    /**
     * @var        ObjectCollection|ChildOutletOrgData[] Collection to store aggregation of ChildOutletOrgData objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletOrgData> Collection to store aggregation of ChildOutletOrgData objects.
     */
    protected $collOutletOrgDatas;
    protected $collOutletOrgDatasPartial;

    /**
     * @var        ObjectCollection|ChildOutletOrgNotes[] Collection to store aggregation of ChildOutletOrgNotes objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletOrgNotes> Collection to store aggregation of ChildOutletOrgNotes objects.
     */
    protected $collOutletOrgNotess;
    protected $collOutletOrgNotessPartial;

    /**
     * @var        ObjectCollection|ChildOutletOutcomes[] Collection to store aggregation of ChildOutletOutcomes objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletOutcomes> Collection to store aggregation of ChildOutletOutcomes objects.
     */
    protected $collOutletOutcomess;
    protected $collOutletOutcomessPartial;

    /**
     * @var        ObjectCollection|ChildOutletStock[] Collection to store aggregation of ChildOutletStock objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletStock> Collection to store aggregation of ChildOutletStock objects.
     */
    protected $collOutletStocks;
    protected $collOutletStocksPartial;

    /**
     * @var        ObjectCollection|ChildOutletStockOtherSummary[] Collection to store aggregation of ChildOutletStockOtherSummary objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletStockOtherSummary> Collection to store aggregation of ChildOutletStockOtherSummary objects.
     */
    protected $collOutletStockOtherSummaries;
    protected $collOutletStockOtherSummariesPartial;

    /**
     * @var        ObjectCollection|ChildOutletStockSummary[] Collection to store aggregation of ChildOutletStockSummary objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletStockSummary> Collection to store aggregation of ChildOutletStockSummary objects.
     */
    protected $collOutletStockSummaries;
    protected $collOutletStockSummariesPartial;

    /**
     * @var        ObjectCollection|ChildOutletTags[] Collection to store aggregation of ChildOutletTags objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletTags> Collection to store aggregation of ChildOutletTags objects.
     */
    protected $collOutletTagss;
    protected $collOutletTagssPartial;

    /**
     * @var        ObjectCollection|ChildOutletType[] Collection to store aggregation of ChildOutletType objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletType> Collection to store aggregation of ChildOutletType objects.
     */
    protected $collOutletTypes;
    protected $collOutletTypesPartial;

    /**
     * @var        ObjectCollection|ChildOutlets[] Collection to store aggregation of ChildOutlets objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutlets> Collection to store aggregation of ChildOutlets objects.
     */
    protected $collOutletss;
    protected $collOutletssPartial;

    /**
     * @var        ObjectCollection|ChildPolicyMaster[] Collection to store aggregation of ChildPolicyMaster objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildPolicyMaster> Collection to store aggregation of ChildPolicyMaster objects.
     */
    protected $collPolicyMasters;
    protected $collPolicyMastersPartial;

    /**
     * @var        ObjectCollection|ChildPolicykeys[] Collection to store aggregation of ChildPolicykeys objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildPolicykeys> Collection to store aggregation of ChildPolicykeys objects.
     */
    protected $collPolicykeyss;
    protected $collPolicykeyssPartial;

    /**
     * @var        ObjectCollection|ChildPositions[] Collection to store aggregation of ChildPositions objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildPositions> Collection to store aggregation of ChildPositions objects.
     */
    protected $collPositionss;
    protected $collPositionssPartial;

    /**
     * @var        ObjectCollection|ChildPricebooklines[] Collection to store aggregation of ChildPricebooklines objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildPricebooklines> Collection to store aggregation of ChildPricebooklines objects.
     */
    protected $collPricebookliness;
    protected $collPricebooklinessPartial;

    /**
     * @var        ObjectCollection|ChildPricebooks[] Collection to store aggregation of ChildPricebooks objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildPricebooks> Collection to store aggregation of ChildPricebooks objects.
     */
    protected $collPricebookss;
    protected $collPricebookssPartial;

    /**
     * @var        ObjectCollection|ChildProducts[] Collection to store aggregation of ChildProducts objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildProducts> Collection to store aggregation of ChildProducts objects.
     */
    protected $collProductss;
    protected $collProductssPartial;

    /**
     * @var        ObjectCollection|ChildReminders[] Collection to store aggregation of ChildReminders objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildReminders> Collection to store aggregation of ChildReminders objects.
     */
    protected $collReminderss;
    protected $collReminderssPartial;

    /**
     * @var        ObjectCollection|ChildSgpiAccounts[] Collection to store aggregation of ChildSgpiAccounts objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildSgpiAccounts> Collection to store aggregation of ChildSgpiAccounts objects.
     */
    protected $collSgpiAccountss;
    protected $collSgpiAccountssPartial;

    /**
     * @var        ObjectCollection|ChildSgpiMaster[] Collection to store aggregation of ChildSgpiMaster objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildSgpiMaster> Collection to store aggregation of ChildSgpiMaster objects.
     */
    protected $collSgpiMasters;
    protected $collSgpiMastersPartial;

    /**
     * @var        ObjectCollection|ChildSgpiTrans[] Collection to store aggregation of ChildSgpiTrans objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildSgpiTrans> Collection to store aggregation of ChildSgpiTrans objects.
     */
    protected $collSgpiTranss;
    protected $collSgpiTranssPartial;

    /**
     * @var        ObjectCollection|ChildShiftTypes[] Collection to store aggregation of ChildShiftTypes objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildShiftTypes> Collection to store aggregation of ChildShiftTypes objects.
     */
    protected $collShiftTypess;
    protected $collShiftTypessPartial;

    /**
     * @var        ObjectCollection|ChildShippinglines[] Collection to store aggregation of ChildShippinglines objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildShippinglines> Collection to store aggregation of ChildShippinglines objects.
     */
    protected $collShippingliness;
    protected $collShippinglinessPartial;

    /**
     * @var        ObjectCollection|ChildShippingorder[] Collection to store aggregation of ChildShippingorder objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildShippingorder> Collection to store aggregation of ChildShippingorder objects.
     */
    protected $collShippingorders;
    protected $collShippingordersPartial;

    /**
     * @var        ObjectCollection|ChildStockTransaction[] Collection to store aggregation of ChildStockTransaction objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildStockTransaction> Collection to store aggregation of ChildStockTransaction objects.
     */
    protected $collStockTransactions;
    protected $collStockTransactionsPartial;

    /**
     * @var        ObjectCollection|ChildStockVoucher[] Collection to store aggregation of ChildStockVoucher objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildStockVoucher> Collection to store aggregation of ChildStockVoucher objects.
     */
    protected $collStockVouchers;
    protected $collStockVouchersPartial;

    /**
     * @var        ObjectCollection|ChildSurvey[] Collection to store aggregation of ChildSurvey objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildSurvey> Collection to store aggregation of ChildSurvey objects.
     */
    protected $collSurveys;
    protected $collSurveysPartial;

    /**
     * @var        ObjectCollection|ChildSurveyCategory[] Collection to store aggregation of ChildSurveyCategory objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildSurveyCategory> Collection to store aggregation of ChildSurveyCategory objects.
     */
    protected $collSurveyCategories;
    protected $collSurveyCategoriesPartial;

    /**
     * @var        ObjectCollection|ChildSurveyQuestion[] Collection to store aggregation of ChildSurveyQuestion objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildSurveyQuestion> Collection to store aggregation of ChildSurveyQuestion objects.
     */
    protected $collSurveyQuestions;
    protected $collSurveyQuestionsPartial;

    /**
     * @var        ObjectCollection|ChildSurveySubmited[] Collection to store aggregation of ChildSurveySubmited objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildSurveySubmited> Collection to store aggregation of ChildSurveySubmited objects.
     */
    protected $collSurveySubmiteds;
    protected $collSurveySubmitedsPartial;

    /**
     * @var        ObjectCollection|ChildTaConfiguration[] Collection to store aggregation of ChildTaConfiguration objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTaConfiguration> Collection to store aggregation of ChildTaConfiguration objects.
     */
    protected $collTaConfigurations;
    protected $collTaConfigurationsPartial;

    /**
     * @var        ObjectCollection|ChildTags[] Collection to store aggregation of ChildTags objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTags> Collection to store aggregation of ChildTags objects.
     */
    protected $collTagss;
    protected $collTagssPartial;

    /**
     * @var        ObjectCollection|ChildTerritories[] Collection to store aggregation of ChildTerritories objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTerritories> Collection to store aggregation of ChildTerritories objects.
     */
    protected $collTerritoriess;
    protected $collTerritoriessPartial;

    /**
     * @var        ObjectCollection|ChildTerritoryTowns[] Collection to store aggregation of ChildTerritoryTowns objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTerritoryTowns> Collection to store aggregation of ChildTerritoryTowns objects.
     */
    protected $collTerritoryTownss;
    protected $collTerritoryTownssPartial;

    /**
     * @var        ObjectCollection|ChildTicketReplies[] Collection to store aggregation of ChildTicketReplies objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTicketReplies> Collection to store aggregation of ChildTicketReplies objects.
     */
    protected $collTicketRepliess;
    protected $collTicketRepliessPartial;

    /**
     * @var        ObjectCollection|ChildTicketType[] Collection to store aggregation of ChildTicketType objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTicketType> Collection to store aggregation of ChildTicketType objects.
     */
    protected $collTicketTypes;
    protected $collTicketTypesPartial;

    /**
     * @var        ObjectCollection|ChildTickets[] Collection to store aggregation of ChildTickets objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTickets> Collection to store aggregation of ChildTickets objects.
     */
    protected $collTicketss;
    protected $collTicketssPartial;

    /**
     * @var        ObjectCollection|ChildTourplans[] Collection to store aggregation of ChildTourplans objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTourplans> Collection to store aggregation of ChildTourplans objects.
     */
    protected $collTourplanss;
    protected $collTourplanssPartial;

    /**
     * @var        ObjectCollection|ChildTransactions[] Collection to store aggregation of ChildTransactions objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildTransactions> Collection to store aggregation of ChildTransactions objects.
     */
    protected $collTransactionss;
    protected $collTransactionssPartial;

    /**
     * @var        ObjectCollection|ChildUsers[] Collection to store aggregation of ChildUsers objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildUsers> Collection to store aggregation of ChildUsers objects.
     */
    protected $collUserss;
    protected $collUserssPartial;

    /**
     * @var        ObjectCollection|ChildWdbSyncLog[] Collection to store aggregation of ChildWdbSyncLog objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildWdbSyncLog> Collection to store aggregation of ChildWdbSyncLog objects.
     */
    protected $collWdbSyncLogs;
    protected $collWdbSyncLogsPartial;

    /**
     * @var        ObjectCollection|ChildWfRequests[] Collection to store aggregation of ChildWfRequests objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildWfRequests> Collection to store aggregation of ChildWfRequests objects.
     */
    protected $collWfRequestss;
    protected $collWfRequestssPartial;

    /**
     * @var        ObjectCollection|ChildStp[] Collection to store aggregation of ChildStp objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildStp> Collection to store aggregation of ChildStp objects.
     */
    protected $collStps;
    protected $collStpsPartial;

    /**
     * @var        ObjectCollection|ChildStpWeek[] Collection to store aggregation of ChildStpWeek objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildStpWeek> Collection to store aggregation of ChildStpWeek objects.
     */
    protected $collStpWeeks;
    protected $collStpWeeksPartial;

    /**
     * @var        ObjectCollection|ChildOutletOrgDataKeys[] Collection to store aggregation of ChildOutletOrgDataKeys objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletOrgDataKeys> Collection to store aggregation of ChildOutletOrgDataKeys objects.
     */
    protected $collOutletOrgDataKeyss;
    protected $collOutletOrgDataKeyssPartial;

    /**
     * @var        ObjectCollection|ChildNotificationConfiguration[] Collection to store aggregation of ChildNotificationConfiguration objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildNotificationConfiguration> Collection to store aggregation of ChildNotificationConfiguration objects.
     */
    protected $collNotificationConfigurations;
    protected $collNotificationConfigurationsPartial;

    /**
     * @var        ObjectCollection|ChildLeaveType[] Collection to store aggregation of ChildLeaveType objects.
     * @phpstan-var ObjectCollection&\Traversable<ChildLeaveType> Collection to store aggregation of ChildLeaveType objects.
     */
    protected $collLeaveTypes;
    protected $collLeaveTypesPartial;

    /**
     * Flag to prevent endless save loop, if this object is referenced
     * by another object which falls in this transaction.
     *
     * @var bool
     */
    protected $alreadyInSave = false;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildAgendatypes[]
     * @phpstan-var ObjectCollection&\Traversable<ChildAgendatypes>
     */
    protected $agendatypessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildAnnouncements[]
     * @phpstan-var ObjectCollection&\Traversable<ChildAnnouncements>
     */
    protected $announcementssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildApiKeys[]
     * @phpstan-var ObjectCollection&\Traversable<ChildApiKeys>
     */
    protected $apiKeyssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildAttendance[]
     * @phpstan-var ObjectCollection&\Traversable<ChildAttendance>
     */
    protected $attendancesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBeatOutlets[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBeatOutlets>
     */
    protected $beatOutletssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBeats[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBeats>
     */
    protected $beatssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBranch[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBranch>
     */
    protected $branchesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBrandCampiagn[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandCampiagn>
     */
    protected $brandCampiagnsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBrandCampiagnDoctors[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandCampiagnDoctors>
     */
    protected $brandCampiagnDoctorssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBrandCampiagnVisitPlan[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandCampiagnVisitPlan>
     */
    protected $brandCampiagnVisitPlansScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBrandCompetition[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandCompetition>
     */
    protected $brandCompetitionsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBrandRcpa[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBrandRcpa>
     */
    protected $brandRcpasScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBrands[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBrands>
     */
    protected $brandssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildBudgetGroup[]
     * @phpstan-var ObjectCollection&\Traversable<ChildBudgetGroup>
     */
    protected $budgetGroupsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildCategories[]
     * @phpstan-var ObjectCollection&\Traversable<ChildCategories>
     */
    protected $categoriessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildCheckinoutOutcomes[]
     * @phpstan-var ObjectCollection&\Traversable<ChildCheckinoutOutcomes>
     */
    protected $checkinoutOutcomessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildCitycategory[]
     * @phpstan-var ObjectCollection&\Traversable<ChildCitycategory>
     */
    protected $citycategoriesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildClassification[]
     * @phpstan-var ObjectCollection&\Traversable<ChildClassification>
     */
    protected $classificationsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildCompetitionMapping[]
     * @phpstan-var ObjectCollection&\Traversable<ChildCompetitionMapping>
     */
    protected $competitionMappingsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildCompetitor[]
     * @phpstan-var ObjectCollection&\Traversable<ChildCompetitor>
     */
    protected $competitorsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildConfiguration[]
     * @phpstan-var ObjectCollection&\Traversable<ChildConfiguration>
     */
    protected $configurationsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildCronCommandLogs[]
     * @phpstan-var ObjectCollection&\Traversable<ChildCronCommandLogs>
     */
    protected $cronCommandLogssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildCronCommands[]
     * @phpstan-var ObjectCollection&\Traversable<ChildCronCommands>
     */
    protected $cronCommandssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildDailycalls[]
     * @phpstan-var ObjectCollection&\Traversable<ChildDailycalls>
     */
    protected $dailycallssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildDailycallsSgpiout[]
     * @phpstan-var ObjectCollection&\Traversable<ChildDailycallsSgpiout>
     */
    protected $dailycallsSgpioutsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildDataExceptionLogs[]
     * @phpstan-var ObjectCollection&\Traversable<ChildDataExceptionLogs>
     */
    protected $dataExceptionLogssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildDataExceptions[]
     * @phpstan-var ObjectCollection&\Traversable<ChildDataExceptions>
     */
    protected $dataExceptionssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildDesignations[]
     * @phpstan-var ObjectCollection&\Traversable<ChildDesignations>
     */
    protected $designationssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEdFeedbacks[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEdFeedbacks>
     */
    protected $edFeedbackssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEdPlaylist[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEdPlaylist>
     */
    protected $edPlaylistsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEdPresentations[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEdPresentations>
     */
    protected $edPresentationssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEdSession[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEdSession>
     */
    protected $edSessionsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEdStats[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEdStats>
     */
    protected $edStatssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEmployee[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEmployee>
     */
    protected $employeesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEmployeeIncentive[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEmployeeIncentive>
     */
    protected $employeeIncentivesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEventTypes[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEventTypes>
     */
    protected $eventTypessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildEvents[]
     * @phpstan-var ObjectCollection&\Traversable<ChildEvents>
     */
    protected $eventssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildExpenseList[]
     * @phpstan-var ObjectCollection&\Traversable<ChildExpenseList>
     */
    protected $expenseListsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildExpenseMaster[]
     * @phpstan-var ObjectCollection&\Traversable<ChildExpenseMaster>
     */
    protected $expenseMastersRelatedByCompanyIdScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildExpensePayments[]
     * @phpstan-var ObjectCollection&\Traversable<ChildExpensePayments>
     */
    protected $expensePaymentssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildExpenses[]
     * @phpstan-var ObjectCollection&\Traversable<ChildExpenses>
     */
    protected $expensessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildFtpConfigs[]
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpConfigs>
     */
    protected $ftpConfigssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildFtpExportBatches[]
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpExportBatches>
     */
    protected $ftpExportBatchessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildFtpExportLogs[]
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpExportLogs>
     */
    protected $ftpExportLogssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildFtpImportBatches[]
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpImportBatches>
     */
    protected $ftpImportBatchessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildFtpImportLogs[]
     * @phpstan-var ObjectCollection&\Traversable<ChildFtpImportLogs>
     */
    protected $ftpImportLogssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildGradeMaster[]
     * @phpstan-var ObjectCollection&\Traversable<ChildGradeMaster>
     */
    protected $gradeMastersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildHolidays[]
     * @phpstan-var ObjectCollection&\Traversable<ChildHolidays>
     */
    protected $holidayssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildIntegrationApiLogs[]
     * @phpstan-var ObjectCollection&\Traversable<ChildIntegrationApiLogs>
     */
    protected $integrationApiLogssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildLeaveRequest[]
     * @phpstan-var ObjectCollection&\Traversable<ChildLeaveRequest>
     */
    protected $leaveRequestsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildLeaves[]
     * @phpstan-var ObjectCollection&\Traversable<ChildLeaves>
     */
    protected $leavessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildMaterialFolders[]
     * @phpstan-var ObjectCollection&\Traversable<ChildMaterialFolders>
     */
    protected $materialFolderssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildMediaFiles[]
     * @phpstan-var ObjectCollection&\Traversable<ChildMediaFiles>
     */
    protected $mediaFilessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildMediaFolders[]
     * @phpstan-var ObjectCollection&\Traversable<ChildMediaFolders>
     */
    protected $mediaFolderssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildMtp[]
     * @phpstan-var ObjectCollection&\Traversable<ChildMtp>
     */
    protected $mtpsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildMtpDay[]
     * @phpstan-var ObjectCollection&\Traversable<ChildMtpDay>
     */
    protected $mtpDaysScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildMtpLogs[]
     * @phpstan-var ObjectCollection&\Traversable<ChildMtpLogs>
     */
    protected $mtpLogssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOffers[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOffers>
     */
    protected $offerssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOnBoardRequest[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOnBoardRequest>
     */
    protected $onBoardRequestsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOnBoardRequestAddress[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOnBoardRequestAddress>
     */
    protected $onBoardRequestAddressesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOnBoardRequiredFields[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOnBoardRequiredFields>
     */
    protected $onBoardRequiredFieldssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOrderLog[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOrderLog>
     */
    protected $orderLogsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOrderlines[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOrderlines>
     */
    protected $orderlinessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOrders[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOrders>
     */
    protected $orderssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOrgUnit[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOrgUnit>
     */
    protected $orgUnitsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOtpRequests[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOtpRequests>
     */
    protected $otpRequestssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletAddress[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletAddress>
     */
    protected $outletAddressesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletOrgData[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletOrgData>
     */
    protected $outletOrgDatasScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletOrgNotes[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletOrgNotes>
     */
    protected $outletOrgNotessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletOutcomes[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletOutcomes>
     */
    protected $outletOutcomessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletStock[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletStock>
     */
    protected $outletStocksScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletStockOtherSummary[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletStockOtherSummary>
     */
    protected $outletStockOtherSummariesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletStockSummary[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletStockSummary>
     */
    protected $outletStockSummariesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletTags[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletTags>
     */
    protected $outletTagssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletType[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletType>
     */
    protected $outletTypesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutlets[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutlets>
     */
    protected $outletssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildPolicyMaster[]
     * @phpstan-var ObjectCollection&\Traversable<ChildPolicyMaster>
     */
    protected $policyMastersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildPolicykeys[]
     * @phpstan-var ObjectCollection&\Traversable<ChildPolicykeys>
     */
    protected $policykeyssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildPositions[]
     * @phpstan-var ObjectCollection&\Traversable<ChildPositions>
     */
    protected $positionssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildPricebooklines[]
     * @phpstan-var ObjectCollection&\Traversable<ChildPricebooklines>
     */
    protected $pricebooklinessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildPricebooks[]
     * @phpstan-var ObjectCollection&\Traversable<ChildPricebooks>
     */
    protected $pricebookssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildProducts[]
     * @phpstan-var ObjectCollection&\Traversable<ChildProducts>
     */
    protected $productssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildReminders[]
     * @phpstan-var ObjectCollection&\Traversable<ChildReminders>
     */
    protected $reminderssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildSgpiAccounts[]
     * @phpstan-var ObjectCollection&\Traversable<ChildSgpiAccounts>
     */
    protected $sgpiAccountssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildSgpiMaster[]
     * @phpstan-var ObjectCollection&\Traversable<ChildSgpiMaster>
     */
    protected $sgpiMastersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildSgpiTrans[]
     * @phpstan-var ObjectCollection&\Traversable<ChildSgpiTrans>
     */
    protected $sgpiTranssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildShiftTypes[]
     * @phpstan-var ObjectCollection&\Traversable<ChildShiftTypes>
     */
    protected $shiftTypessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildShippinglines[]
     * @phpstan-var ObjectCollection&\Traversable<ChildShippinglines>
     */
    protected $shippinglinessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildShippingorder[]
     * @phpstan-var ObjectCollection&\Traversable<ChildShippingorder>
     */
    protected $shippingordersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildStockTransaction[]
     * @phpstan-var ObjectCollection&\Traversable<ChildStockTransaction>
     */
    protected $stockTransactionsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildStockVoucher[]
     * @phpstan-var ObjectCollection&\Traversable<ChildStockVoucher>
     */
    protected $stockVouchersScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildSurvey[]
     * @phpstan-var ObjectCollection&\Traversable<ChildSurvey>
     */
    protected $surveysScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildSurveyCategory[]
     * @phpstan-var ObjectCollection&\Traversable<ChildSurveyCategory>
     */
    protected $surveyCategoriesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildSurveyQuestion[]
     * @phpstan-var ObjectCollection&\Traversable<ChildSurveyQuestion>
     */
    protected $surveyQuestionsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildSurveySubmited[]
     * @phpstan-var ObjectCollection&\Traversable<ChildSurveySubmited>
     */
    protected $surveySubmitedsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTaConfiguration[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTaConfiguration>
     */
    protected $taConfigurationsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTags[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTags>
     */
    protected $tagssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTerritories[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTerritories>
     */
    protected $territoriessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTerritoryTowns[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTerritoryTowns>
     */
    protected $territoryTownssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTicketReplies[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTicketReplies>
     */
    protected $ticketRepliessScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTicketType[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTicketType>
     */
    protected $ticketTypesScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTickets[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTickets>
     */
    protected $ticketssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTourplans[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTourplans>
     */
    protected $tourplanssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildTransactions[]
     * @phpstan-var ObjectCollection&\Traversable<ChildTransactions>
     */
    protected $transactionssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildUsers[]
     * @phpstan-var ObjectCollection&\Traversable<ChildUsers>
     */
    protected $userssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildWdbSyncLog[]
     * @phpstan-var ObjectCollection&\Traversable<ChildWdbSyncLog>
     */
    protected $wdbSyncLogsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildWfRequests[]
     * @phpstan-var ObjectCollection&\Traversable<ChildWfRequests>
     */
    protected $wfRequestssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildStp[]
     * @phpstan-var ObjectCollection&\Traversable<ChildStp>
     */
    protected $stpsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildStpWeek[]
     * @phpstan-var ObjectCollection&\Traversable<ChildStpWeek>
     */
    protected $stpWeeksScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildOutletOrgDataKeys[]
     * @phpstan-var ObjectCollection&\Traversable<ChildOutletOrgDataKeys>
     */
    protected $outletOrgDataKeyssScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildNotificationConfiguration[]
     * @phpstan-var ObjectCollection&\Traversable<ChildNotificationConfiguration>
     */
    protected $notificationConfigurationsScheduledForDeletion = null;

    /**
     * An array of objects scheduled for deletion.
     * @var ObjectCollection|ChildLeaveType[]
     * @phpstan-var ObjectCollection&\Traversable<ChildLeaveType>
     */
    protected $leaveTypesScheduledForDeletion = null;

    /**
     * Applies default values to this object.
     * This method should be called from the object's constructor (or
     * equivalent initialization method).
     * @see __construct()
     */
    public function applyDefaultValues(): void
    {
        $this->company_code = '0';
        $this->company_first_setup = 0;
        $this->owner_email = '0';
        $this->expense_reminder = 0;
        $this->currentmonthsubmit = 1;
        $this->tripapprovalreq = 1;
        $this->expenseonlyontrip = 0;
        $this->allowbackdatedtrip = 1;
        $this->paymentsystem = 1;
        $this->auto_settle = 1;
        $this->allowradius = 1;
        $this->order_seq = '1';
        $this->shippingorder_seq = '1';
        $this->workingdaysinweek = 6;
        $this->expense_months = 3;
    }

    /**
     * Initializes internal state of entities\Base\Company object.
     * @see applyDefaults()
     */
    public function __construct()
    {
        $this->applyDefaultValues();
    }

    /**
     * Returns whether the object has been modified.
     *
     * @return bool True if the object has been modified.
     */
    public function isModified(): bool
    {
        return !!$this->modifiedColumns;
    }

    /**
     * Has specified column been modified?
     *
     * @param string $col column fully qualified name (TableMap::TYPE_COLNAME), e.g. Book::AUTHOR_ID
     * @return bool True if $col has been modified.
     */
    public function isColumnModified(string $col): bool
    {
        return $this->modifiedColumns && isset($this->modifiedColumns[$col]);
    }

    /**
     * Get the columns that have been modified in this object.
     * @return array A unique list of the modified column names for this object.
     */
    public function getModifiedColumns(): array
    {
        return $this->modifiedColumns ? array_keys($this->modifiedColumns) : [];
    }

    /**
     * Returns whether the object has ever been saved.  This will
     * be false, if the object was retrieved from storage or was created
     * and then saved.
     *
     * @return bool True, if the object has never been persisted.
     */
    public function isNew(): bool
    {
        return $this->new;
    }

    /**
     * Setter for the isNew attribute.  This method will be called
     * by Propel-generated children and objects.
     *
     * @param bool $b the state of the object.
     */
    public function setNew(bool $b): void
    {
        $this->new = $b;
    }

    /**
     * Whether this object has been deleted.
     * @return bool The deleted state of this object.
     */
    public function isDeleted(): bool
    {
        return $this->deleted;
    }

    /**
     * Specify whether this object has been deleted.
     * @param bool $b The deleted state of this object.
     * @return void
     */
    public function setDeleted(bool $b): void
    {
        $this->deleted = $b;
    }

    /**
     * Sets the modified state for the object to be false.
     * @param string $col If supplied, only the specified column is reset.
     * @return void
     */
    public function resetModified(?string $col = null): void
    {
        if (null !== $col) {
            unset($this->modifiedColumns[$col]);
        } else {
            $this->modifiedColumns = [];
        }
    }

    /**
     * Compares this with another <code>Company</code> instance.  If
     * <code>obj</code> is an instance of <code>Company</code>, delegates to
     * <code>equals(Company)</code>.  Otherwise, returns <code>false</code>.
     *
     * @param mixed $obj The object to compare to.
     * @return bool Whether equal to the object specified.
     */
    public function equals($obj): bool
    {
        if (!$obj instanceof static) {
            return false;
        }

        if ($this === $obj) {
            return true;
        }

        if (null === $this->getPrimaryKey() || null === $obj->getPrimaryKey()) {
            return false;
        }

        return $this->getPrimaryKey() === $obj->getPrimaryKey();
    }

    /**
     * Get the associative array of the virtual columns in this object
     *
     * @return array
     */
    public function getVirtualColumns(): array
    {
        return $this->virtualColumns;
    }

    /**
     * Checks the existence of a virtual column in this object
     *
     * @param string $name The virtual column name
     * @return bool
     */
    public function hasVirtualColumn(string $name): bool
    {
        return array_key_exists($name, $this->virtualColumns);
    }

    /**
     * Get the value of a virtual column in this object
     *
     * @param string $name The virtual column name
     * @return mixed
     *
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getVirtualColumn(string $name)
    {
        if (!$this->hasVirtualColumn($name)) {
            throw new PropelException(sprintf('Cannot get value of nonexistent virtual column `%s`.', $name));
        }

        return $this->virtualColumns[$name];
    }

    /**
     * Set the value of a virtual column in this object
     *
     * @param string $name The virtual column name
     * @param mixed $value The value to give to the virtual column
     *
     * @return $this The current object, for fluid interface
     */
    public function setVirtualColumn(string $name, $value)
    {
        $this->virtualColumns[$name] = $value;

        return $this;
    }

    /**
     * Logs a message using Propel::log().
     *
     * @param string $msg
     * @param int $priority One of the Propel::LOG_* logging levels
     * @return void
     */
    protected function log(string $msg, int $priority = Propel::LOG_INFO): void
    {
        Propel::log(get_class($this) . ': ' . $msg, $priority);
    }

    /**
     * Export the current object properties to a string, using a given parser format
     * <code>
     * $book = BookQuery::create()->findPk(9012);
     * echo $book->exportTo('JSON');
     *  => {"Id":9012,"Title":"Don Juan","ISBN":"0140422161","Price":12.99,"PublisherId":1234,"AuthorId":5678}');
     * </code>
     *
     * @param \Propel\Runtime\Parser\AbstractParser|string $parser An AbstractParser instance, or a format name ('XML', 'YAML', 'JSON', 'CSV')
     * @param bool $includeLazyLoadColumns (optional) Whether to include lazy load(ed) columns. Defaults to TRUE.
     * @param string $keyType (optional) One of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_CAMELNAME, TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM. Defaults to TableMap::TYPE_PHPNAME.
     * @return string The exported data
     */
    public function exportTo($parser, bool $includeLazyLoadColumns = true, string $keyType = TableMap::TYPE_PHPNAME): string
    {
        if (!$parser instanceof AbstractParser) {
            $parser = AbstractParser::getParser($parser);
        }

        return $parser->fromArray($this->toArray($keyType, $includeLazyLoadColumns, array(), true));
    }

    /**
     * Clean up internal collections prior to serializing
     * Avoids recursive loops that turn into segmentation faults when serializing
     *
     * @return array<string>
     */
    public function __sleep(): array
    {
        $this->clearAllReferences();

        $cls = new \ReflectionClass($this);
        $propertyNames = [];
        $serializableProperties = array_diff($cls->getProperties(), $cls->getProperties(\ReflectionProperty::IS_STATIC));

        foreach($serializableProperties as $property) {
            $propertyNames[] = $property->getName();
        }

        return $propertyNames;
    }

    /**
     * Get the [company_id] column value.
     *
     * @return int
     */
    public function getCompanyId()
    {
        return $this->company_id;
    }

    /**
     * Get the [company_code] column value.
     *
     * @return string
     */
    public function getCompanyCode()
    {
        return $this->company_code;
    }

    /**
     * Get the [company_name] column value.
     *
     * @return string|null
     */
    public function getCompanyName()
    {
        return $this->company_name;
    }

    /**
     * Get the [owner_name] column value.
     *
     * @return string|null
     */
    public function getOwnerName()
    {
        return $this->owner_name;
    }

    /**
     * Get the [company_phone_number] column value.
     *
     * @return string|null
     */
    public function getCompanyPhoneNumber()
    {
        return $this->company_phone_number;
    }

    /**
     * Get the [company_contact_number] column value.
     *
     * @return string|null
     */
    public function getCompanyContactNumber()
    {
        return $this->company_contact_number;
    }

    /**
     * Get the [company_logo] column value.
     *
     * @return string|null
     */
    public function getCompanyLogo()
    {
        return $this->company_logo;
    }

    /**
     * Get the [company_address_1] column value.
     *
     * @return string|null
     */
    public function getCompanyAddress1()
    {
        return $this->company_address_1;
    }

    /**
     * Get the [company_address_2] column value.
     *
     * @return string|null
     */
    public function getCompanyAddress2()
    {
        return $this->company_address_2;
    }

    /**
     * Get the [company_default_currency] column value.
     *
     * @return int|null
     */
    public function getCompanyDefaultCurrency()
    {
        return $this->company_default_currency;
    }

    /**
     * Get the [timezone] column value.
     *
     * @return string|null
     */
    public function getTimezone()
    {
        return $this->timezone;
    }

    /**
     * Get the [company_first_setup] column value.
     *
     * @return int|null
     */
    public function getCompanyFirstSetup()
    {
        return $this->company_first_setup;
    }

    /**
     * Get the [owner_email] column value.
     *
     * @return string|null
     */
    public function getOwnerEmail()
    {
        return $this->owner_email;
    }

    /**
     * Get the [expense_reminder] column value.
     *
     * @return int|null
     */
    public function getExpenseReminder()
    {
        return $this->expense_reminder;
    }

    /**
     * Get the [currentmonthsubmit] column value.
     *
     * @return int|null
     */
    public function getCurrentmonthsubmit()
    {
        return $this->currentmonthsubmit;
    }

    /**
     * Get the [tripapprovalreq] column value.
     *
     * @return int|null
     */
    public function getTripapprovalreq()
    {
        return $this->tripapprovalreq;
    }

    /**
     * Get the [expenseonlyontrip] column value.
     *
     * @return int
     */
    public function getExpenseonlyontrip()
    {
        return $this->expenseonlyontrip;
    }

    /**
     * Get the [allowbackdatedtrip] column value.
     *
     * @return int
     */
    public function getAllowbackdatedtrip()
    {
        return $this->allowbackdatedtrip;
    }

    /**
     * Get the [paymentsystem] column value.
     *
     * @return int
     */
    public function getPaymentsystem()
    {
        return $this->paymentsystem;
    }

    /**
     * Get the [auto_settle] column value.
     *
     * @return int
     */
    public function getAutoSettle()
    {
        return $this->auto_settle;
    }

    /**
     * Get the [allowradius] column value.
     *
     * @return int|null
     */
    public function getAllowradius()
    {
        return $this->allowradius;
    }

    /**
     * Get the [order_seq] column value.
     *
     * @return string
     */
    public function getOrderSeq()
    {
        return $this->order_seq;
    }

    /**
     * Get the [shippingorder_seq] column value.
     *
     * @return string
     */
    public function getShippingorderSeq()
    {
        return $this->shippingorder_seq;
    }

    /**
     * Get the [googlemapkey] column value.
     *
     * @return string|null
     */
    public function getGooglemapkey()
    {
        return $this->googlemapkey;
    }

    /**
     * Get the [workingdaysinweek] column value.
     *
     * @return int|null
     */
    public function getWorkingdaysinweek()
    {
        return $this->workingdaysinweek;
    }

    /**
     * Get the [auto_calculated_ta] column value.
     *
     * @return int|null
     */
    public function getAutoCalculatedTa()
    {
        return $this->auto_calculated_ta;
    }

    /**
     * Get the [reporting_days] column value.
     *
     * @return string|null
     */
    public function getReportingDays()
    {
        return $this->reporting_days;
    }

    /**
     * Get the [expense_months] column value.
     *
     * @return int
     */
    public function getExpenseMonths()
    {
        return $this->expense_months;
    }

    /**
     * Set the value of [company_id] column.
     *
     * @param int $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyId($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->company_id !== $v) {
            $this->company_id = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_ID] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_code] column.
     *
     * @param string $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyCode($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->company_code !== $v) {
            $this->company_code = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_CODE] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_name] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyName($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->company_name !== $v) {
            $this->company_name = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_NAME] = true;
        }

        return $this;
    }

    /**
     * Set the value of [owner_name] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setOwnerName($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->owner_name !== $v) {
            $this->owner_name = $v;
            $this->modifiedColumns[CompanyTableMap::COL_OWNER_NAME] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_phone_number] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyPhoneNumber($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->company_phone_number !== $v) {
            $this->company_phone_number = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_PHONE_NUMBER] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_contact_number] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyContactNumber($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->company_contact_number !== $v) {
            $this->company_contact_number = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_CONTACT_NUMBER] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_logo] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyLogo($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->company_logo !== $v) {
            $this->company_logo = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_LOGO] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_address_1] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyAddress1($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->company_address_1 !== $v) {
            $this->company_address_1 = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_ADDRESS_1] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_address_2] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyAddress2($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->company_address_2 !== $v) {
            $this->company_address_2 = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_ADDRESS_2] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_default_currency] column.
     *
     * @param int|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyDefaultCurrency($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->company_default_currency !== $v) {
            $this->company_default_currency = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_DEFAULT_CURRENCY] = true;
        }

        if ($this->aCurrencies !== null && $this->aCurrencies->getCurrencyId() !== $v) {
            $this->aCurrencies = null;
        }

        return $this;
    }

    /**
     * Set the value of [timezone] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setTimezone($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->timezone !== $v) {
            $this->timezone = $v;
            $this->modifiedColumns[CompanyTableMap::COL_TIMEZONE] = true;
        }

        return $this;
    }

    /**
     * Set the value of [company_first_setup] column.
     *
     * @param int|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCompanyFirstSetup($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->company_first_setup !== $v) {
            $this->company_first_setup = $v;
            $this->modifiedColumns[CompanyTableMap::COL_COMPANY_FIRST_SETUP] = true;
        }

        return $this;
    }

    /**
     * Set the value of [owner_email] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setOwnerEmail($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->owner_email !== $v) {
            $this->owner_email = $v;
            $this->modifiedColumns[CompanyTableMap::COL_OWNER_EMAIL] = true;
        }

        return $this;
    }

    /**
     * Set the value of [expense_reminder] column.
     *
     * @param int|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setExpenseReminder($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->expense_reminder !== $v) {
            $this->expense_reminder = $v;
            $this->modifiedColumns[CompanyTableMap::COL_EXPENSE_REMINDER] = true;
        }

        return $this;
    }

    /**
     * Set the value of [currentmonthsubmit] column.
     *
     * @param int|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setCurrentmonthsubmit($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->currentmonthsubmit !== $v) {
            $this->currentmonthsubmit = $v;
            $this->modifiedColumns[CompanyTableMap::COL_CURRENTMONTHSUBMIT] = true;
        }

        return $this;
    }

    /**
     * Set the value of [tripapprovalreq] column.
     *
     * @param int|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setTripapprovalreq($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->tripapprovalreq !== $v) {
            $this->tripapprovalreq = $v;
            $this->modifiedColumns[CompanyTableMap::COL_TRIPAPPROVALREQ] = true;
        }

        return $this;
    }

    /**
     * Set the value of [expenseonlyontrip] column.
     *
     * @param int $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setExpenseonlyontrip($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->expenseonlyontrip !== $v) {
            $this->expenseonlyontrip = $v;
            $this->modifiedColumns[CompanyTableMap::COL_EXPENSEONLYONTRIP] = true;
        }

        return $this;
    }

    /**
     * Set the value of [allowbackdatedtrip] column.
     *
     * @param int $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setAllowbackdatedtrip($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->allowbackdatedtrip !== $v) {
            $this->allowbackdatedtrip = $v;
            $this->modifiedColumns[CompanyTableMap::COL_ALLOWBACKDATEDTRIP] = true;
        }

        return $this;
    }

    /**
     * Set the value of [paymentsystem] column.
     *
     * @param int $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setPaymentsystem($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->paymentsystem !== $v) {
            $this->paymentsystem = $v;
            $this->modifiedColumns[CompanyTableMap::COL_PAYMENTSYSTEM] = true;
        }

        return $this;
    }

    /**
     * Set the value of [auto_settle] column.
     *
     * @param int $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setAutoSettle($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->auto_settle !== $v) {
            $this->auto_settle = $v;
            $this->modifiedColumns[CompanyTableMap::COL_AUTO_SETTLE] = true;
        }

        return $this;
    }

    /**
     * Set the value of [allowradius] column.
     *
     * @param int|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setAllowradius($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->allowradius !== $v) {
            $this->allowradius = $v;
            $this->modifiedColumns[CompanyTableMap::COL_ALLOWRADIUS] = true;
        }

        return $this;
    }

    /**
     * Set the value of [order_seq] column.
     *
     * @param string $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setOrderSeq($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->order_seq !== $v) {
            $this->order_seq = $v;
            $this->modifiedColumns[CompanyTableMap::COL_ORDER_SEQ] = true;
        }

        return $this;
    }

    /**
     * Set the value of [shippingorder_seq] column.
     *
     * @param string $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setShippingorderSeq($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->shippingorder_seq !== $v) {
            $this->shippingorder_seq = $v;
            $this->modifiedColumns[CompanyTableMap::COL_SHIPPINGORDER_SEQ] = true;
        }

        return $this;
    }

    /**
     * Set the value of [googlemapkey] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setGooglemapkey($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->googlemapkey !== $v) {
            $this->googlemapkey = $v;
            $this->modifiedColumns[CompanyTableMap::COL_GOOGLEMAPKEY] = true;
        }

        return $this;
    }

    /**
     * Set the value of [workingdaysinweek] column.
     *
     * @param int|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setWorkingdaysinweek($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->workingdaysinweek !== $v) {
            $this->workingdaysinweek = $v;
            $this->modifiedColumns[CompanyTableMap::COL_WORKINGDAYSINWEEK] = true;
        }

        return $this;
    }

    /**
     * Set the value of [auto_calculated_ta] column.
     *
     * @param int|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setAutoCalculatedTa($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->auto_calculated_ta !== $v) {
            $this->auto_calculated_ta = $v;
            $this->modifiedColumns[CompanyTableMap::COL_AUTO_CALCULATED_TA] = true;
        }

        if ($this->aExpenseMasterRelatedByAutoCalculatedTa !== null && $this->aExpenseMasterRelatedByAutoCalculatedTa->getExpenseId() !== $v) {
            $this->aExpenseMasterRelatedByAutoCalculatedTa = null;
        }

        return $this;
    }

    /**
     * Set the value of [reporting_days] column.
     *
     * @param string|null $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setReportingDays($v)
    {
        if ($v !== null) {
            $v = (string) $v;
        }

        if ($this->reporting_days !== $v) {
            $this->reporting_days = $v;
            $this->modifiedColumns[CompanyTableMap::COL_REPORTING_DAYS] = true;
        }

        return $this;
    }

    /**
     * Set the value of [expense_months] column.
     *
     * @param int $v New value
     * @return $this The current object (for fluent API support)
     */
    public function setExpenseMonths($v)
    {
        if ($v !== null) {
            $v = (int) $v;
        }

        if ($this->expense_months !== $v) {
            $this->expense_months = $v;
            $this->modifiedColumns[CompanyTableMap::COL_EXPENSE_MONTHS] = true;
        }

        return $this;
    }

    /**
     * Indicates whether the columns in this object are only set to default values.
     *
     * This method can be used in conjunction with isModified() to indicate whether an object is both
     * modified _and_ has some values set which are non-default.
     *
     * @return bool Whether the columns in this object are only been set with default values.
     */
    public function hasOnlyDefaultValues(): bool
    {
            if ($this->company_code !== '0') {
                return false;
            }

            if ($this->company_first_setup !== 0) {
                return false;
            }

            if ($this->owner_email !== '0') {
                return false;
            }

            if ($this->expense_reminder !== 0) {
                return false;
            }

            if ($this->currentmonthsubmit !== 1) {
                return false;
            }

            if ($this->tripapprovalreq !== 1) {
                return false;
            }

            if ($this->expenseonlyontrip !== 0) {
                return false;
            }

            if ($this->allowbackdatedtrip !== 1) {
                return false;
            }

            if ($this->paymentsystem !== 1) {
                return false;
            }

            if ($this->auto_settle !== 1) {
                return false;
            }

            if ($this->allowradius !== 1) {
                return false;
            }

            if ($this->order_seq !== '1') {
                return false;
            }

            if ($this->shippingorder_seq !== '1') {
                return false;
            }

            if ($this->workingdaysinweek !== 6) {
                return false;
            }

            if ($this->expense_months !== 3) {
                return false;
            }

        // otherwise, everything was equal, so return TRUE
        return true;
    }

    /**
     * Hydrates (populates) the object variables with values from the database resultset.
     *
     * An offset (0-based "start column") is specified so that objects can be hydrated
     * with a subset of the columns in the resultset rows.  This is needed, for example,
     * for results of JOIN queries where the resultset row includes columns from two or
     * more tables.
     *
     * @param array $row The row returned by DataFetcher->fetch().
     * @param int $startcol 0-based offset column which indicates which resultset column to start with.
     * @param bool $rehydrate Whether this object is being re-hydrated from the database.
     * @param string $indexType The index type of $row. Mostly DataFetcher->getIndexType().
                                  One of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_CAMELNAME
     *                            TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM.
     *
     * @return int next starting column
     * @throws \Propel\Runtime\Exception\PropelException - Any caught Exception will be rewrapped as a PropelException.
     */
    public function hydrate(array $row, int $startcol = 0, bool $rehydrate = false, string $indexType = TableMap::TYPE_NUM): int
    {
        try {

            $col = $row[TableMap::TYPE_NUM == $indexType ? 0 + $startcol : CompanyTableMap::translateFieldName('CompanyId', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_id = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 1 + $startcol : CompanyTableMap::translateFieldName('CompanyCode', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_code = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 2 + $startcol : CompanyTableMap::translateFieldName('CompanyName', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_name = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 3 + $startcol : CompanyTableMap::translateFieldName('OwnerName', TableMap::TYPE_PHPNAME, $indexType)];
            $this->owner_name = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 4 + $startcol : CompanyTableMap::translateFieldName('CompanyPhoneNumber', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_phone_number = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 5 + $startcol : CompanyTableMap::translateFieldName('CompanyContactNumber', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_contact_number = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 6 + $startcol : CompanyTableMap::translateFieldName('CompanyLogo', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_logo = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 7 + $startcol : CompanyTableMap::translateFieldName('CompanyAddress1', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_address_1 = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 8 + $startcol : CompanyTableMap::translateFieldName('CompanyAddress2', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_address_2 = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 9 + $startcol : CompanyTableMap::translateFieldName('CompanyDefaultCurrency', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_default_currency = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 10 + $startcol : CompanyTableMap::translateFieldName('Timezone', TableMap::TYPE_PHPNAME, $indexType)];
            $this->timezone = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 11 + $startcol : CompanyTableMap::translateFieldName('CompanyFirstSetup', TableMap::TYPE_PHPNAME, $indexType)];
            $this->company_first_setup = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 12 + $startcol : CompanyTableMap::translateFieldName('OwnerEmail', TableMap::TYPE_PHPNAME, $indexType)];
            $this->owner_email = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 13 + $startcol : CompanyTableMap::translateFieldName('ExpenseReminder', TableMap::TYPE_PHPNAME, $indexType)];
            $this->expense_reminder = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 14 + $startcol : CompanyTableMap::translateFieldName('Currentmonthsubmit', TableMap::TYPE_PHPNAME, $indexType)];
            $this->currentmonthsubmit = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 15 + $startcol : CompanyTableMap::translateFieldName('Tripapprovalreq', TableMap::TYPE_PHPNAME, $indexType)];
            $this->tripapprovalreq = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 16 + $startcol : CompanyTableMap::translateFieldName('Expenseonlyontrip', TableMap::TYPE_PHPNAME, $indexType)];
            $this->expenseonlyontrip = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 17 + $startcol : CompanyTableMap::translateFieldName('Allowbackdatedtrip', TableMap::TYPE_PHPNAME, $indexType)];
            $this->allowbackdatedtrip = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 18 + $startcol : CompanyTableMap::translateFieldName('Paymentsystem', TableMap::TYPE_PHPNAME, $indexType)];
            $this->paymentsystem = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 19 + $startcol : CompanyTableMap::translateFieldName('AutoSettle', TableMap::TYPE_PHPNAME, $indexType)];
            $this->auto_settle = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 20 + $startcol : CompanyTableMap::translateFieldName('Allowradius', TableMap::TYPE_PHPNAME, $indexType)];
            $this->allowradius = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 21 + $startcol : CompanyTableMap::translateFieldName('OrderSeq', TableMap::TYPE_PHPNAME, $indexType)];
            $this->order_seq = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 22 + $startcol : CompanyTableMap::translateFieldName('ShippingorderSeq', TableMap::TYPE_PHPNAME, $indexType)];
            $this->shippingorder_seq = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 23 + $startcol : CompanyTableMap::translateFieldName('Googlemapkey', TableMap::TYPE_PHPNAME, $indexType)];
            $this->googlemapkey = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 24 + $startcol : CompanyTableMap::translateFieldName('Workingdaysinweek', TableMap::TYPE_PHPNAME, $indexType)];
            $this->workingdaysinweek = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 25 + $startcol : CompanyTableMap::translateFieldName('AutoCalculatedTa', TableMap::TYPE_PHPNAME, $indexType)];
            $this->auto_calculated_ta = (null !== $col) ? (int) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 26 + $startcol : CompanyTableMap::translateFieldName('ReportingDays', TableMap::TYPE_PHPNAME, $indexType)];
            $this->reporting_days = (null !== $col) ? (string) $col : null;

            $col = $row[TableMap::TYPE_NUM == $indexType ? 27 + $startcol : CompanyTableMap::translateFieldName('ExpenseMonths', TableMap::TYPE_PHPNAME, $indexType)];
            $this->expense_months = (null !== $col) ? (int) $col : null;

            $this->resetModified();
            $this->setNew(false);

            if ($rehydrate) {
                $this->ensureConsistency();
            }

            return $startcol + 28; // 28 = CompanyTableMap::NUM_HYDRATE_COLUMNS.

        } catch (Exception $e) {
            throw new PropelException(sprintf('Error populating %s object', '\\entities\\Company'), 0, $e);
        }
    }

    /**
     * Checks and repairs the internal consistency of the object.
     *
     * This method is executed after an already-instantiated object is re-hydrated
     * from the database.  It exists to check any foreign keys to make sure that
     * the objects related to the current object are correct based on foreign key.
     *
     * You can override this method in the stub class, but you should always invoke
     * the base method from the overridden method (i.e. parent::ensureConsistency()),
     * in case your model changes.
     *
     * @throws \Propel\Runtime\Exception\PropelException
     * @return void
     */
    public function ensureConsistency(): void
    {
        if ($this->aCurrencies !== null && $this->company_default_currency !== $this->aCurrencies->getCurrencyId()) {
            $this->aCurrencies = null;
        }
        if ($this->aExpenseMasterRelatedByAutoCalculatedTa !== null && $this->auto_calculated_ta !== $this->aExpenseMasterRelatedByAutoCalculatedTa->getExpenseId()) {
            $this->aExpenseMasterRelatedByAutoCalculatedTa = null;
        }
    }

    /**
     * Reloads this object from datastore based on primary key and (optionally) resets all associated objects.
     *
     * This will only work if the object has been saved and has a valid primary key set.
     *
     * @param bool $deep (optional) Whether to also de-associated any related objects.
     * @param ConnectionInterface $con (optional) The ConnectionInterface connection to use.
     * @return void
     * @throws \Propel\Runtime\Exception\PropelException - if this object is deleted, unsaved or doesn't have pk match in db
     */
    public function reload(bool $deep = false, ?ConnectionInterface $con = null): void
    {
        if ($this->isDeleted()) {
            throw new PropelException("Cannot reload a deleted object.");
        }

        if ($this->isNew()) {
            throw new PropelException("Cannot reload an unsaved object.");
        }

        if ($con === null) {
            $con = Propel::getServiceContainer()->getReadConnection(CompanyTableMap::DATABASE_NAME);
        }

        // We don't need to alter the object instance pool; we're just modifying this instance
        // already in the pool.

        $dataFetcher = ChildCompanyQuery::create(null, $this->buildPkeyCriteria())->setFormatter(ModelCriteria::FORMAT_STATEMENT)->find($con);
        $row = $dataFetcher->fetch();
        $dataFetcher->close();
        if (!$row) {
            throw new PropelException('Cannot find matching row in the database to reload object values.');
        }
        $this->hydrate($row, 0, true, $dataFetcher->getIndexType()); // rehydrate

        if ($deep) {  // also de-associate any related objects?

            $this->aExpenseMasterRelatedByAutoCalculatedTa = null;
            $this->aCurrencies = null;
            $this->collAgendatypess = null;

            $this->collAnnouncementss = null;

            $this->collApiKeyss = null;

            $this->collAttendances = null;

            $this->collBeatOutletss = null;

            $this->collBeatss = null;

            $this->collBranches = null;

            $this->collBrandCampiagns = null;

            $this->collBrandCampiagnDoctorss = null;

            $this->collBrandCampiagnVisitPlans = null;

            $this->collBrandCompetitions = null;

            $this->collBrandRcpas = null;

            $this->collBrandss = null;

            $this->collBudgetGroups = null;

            $this->collCategoriess = null;

            $this->collCheckinoutOutcomess = null;

            $this->collCitycategories = null;

            $this->collClassifications = null;

            $this->collCompetitionMappings = null;

            $this->collCompetitors = null;

            $this->collConfigurations = null;

            $this->collCronCommandLogss = null;

            $this->collCronCommandss = null;

            $this->collDailycallss = null;

            $this->collDailycallsSgpiouts = null;

            $this->collDataExceptionLogss = null;

            $this->collDataExceptionss = null;

            $this->collDesignationss = null;

            $this->collEdFeedbackss = null;

            $this->collEdPlaylists = null;

            $this->collEdPresentationss = null;

            $this->collEdSessions = null;

            $this->collEdStatss = null;

            $this->collEmployees = null;

            $this->collEmployeeIncentives = null;

            $this->collEventTypess = null;

            $this->collEventss = null;

            $this->collExpenseLists = null;

            $this->collExpenseMastersRelatedByCompanyId = null;

            $this->collExpensePaymentss = null;

            $this->collExpensess = null;

            $this->collFtpConfigss = null;

            $this->collFtpExportBatchess = null;

            $this->collFtpExportLogss = null;

            $this->collFtpImportBatchess = null;

            $this->collFtpImportLogss = null;

            $this->collGradeMasters = null;

            $this->collHolidayss = null;

            $this->collIntegrationApiLogss = null;

            $this->collLeaveRequests = null;

            $this->collLeavess = null;

            $this->collMaterialFolderss = null;

            $this->collMediaFiless = null;

            $this->collMediaFolderss = null;

            $this->collMtps = null;

            $this->collMtpDays = null;

            $this->collMtpLogss = null;

            $this->collOfferss = null;

            $this->collOnBoardRequests = null;

            $this->collOnBoardRequestAddresses = null;

            $this->collOnBoardRequiredFieldss = null;

            $this->collOrderLogs = null;

            $this->collOrderliness = null;

            $this->collOrderss = null;

            $this->collOrgUnits = null;

            $this->collOtpRequestss = null;

            $this->collOutletAddresses = null;

            $this->collOutletOrgDatas = null;

            $this->collOutletOrgNotess = null;

            $this->collOutletOutcomess = null;

            $this->collOutletStocks = null;

            $this->collOutletStockOtherSummaries = null;

            $this->collOutletStockSummaries = null;

            $this->collOutletTagss = null;

            $this->collOutletTypes = null;

            $this->collOutletss = null;

            $this->collPolicyMasters = null;

            $this->collPolicykeyss = null;

            $this->collPositionss = null;

            $this->collPricebookliness = null;

            $this->collPricebookss = null;

            $this->collProductss = null;

            $this->collReminderss = null;

            $this->collSgpiAccountss = null;

            $this->collSgpiMasters = null;

            $this->collSgpiTranss = null;

            $this->collShiftTypess = null;

            $this->collShippingliness = null;

            $this->collShippingorders = null;

            $this->collStockTransactions = null;

            $this->collStockVouchers = null;

            $this->collSurveys = null;

            $this->collSurveyCategories = null;

            $this->collSurveyQuestions = null;

            $this->collSurveySubmiteds = null;

            $this->collTaConfigurations = null;

            $this->collTagss = null;

            $this->collTerritoriess = null;

            $this->collTerritoryTownss = null;

            $this->collTicketRepliess = null;

            $this->collTicketTypes = null;

            $this->collTicketss = null;

            $this->collTourplanss = null;

            $this->collTransactionss = null;

            $this->collUserss = null;

            $this->collWdbSyncLogs = null;

            $this->collWfRequestss = null;

            $this->collStps = null;

            $this->collStpWeeks = null;

            $this->collOutletOrgDataKeyss = null;

            $this->collNotificationConfigurations = null;

            $this->collLeaveTypes = null;

        } // if (deep)
    }

    /**
     * Removes this object from datastore and sets delete attribute.
     *
     * @param ConnectionInterface $con
     * @return void
     * @throws \Propel\Runtime\Exception\PropelException
     * @see Company::setDeleted()
     * @see Company::isDeleted()
     */
    public function delete(?ConnectionInterface $con = null): void
    {
        if ($this->isDeleted()) {
            throw new PropelException("This object has already been deleted.");
        }

        if ($con === null) {
            $con = Propel::getServiceContainer()->getWriteConnection(CompanyTableMap::DATABASE_NAME);
        }

        $con->transaction(function () use ($con) {
            $deleteQuery = ChildCompanyQuery::create()
                ->filterByPrimaryKey($this->getPrimaryKey());
            $ret = $this->preDelete($con);
            if ($ret) {
                $deleteQuery->delete($con);
                $this->postDelete($con);
                $this->setDeleted(true);
            }
        });
    }

    /**
     * Persists this object to the database.
     *
     * If the object is new, it inserts it; otherwise an update is performed.
     * All modified related objects will also be persisted in the doSave()
     * method.  This method wraps all precipitate database operations in a
     * single transaction.
     *
     * @param ConnectionInterface $con
     * @return int The number of rows affected by this insert/update and any referring fk objects' save() operations.
     * @throws \Propel\Runtime\Exception\PropelException
     * @see doSave()
     */
    public function save(?ConnectionInterface $con = null): int
    {
        if ($this->isDeleted()) {
            throw new PropelException("You cannot save an object that has been deleted.");
        }

        if ($this->alreadyInSave) {
            return 0;
        }

        if ($con === null) {
            $con = Propel::getServiceContainer()->getWriteConnection(CompanyTableMap::DATABASE_NAME);
        }

        return $con->transaction(function () use ($con) {
            $ret = $this->preSave($con);
            $isInsert = $this->isNew();
            if ($isInsert) {
                $ret = $ret && $this->preInsert($con);
            } else {
                $ret = $ret && $this->preUpdate($con);
            }
            if ($ret) {
                $affectedRows = $this->doSave($con);
                if ($isInsert) {
                    $this->postInsert($con);
                } else {
                    $this->postUpdate($con);
                }
                $this->postSave($con);
                CompanyTableMap::addInstanceToPool($this);
            } else {
                $affectedRows = 0;
            }

            return $affectedRows;
        });
    }

    /**
     * Performs the work of inserting or updating the row in the database.
     *
     * If the object is new, it inserts it; otherwise an update is performed.
     * All related objects are also updated in this method.
     *
     * @param ConnectionInterface $con
     * @return int The number of rows affected by this insert/update and any referring fk objects' save() operations.
     * @throws \Propel\Runtime\Exception\PropelException
     * @see save()
     */
    protected function doSave(ConnectionInterface $con): int
    {
        $affectedRows = 0; // initialize var to track total num of affected rows
        if (!$this->alreadyInSave) {
            $this->alreadyInSave = true;

            // We call the save method on the following object(s) if they
            // were passed to this object by their corresponding set
            // method.  This object relates to these object(s) by a
            // foreign key reference.

            if ($this->aExpenseMasterRelatedByAutoCalculatedTa !== null) {
                if ($this->aExpenseMasterRelatedByAutoCalculatedTa->isModified() || $this->aExpenseMasterRelatedByAutoCalculatedTa->isNew()) {
                    $affectedRows += $this->aExpenseMasterRelatedByAutoCalculatedTa->save($con);
                }
                $this->setExpenseMasterRelatedByAutoCalculatedTa($this->aExpenseMasterRelatedByAutoCalculatedTa);
            }

            if ($this->aCurrencies !== null) {
                if ($this->aCurrencies->isModified() || $this->aCurrencies->isNew()) {
                    $affectedRows += $this->aCurrencies->save($con);
                }
                $this->setCurrencies($this->aCurrencies);
            }

            if ($this->isNew() || $this->isModified()) {
                // persist changes
                if ($this->isNew()) {
                    $this->doInsert($con);
                    $affectedRows += 1;
                } else {
                    $affectedRows += $this->doUpdate($con);
                }
                $this->resetModified();
            }

            if ($this->agendatypessScheduledForDeletion !== null) {
                if (!$this->agendatypessScheduledForDeletion->isEmpty()) {
                    \entities\AgendatypesQuery::create()
                        ->filterByPrimaryKeys($this->agendatypessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->agendatypessScheduledForDeletion = null;
                }
            }

            if ($this->collAgendatypess !== null) {
                foreach ($this->collAgendatypess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->announcementssScheduledForDeletion !== null) {
                if (!$this->announcementssScheduledForDeletion->isEmpty()) {
                    \entities\AnnouncementsQuery::create()
                        ->filterByPrimaryKeys($this->announcementssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->announcementssScheduledForDeletion = null;
                }
            }

            if ($this->collAnnouncementss !== null) {
                foreach ($this->collAnnouncementss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->apiKeyssScheduledForDeletion !== null) {
                if (!$this->apiKeyssScheduledForDeletion->isEmpty()) {
                    foreach ($this->apiKeyssScheduledForDeletion as $apiKeys) {
                        // need to save related object because we set the relation to null
                        $apiKeys->save($con);
                    }
                    $this->apiKeyssScheduledForDeletion = null;
                }
            }

            if ($this->collApiKeyss !== null) {
                foreach ($this->collApiKeyss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->attendancesScheduledForDeletion !== null) {
                if (!$this->attendancesScheduledForDeletion->isEmpty()) {
                    \entities\AttendanceQuery::create()
                        ->filterByPrimaryKeys($this->attendancesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->attendancesScheduledForDeletion = null;
                }
            }

            if ($this->collAttendances !== null) {
                foreach ($this->collAttendances as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->beatOutletssScheduledForDeletion !== null) {
                if (!$this->beatOutletssScheduledForDeletion->isEmpty()) {
                    \entities\BeatOutletsQuery::create()
                        ->filterByPrimaryKeys($this->beatOutletssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->beatOutletssScheduledForDeletion = null;
                }
            }

            if ($this->collBeatOutletss !== null) {
                foreach ($this->collBeatOutletss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->beatssScheduledForDeletion !== null) {
                if (!$this->beatssScheduledForDeletion->isEmpty()) {
                    \entities\BeatsQuery::create()
                        ->filterByPrimaryKeys($this->beatssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->beatssScheduledForDeletion = null;
                }
            }

            if ($this->collBeatss !== null) {
                foreach ($this->collBeatss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->branchesScheduledForDeletion !== null) {
                if (!$this->branchesScheduledForDeletion->isEmpty()) {
                    \entities\BranchQuery::create()
                        ->filterByPrimaryKeys($this->branchesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->branchesScheduledForDeletion = null;
                }
            }

            if ($this->collBranches !== null) {
                foreach ($this->collBranches as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->brandCampiagnsScheduledForDeletion !== null) {
                if (!$this->brandCampiagnsScheduledForDeletion->isEmpty()) {
                    foreach ($this->brandCampiagnsScheduledForDeletion as $brandCampiagn) {
                        // need to save related object because we set the relation to null
                        $brandCampiagn->save($con);
                    }
                    $this->brandCampiagnsScheduledForDeletion = null;
                }
            }

            if ($this->collBrandCampiagns !== null) {
                foreach ($this->collBrandCampiagns as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->brandCampiagnDoctorssScheduledForDeletion !== null) {
                if (!$this->brandCampiagnDoctorssScheduledForDeletion->isEmpty()) {
                    foreach ($this->brandCampiagnDoctorssScheduledForDeletion as $brandCampiagnDoctors) {
                        // need to save related object because we set the relation to null
                        $brandCampiagnDoctors->save($con);
                    }
                    $this->brandCampiagnDoctorssScheduledForDeletion = null;
                }
            }

            if ($this->collBrandCampiagnDoctorss !== null) {
                foreach ($this->collBrandCampiagnDoctorss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->brandCampiagnVisitPlansScheduledForDeletion !== null) {
                if (!$this->brandCampiagnVisitPlansScheduledForDeletion->isEmpty()) {
                    foreach ($this->brandCampiagnVisitPlansScheduledForDeletion as $brandCampiagnVisitPlan) {
                        // need to save related object because we set the relation to null
                        $brandCampiagnVisitPlan->save($con);
                    }
                    $this->brandCampiagnVisitPlansScheduledForDeletion = null;
                }
            }

            if ($this->collBrandCampiagnVisitPlans !== null) {
                foreach ($this->collBrandCampiagnVisitPlans as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->brandCompetitionsScheduledForDeletion !== null) {
                if (!$this->brandCompetitionsScheduledForDeletion->isEmpty()) {
                    foreach ($this->brandCompetitionsScheduledForDeletion as $brandCompetition) {
                        // need to save related object because we set the relation to null
                        $brandCompetition->save($con);
                    }
                    $this->brandCompetitionsScheduledForDeletion = null;
                }
            }

            if ($this->collBrandCompetitions !== null) {
                foreach ($this->collBrandCompetitions as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->brandRcpasScheduledForDeletion !== null) {
                if (!$this->brandRcpasScheduledForDeletion->isEmpty()) {
                    foreach ($this->brandRcpasScheduledForDeletion as $brandRcpa) {
                        // need to save related object because we set the relation to null
                        $brandRcpa->save($con);
                    }
                    $this->brandRcpasScheduledForDeletion = null;
                }
            }

            if ($this->collBrandRcpas !== null) {
                foreach ($this->collBrandRcpas as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->brandssScheduledForDeletion !== null) {
                if (!$this->brandssScheduledForDeletion->isEmpty()) {
                    foreach ($this->brandssScheduledForDeletion as $brands) {
                        // need to save related object because we set the relation to null
                        $brands->save($con);
                    }
                    $this->brandssScheduledForDeletion = null;
                }
            }

            if ($this->collBrandss !== null) {
                foreach ($this->collBrandss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->budgetGroupsScheduledForDeletion !== null) {
                if (!$this->budgetGroupsScheduledForDeletion->isEmpty()) {
                    \entities\BudgetGroupQuery::create()
                        ->filterByPrimaryKeys($this->budgetGroupsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->budgetGroupsScheduledForDeletion = null;
                }
            }

            if ($this->collBudgetGroups !== null) {
                foreach ($this->collBudgetGroups as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->categoriessScheduledForDeletion !== null) {
                if (!$this->categoriessScheduledForDeletion->isEmpty()) {
                    \entities\CategoriesQuery::create()
                        ->filterByPrimaryKeys($this->categoriessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->categoriessScheduledForDeletion = null;
                }
            }

            if ($this->collCategoriess !== null) {
                foreach ($this->collCategoriess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->checkinoutOutcomessScheduledForDeletion !== null) {
                if (!$this->checkinoutOutcomessScheduledForDeletion->isEmpty()) {
                    \entities\CheckinoutOutcomesQuery::create()
                        ->filterByPrimaryKeys($this->checkinoutOutcomessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->checkinoutOutcomessScheduledForDeletion = null;
                }
            }

            if ($this->collCheckinoutOutcomess !== null) {
                foreach ($this->collCheckinoutOutcomess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->citycategoriesScheduledForDeletion !== null) {
                if (!$this->citycategoriesScheduledForDeletion->isEmpty()) {
                    \entities\CitycategoryQuery::create()
                        ->filterByPrimaryKeys($this->citycategoriesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->citycategoriesScheduledForDeletion = null;
                }
            }

            if ($this->collCitycategories !== null) {
                foreach ($this->collCitycategories as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->classificationsScheduledForDeletion !== null) {
                if (!$this->classificationsScheduledForDeletion->isEmpty()) {
                    \entities\ClassificationQuery::create()
                        ->filterByPrimaryKeys($this->classificationsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->classificationsScheduledForDeletion = null;
                }
            }

            if ($this->collClassifications !== null) {
                foreach ($this->collClassifications as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->competitionMappingsScheduledForDeletion !== null) {
                if (!$this->competitionMappingsScheduledForDeletion->isEmpty()) {
                    \entities\CompetitionMappingQuery::create()
                        ->filterByPrimaryKeys($this->competitionMappingsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->competitionMappingsScheduledForDeletion = null;
                }
            }

            if ($this->collCompetitionMappings !== null) {
                foreach ($this->collCompetitionMappings as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->competitorsScheduledForDeletion !== null) {
                if (!$this->competitorsScheduledForDeletion->isEmpty()) {
                    \entities\CompetitorQuery::create()
                        ->filterByPrimaryKeys($this->competitorsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->competitorsScheduledForDeletion = null;
                }
            }

            if ($this->collCompetitors !== null) {
                foreach ($this->collCompetitors as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->configurationsScheduledForDeletion !== null) {
                if (!$this->configurationsScheduledForDeletion->isEmpty()) {
                    \entities\ConfigurationQuery::create()
                        ->filterByPrimaryKeys($this->configurationsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->configurationsScheduledForDeletion = null;
                }
            }

            if ($this->collConfigurations !== null) {
                foreach ($this->collConfigurations as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->cronCommandLogssScheduledForDeletion !== null) {
                if (!$this->cronCommandLogssScheduledForDeletion->isEmpty()) {
                    foreach ($this->cronCommandLogssScheduledForDeletion as $cronCommandLogs) {
                        // need to save related object because we set the relation to null
                        $cronCommandLogs->save($con);
                    }
                    $this->cronCommandLogssScheduledForDeletion = null;
                }
            }

            if ($this->collCronCommandLogss !== null) {
                foreach ($this->collCronCommandLogss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->cronCommandssScheduledForDeletion !== null) {
                if (!$this->cronCommandssScheduledForDeletion->isEmpty()) {
                    foreach ($this->cronCommandssScheduledForDeletion as $cronCommands) {
                        // need to save related object because we set the relation to null
                        $cronCommands->save($con);
                    }
                    $this->cronCommandssScheduledForDeletion = null;
                }
            }

            if ($this->collCronCommandss !== null) {
                foreach ($this->collCronCommandss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->dailycallssScheduledForDeletion !== null) {
                if (!$this->dailycallssScheduledForDeletion->isEmpty()) {
                    foreach ($this->dailycallssScheduledForDeletion as $dailycalls) {
                        // need to save related object because we set the relation to null
                        $dailycalls->save($con);
                    }
                    $this->dailycallssScheduledForDeletion = null;
                }
            }

            if ($this->collDailycallss !== null) {
                foreach ($this->collDailycallss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->dailycallsSgpioutsScheduledForDeletion !== null) {
                if (!$this->dailycallsSgpioutsScheduledForDeletion->isEmpty()) {
                    foreach ($this->dailycallsSgpioutsScheduledForDeletion as $dailycallsSgpiout) {
                        // need to save related object because we set the relation to null
                        $dailycallsSgpiout->save($con);
                    }
                    $this->dailycallsSgpioutsScheduledForDeletion = null;
                }
            }

            if ($this->collDailycallsSgpiouts !== null) {
                foreach ($this->collDailycallsSgpiouts as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->dataExceptionLogssScheduledForDeletion !== null) {
                if (!$this->dataExceptionLogssScheduledForDeletion->isEmpty()) {
                    foreach ($this->dataExceptionLogssScheduledForDeletion as $dataExceptionLogs) {
                        // need to save related object because we set the relation to null
                        $dataExceptionLogs->save($con);
                    }
                    $this->dataExceptionLogssScheduledForDeletion = null;
                }
            }

            if ($this->collDataExceptionLogss !== null) {
                foreach ($this->collDataExceptionLogss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->dataExceptionssScheduledForDeletion !== null) {
                if (!$this->dataExceptionssScheduledForDeletion->isEmpty()) {
                    foreach ($this->dataExceptionssScheduledForDeletion as $dataExceptions) {
                        // need to save related object because we set the relation to null
                        $dataExceptions->save($con);
                    }
                    $this->dataExceptionssScheduledForDeletion = null;
                }
            }

            if ($this->collDataExceptionss !== null) {
                foreach ($this->collDataExceptionss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->designationssScheduledForDeletion !== null) {
                if (!$this->designationssScheduledForDeletion->isEmpty()) {
                    \entities\DesignationsQuery::create()
                        ->filterByPrimaryKeys($this->designationssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->designationssScheduledForDeletion = null;
                }
            }

            if ($this->collDesignationss !== null) {
                foreach ($this->collDesignationss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->edFeedbackssScheduledForDeletion !== null) {
                if (!$this->edFeedbackssScheduledForDeletion->isEmpty()) {
                    foreach ($this->edFeedbackssScheduledForDeletion as $edFeedbacks) {
                        // need to save related object because we set the relation to null
                        $edFeedbacks->save($con);
                    }
                    $this->edFeedbackssScheduledForDeletion = null;
                }
            }

            if ($this->collEdFeedbackss !== null) {
                foreach ($this->collEdFeedbackss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->edPlaylistsScheduledForDeletion !== null) {
                if (!$this->edPlaylistsScheduledForDeletion->isEmpty()) {
                    \entities\EdPlaylistQuery::create()
                        ->filterByPrimaryKeys($this->edPlaylistsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->edPlaylistsScheduledForDeletion = null;
                }
            }

            if ($this->collEdPlaylists !== null) {
                foreach ($this->collEdPlaylists as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->edPresentationssScheduledForDeletion !== null) {
                if (!$this->edPresentationssScheduledForDeletion->isEmpty()) {
                    \entities\EdPresentationsQuery::create()
                        ->filterByPrimaryKeys($this->edPresentationssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->edPresentationssScheduledForDeletion = null;
                }
            }

            if ($this->collEdPresentationss !== null) {
                foreach ($this->collEdPresentationss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->edSessionsScheduledForDeletion !== null) {
                if (!$this->edSessionsScheduledForDeletion->isEmpty()) {
                    foreach ($this->edSessionsScheduledForDeletion as $edSession) {
                        // need to save related object because we set the relation to null
                        $edSession->save($con);
                    }
                    $this->edSessionsScheduledForDeletion = null;
                }
            }

            if ($this->collEdSessions !== null) {
                foreach ($this->collEdSessions as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->edStatssScheduledForDeletion !== null) {
                if (!$this->edStatssScheduledForDeletion->isEmpty()) {
                    \entities\EdStatsQuery::create()
                        ->filterByPrimaryKeys($this->edStatssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->edStatssScheduledForDeletion = null;
                }
            }

            if ($this->collEdStatss !== null) {
                foreach ($this->collEdStatss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->employeesScheduledForDeletion !== null) {
                if (!$this->employeesScheduledForDeletion->isEmpty()) {
                    \entities\EmployeeQuery::create()
                        ->filterByPrimaryKeys($this->employeesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->employeesScheduledForDeletion = null;
                }
            }

            if ($this->collEmployees !== null) {
                foreach ($this->collEmployees as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->employeeIncentivesScheduledForDeletion !== null) {
                if (!$this->employeeIncentivesScheduledForDeletion->isEmpty()) {
                    \entities\EmployeeIncentiveQuery::create()
                        ->filterByPrimaryKeys($this->employeeIncentivesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->employeeIncentivesScheduledForDeletion = null;
                }
            }

            if ($this->collEmployeeIncentives !== null) {
                foreach ($this->collEmployeeIncentives as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->eventTypessScheduledForDeletion !== null) {
                if (!$this->eventTypessScheduledForDeletion->isEmpty()) {
                    \entities\EventTypesQuery::create()
                        ->filterByPrimaryKeys($this->eventTypessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->eventTypessScheduledForDeletion = null;
                }
            }

            if ($this->collEventTypess !== null) {
                foreach ($this->collEventTypess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->eventssScheduledForDeletion !== null) {
                if (!$this->eventssScheduledForDeletion->isEmpty()) {
                    \entities\EventsQuery::create()
                        ->filterByPrimaryKeys($this->eventssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->eventssScheduledForDeletion = null;
                }
            }

            if ($this->collEventss !== null) {
                foreach ($this->collEventss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->expenseListsScheduledForDeletion !== null) {
                if (!$this->expenseListsScheduledForDeletion->isEmpty()) {
                    \entities\ExpenseListQuery::create()
                        ->filterByPrimaryKeys($this->expenseListsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->expenseListsScheduledForDeletion = null;
                }
            }

            if ($this->collExpenseLists !== null) {
                foreach ($this->collExpenseLists as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->expenseMastersRelatedByCompanyIdScheduledForDeletion !== null) {
                if (!$this->expenseMastersRelatedByCompanyIdScheduledForDeletion->isEmpty()) {
                    \entities\ExpenseMasterQuery::create()
                        ->filterByPrimaryKeys($this->expenseMastersRelatedByCompanyIdScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->expenseMastersRelatedByCompanyIdScheduledForDeletion = null;
                }
            }

            if ($this->collExpenseMastersRelatedByCompanyId !== null) {
                foreach ($this->collExpenseMastersRelatedByCompanyId as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->expensePaymentssScheduledForDeletion !== null) {
                if (!$this->expensePaymentssScheduledForDeletion->isEmpty()) {
                    foreach ($this->expensePaymentssScheduledForDeletion as $expensePayments) {
                        // need to save related object because we set the relation to null
                        $expensePayments->save($con);
                    }
                    $this->expensePaymentssScheduledForDeletion = null;
                }
            }

            if ($this->collExpensePaymentss !== null) {
                foreach ($this->collExpensePaymentss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->expensessScheduledForDeletion !== null) {
                if (!$this->expensessScheduledForDeletion->isEmpty()) {
                    \entities\ExpensesQuery::create()
                        ->filterByPrimaryKeys($this->expensessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->expensessScheduledForDeletion = null;
                }
            }

            if ($this->collExpensess !== null) {
                foreach ($this->collExpensess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ftpConfigssScheduledForDeletion !== null) {
                if (!$this->ftpConfigssScheduledForDeletion->isEmpty()) {
                    \entities\FtpConfigsQuery::create()
                        ->filterByPrimaryKeys($this->ftpConfigssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->ftpConfigssScheduledForDeletion = null;
                }
            }

            if ($this->collFtpConfigss !== null) {
                foreach ($this->collFtpConfigss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ftpExportBatchessScheduledForDeletion !== null) {
                if (!$this->ftpExportBatchessScheduledForDeletion->isEmpty()) {
                    \entities\FtpExportBatchesQuery::create()
                        ->filterByPrimaryKeys($this->ftpExportBatchessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->ftpExportBatchessScheduledForDeletion = null;
                }
            }

            if ($this->collFtpExportBatchess !== null) {
                foreach ($this->collFtpExportBatchess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ftpExportLogssScheduledForDeletion !== null) {
                if (!$this->ftpExportLogssScheduledForDeletion->isEmpty()) {
                    \entities\FtpExportLogsQuery::create()
                        ->filterByPrimaryKeys($this->ftpExportLogssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->ftpExportLogssScheduledForDeletion = null;
                }
            }

            if ($this->collFtpExportLogss !== null) {
                foreach ($this->collFtpExportLogss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ftpImportBatchessScheduledForDeletion !== null) {
                if (!$this->ftpImportBatchessScheduledForDeletion->isEmpty()) {
                    \entities\FtpImportBatchesQuery::create()
                        ->filterByPrimaryKeys($this->ftpImportBatchessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->ftpImportBatchessScheduledForDeletion = null;
                }
            }

            if ($this->collFtpImportBatchess !== null) {
                foreach ($this->collFtpImportBatchess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ftpImportLogssScheduledForDeletion !== null) {
                if (!$this->ftpImportLogssScheduledForDeletion->isEmpty()) {
                    \entities\FtpImportLogsQuery::create()
                        ->filterByPrimaryKeys($this->ftpImportLogssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->ftpImportLogssScheduledForDeletion = null;
                }
            }

            if ($this->collFtpImportLogss !== null) {
                foreach ($this->collFtpImportLogss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->gradeMastersScheduledForDeletion !== null) {
                if (!$this->gradeMastersScheduledForDeletion->isEmpty()) {
                    \entities\GradeMasterQuery::create()
                        ->filterByPrimaryKeys($this->gradeMastersScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->gradeMastersScheduledForDeletion = null;
                }
            }

            if ($this->collGradeMasters !== null) {
                foreach ($this->collGradeMasters as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->holidayssScheduledForDeletion !== null) {
                if (!$this->holidayssScheduledForDeletion->isEmpty()) {
                    foreach ($this->holidayssScheduledForDeletion as $holidays) {
                        // need to save related object because we set the relation to null
                        $holidays->save($con);
                    }
                    $this->holidayssScheduledForDeletion = null;
                }
            }

            if ($this->collHolidayss !== null) {
                foreach ($this->collHolidayss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->integrationApiLogssScheduledForDeletion !== null) {
                if (!$this->integrationApiLogssScheduledForDeletion->isEmpty()) {
                    foreach ($this->integrationApiLogssScheduledForDeletion as $integrationApiLogs) {
                        // need to save related object because we set the relation to null
                        $integrationApiLogs->save($con);
                    }
                    $this->integrationApiLogssScheduledForDeletion = null;
                }
            }

            if ($this->collIntegrationApiLogss !== null) {
                foreach ($this->collIntegrationApiLogss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->leaveRequestsScheduledForDeletion !== null) {
                if (!$this->leaveRequestsScheduledForDeletion->isEmpty()) {
                    \entities\LeaveRequestQuery::create()
                        ->filterByPrimaryKeys($this->leaveRequestsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->leaveRequestsScheduledForDeletion = null;
                }
            }

            if ($this->collLeaveRequests !== null) {
                foreach ($this->collLeaveRequests as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->leavessScheduledForDeletion !== null) {
                if (!$this->leavessScheduledForDeletion->isEmpty()) {
                    foreach ($this->leavessScheduledForDeletion as $leaves) {
                        // need to save related object because we set the relation to null
                        $leaves->save($con);
                    }
                    $this->leavessScheduledForDeletion = null;
                }
            }

            if ($this->collLeavess !== null) {
                foreach ($this->collLeavess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->materialFolderssScheduledForDeletion !== null) {
                if (!$this->materialFolderssScheduledForDeletion->isEmpty()) {
                    foreach ($this->materialFolderssScheduledForDeletion as $materialFolders) {
                        // need to save related object because we set the relation to null
                        $materialFolders->save($con);
                    }
                    $this->materialFolderssScheduledForDeletion = null;
                }
            }

            if ($this->collMaterialFolderss !== null) {
                foreach ($this->collMaterialFolderss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->mediaFilessScheduledForDeletion !== null) {
                if (!$this->mediaFilessScheduledForDeletion->isEmpty()) {
                    foreach ($this->mediaFilessScheduledForDeletion as $mediaFiles) {
                        // need to save related object because we set the relation to null
                        $mediaFiles->save($con);
                    }
                    $this->mediaFilessScheduledForDeletion = null;
                }
            }

            if ($this->collMediaFiless !== null) {
                foreach ($this->collMediaFiless as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->mediaFolderssScheduledForDeletion !== null) {
                if (!$this->mediaFolderssScheduledForDeletion->isEmpty()) {
                    \entities\MediaFoldersQuery::create()
                        ->filterByPrimaryKeys($this->mediaFolderssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->mediaFolderssScheduledForDeletion = null;
                }
            }

            if ($this->collMediaFolderss !== null) {
                foreach ($this->collMediaFolderss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->mtpsScheduledForDeletion !== null) {
                if (!$this->mtpsScheduledForDeletion->isEmpty()) {
                    \entities\MtpQuery::create()
                        ->filterByPrimaryKeys($this->mtpsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->mtpsScheduledForDeletion = null;
                }
            }

            if ($this->collMtps !== null) {
                foreach ($this->collMtps as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->mtpDaysScheduledForDeletion !== null) {
                if (!$this->mtpDaysScheduledForDeletion->isEmpty()) {
                    foreach ($this->mtpDaysScheduledForDeletion as $mtpDay) {
                        // need to save related object because we set the relation to null
                        $mtpDay->save($con);
                    }
                    $this->mtpDaysScheduledForDeletion = null;
                }
            }

            if ($this->collMtpDays !== null) {
                foreach ($this->collMtpDays as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->mtpLogssScheduledForDeletion !== null) {
                if (!$this->mtpLogssScheduledForDeletion->isEmpty()) {
                    foreach ($this->mtpLogssScheduledForDeletion as $mtpLogs) {
                        // need to save related object because we set the relation to null
                        $mtpLogs->save($con);
                    }
                    $this->mtpLogssScheduledForDeletion = null;
                }
            }

            if ($this->collMtpLogss !== null) {
                foreach ($this->collMtpLogss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->offerssScheduledForDeletion !== null) {
                if (!$this->offerssScheduledForDeletion->isEmpty()) {
                    foreach ($this->offerssScheduledForDeletion as $offers) {
                        // need to save related object because we set the relation to null
                        $offers->save($con);
                    }
                    $this->offerssScheduledForDeletion = null;
                }
            }

            if ($this->collOfferss !== null) {
                foreach ($this->collOfferss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->onBoardRequestsScheduledForDeletion !== null) {
                if (!$this->onBoardRequestsScheduledForDeletion->isEmpty()) {
                    foreach ($this->onBoardRequestsScheduledForDeletion as $onBoardRequest) {
                        // need to save related object because we set the relation to null
                        $onBoardRequest->save($con);
                    }
                    $this->onBoardRequestsScheduledForDeletion = null;
                }
            }

            if ($this->collOnBoardRequests !== null) {
                foreach ($this->collOnBoardRequests as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->onBoardRequestAddressesScheduledForDeletion !== null) {
                if (!$this->onBoardRequestAddressesScheduledForDeletion->isEmpty()) {
                    foreach ($this->onBoardRequestAddressesScheduledForDeletion as $onBoardRequestAddress) {
                        // need to save related object because we set the relation to null
                        $onBoardRequestAddress->save($con);
                    }
                    $this->onBoardRequestAddressesScheduledForDeletion = null;
                }
            }

            if ($this->collOnBoardRequestAddresses !== null) {
                foreach ($this->collOnBoardRequestAddresses as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->onBoardRequiredFieldssScheduledForDeletion !== null) {
                if (!$this->onBoardRequiredFieldssScheduledForDeletion->isEmpty()) {
                    foreach ($this->onBoardRequiredFieldssScheduledForDeletion as $onBoardRequiredFields) {
                        // need to save related object because we set the relation to null
                        $onBoardRequiredFields->save($con);
                    }
                    $this->onBoardRequiredFieldssScheduledForDeletion = null;
                }
            }

            if ($this->collOnBoardRequiredFieldss !== null) {
                foreach ($this->collOnBoardRequiredFieldss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->orderLogsScheduledForDeletion !== null) {
                if (!$this->orderLogsScheduledForDeletion->isEmpty()) {
                    \entities\OrderLogQuery::create()
                        ->filterByPrimaryKeys($this->orderLogsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->orderLogsScheduledForDeletion = null;
                }
            }

            if ($this->collOrderLogs !== null) {
                foreach ($this->collOrderLogs as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->orderlinessScheduledForDeletion !== null) {
                if (!$this->orderlinessScheduledForDeletion->isEmpty()) {
                    \entities\OrderlinesQuery::create()
                        ->filterByPrimaryKeys($this->orderlinessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->orderlinessScheduledForDeletion = null;
                }
            }

            if ($this->collOrderliness !== null) {
                foreach ($this->collOrderliness as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->orderssScheduledForDeletion !== null) {
                if (!$this->orderssScheduledForDeletion->isEmpty()) {
                    foreach ($this->orderssScheduledForDeletion as $orders) {
                        // need to save related object because we set the relation to null
                        $orders->save($con);
                    }
                    $this->orderssScheduledForDeletion = null;
                }
            }

            if ($this->collOrderss !== null) {
                foreach ($this->collOrderss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->orgUnitsScheduledForDeletion !== null) {
                if (!$this->orgUnitsScheduledForDeletion->isEmpty()) {
                    \entities\OrgUnitQuery::create()
                        ->filterByPrimaryKeys($this->orgUnitsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->orgUnitsScheduledForDeletion = null;
                }
            }

            if ($this->collOrgUnits !== null) {
                foreach ($this->collOrgUnits as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->otpRequestssScheduledForDeletion !== null) {
                if (!$this->otpRequestssScheduledForDeletion->isEmpty()) {
                    \entities\OtpRequestsQuery::create()
                        ->filterByPrimaryKeys($this->otpRequestssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->otpRequestssScheduledForDeletion = null;
                }
            }

            if ($this->collOtpRequestss !== null) {
                foreach ($this->collOtpRequestss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletAddressesScheduledForDeletion !== null) {
                if (!$this->outletAddressesScheduledForDeletion->isEmpty()) {
                    foreach ($this->outletAddressesScheduledForDeletion as $outletAddress) {
                        // need to save related object because we set the relation to null
                        $outletAddress->save($con);
                    }
                    $this->outletAddressesScheduledForDeletion = null;
                }
            }

            if ($this->collOutletAddresses !== null) {
                foreach ($this->collOutletAddresses as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletOrgDatasScheduledForDeletion !== null) {
                if (!$this->outletOrgDatasScheduledForDeletion->isEmpty()) {
                    foreach ($this->outletOrgDatasScheduledForDeletion as $outletOrgData) {
                        // need to save related object because we set the relation to null
                        $outletOrgData->save($con);
                    }
                    $this->outletOrgDatasScheduledForDeletion = null;
                }
            }

            if ($this->collOutletOrgDatas !== null) {
                foreach ($this->collOutletOrgDatas as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletOrgNotessScheduledForDeletion !== null) {
                if (!$this->outletOrgNotessScheduledForDeletion->isEmpty()) {
                    \entities\OutletOrgNotesQuery::create()
                        ->filterByPrimaryKeys($this->outletOrgNotessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->outletOrgNotessScheduledForDeletion = null;
                }
            }

            if ($this->collOutletOrgNotess !== null) {
                foreach ($this->collOutletOrgNotess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletOutcomessScheduledForDeletion !== null) {
                if (!$this->outletOutcomessScheduledForDeletion->isEmpty()) {
                    foreach ($this->outletOutcomessScheduledForDeletion as $outletOutcomes) {
                        // need to save related object because we set the relation to null
                        $outletOutcomes->save($con);
                    }
                    $this->outletOutcomessScheduledForDeletion = null;
                }
            }

            if ($this->collOutletOutcomess !== null) {
                foreach ($this->collOutletOutcomess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletStocksScheduledForDeletion !== null) {
                if (!$this->outletStocksScheduledForDeletion->isEmpty()) {
                    \entities\OutletStockQuery::create()
                        ->filterByPrimaryKeys($this->outletStocksScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->outletStocksScheduledForDeletion = null;
                }
            }

            if ($this->collOutletStocks !== null) {
                foreach ($this->collOutletStocks as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletStockOtherSummariesScheduledForDeletion !== null) {
                if (!$this->outletStockOtherSummariesScheduledForDeletion->isEmpty()) {
                    \entities\OutletStockOtherSummaryQuery::create()
                        ->filterByPrimaryKeys($this->outletStockOtherSummariesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->outletStockOtherSummariesScheduledForDeletion = null;
                }
            }

            if ($this->collOutletStockOtherSummaries !== null) {
                foreach ($this->collOutletStockOtherSummaries as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletStockSummariesScheduledForDeletion !== null) {
                if (!$this->outletStockSummariesScheduledForDeletion->isEmpty()) {
                    \entities\OutletStockSummaryQuery::create()
                        ->filterByPrimaryKeys($this->outletStockSummariesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->outletStockSummariesScheduledForDeletion = null;
                }
            }

            if ($this->collOutletStockSummaries !== null) {
                foreach ($this->collOutletStockSummaries as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletTagssScheduledForDeletion !== null) {
                if (!$this->outletTagssScheduledForDeletion->isEmpty()) {
                    foreach ($this->outletTagssScheduledForDeletion as $outletTags) {
                        // need to save related object because we set the relation to null
                        $outletTags->save($con);
                    }
                    $this->outletTagssScheduledForDeletion = null;
                }
            }

            if ($this->collOutletTagss !== null) {
                foreach ($this->collOutletTagss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletTypesScheduledForDeletion !== null) {
                if (!$this->outletTypesScheduledForDeletion->isEmpty()) {
                    \entities\OutletTypeQuery::create()
                        ->filterByPrimaryKeys($this->outletTypesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->outletTypesScheduledForDeletion = null;
                }
            }

            if ($this->collOutletTypes !== null) {
                foreach ($this->collOutletTypes as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletssScheduledForDeletion !== null) {
                if (!$this->outletssScheduledForDeletion->isEmpty()) {
                    \entities\OutletsQuery::create()
                        ->filterByPrimaryKeys($this->outletssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->outletssScheduledForDeletion = null;
                }
            }

            if ($this->collOutletss !== null) {
                foreach ($this->collOutletss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->policyMastersScheduledForDeletion !== null) {
                if (!$this->policyMastersScheduledForDeletion->isEmpty()) {
                    \entities\PolicyMasterQuery::create()
                        ->filterByPrimaryKeys($this->policyMastersScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->policyMastersScheduledForDeletion = null;
                }
            }

            if ($this->collPolicyMasters !== null) {
                foreach ($this->collPolicyMasters as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->policykeyssScheduledForDeletion !== null) {
                if (!$this->policykeyssScheduledForDeletion->isEmpty()) {
                    \entities\PolicykeysQuery::create()
                        ->filterByPrimaryKeys($this->policykeyssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->policykeyssScheduledForDeletion = null;
                }
            }

            if ($this->collPolicykeyss !== null) {
                foreach ($this->collPolicykeyss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->positionssScheduledForDeletion !== null) {
                if (!$this->positionssScheduledForDeletion->isEmpty()) {
                    \entities\PositionsQuery::create()
                        ->filterByPrimaryKeys($this->positionssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->positionssScheduledForDeletion = null;
                }
            }

            if ($this->collPositionss !== null) {
                foreach ($this->collPositionss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->pricebooklinessScheduledForDeletion !== null) {
                if (!$this->pricebooklinessScheduledForDeletion->isEmpty()) {
                    \entities\PricebooklinesQuery::create()
                        ->filterByPrimaryKeys($this->pricebooklinessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->pricebooklinessScheduledForDeletion = null;
                }
            }

            if ($this->collPricebookliness !== null) {
                foreach ($this->collPricebookliness as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->pricebookssScheduledForDeletion !== null) {
                if (!$this->pricebookssScheduledForDeletion->isEmpty()) {
                    foreach ($this->pricebookssScheduledForDeletion as $pricebooks) {
                        // need to save related object because we set the relation to null
                        $pricebooks->save($con);
                    }
                    $this->pricebookssScheduledForDeletion = null;
                }
            }

            if ($this->collPricebookss !== null) {
                foreach ($this->collPricebookss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->productssScheduledForDeletion !== null) {
                if (!$this->productssScheduledForDeletion->isEmpty()) {
                    \entities\ProductsQuery::create()
                        ->filterByPrimaryKeys($this->productssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->productssScheduledForDeletion = null;
                }
            }

            if ($this->collProductss !== null) {
                foreach ($this->collProductss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->reminderssScheduledForDeletion !== null) {
                if (!$this->reminderssScheduledForDeletion->isEmpty()) {
                    foreach ($this->reminderssScheduledForDeletion as $reminders) {
                        // need to save related object because we set the relation to null
                        $reminders->save($con);
                    }
                    $this->reminderssScheduledForDeletion = null;
                }
            }

            if ($this->collReminderss !== null) {
                foreach ($this->collReminderss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sgpiAccountssScheduledForDeletion !== null) {
                if (!$this->sgpiAccountssScheduledForDeletion->isEmpty()) {
                    \entities\SgpiAccountsQuery::create()
                        ->filterByPrimaryKeys($this->sgpiAccountssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->sgpiAccountssScheduledForDeletion = null;
                }
            }

            if ($this->collSgpiAccountss !== null) {
                foreach ($this->collSgpiAccountss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sgpiMastersScheduledForDeletion !== null) {
                if (!$this->sgpiMastersScheduledForDeletion->isEmpty()) {
                    foreach ($this->sgpiMastersScheduledForDeletion as $sgpiMaster) {
                        // need to save related object because we set the relation to null
                        $sgpiMaster->save($con);
                    }
                    $this->sgpiMastersScheduledForDeletion = null;
                }
            }

            if ($this->collSgpiMasters !== null) {
                foreach ($this->collSgpiMasters as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->sgpiTranssScheduledForDeletion !== null) {
                if (!$this->sgpiTranssScheduledForDeletion->isEmpty()) {
                    foreach ($this->sgpiTranssScheduledForDeletion as $sgpiTrans) {
                        // need to save related object because we set the relation to null
                        $sgpiTrans->save($con);
                    }
                    $this->sgpiTranssScheduledForDeletion = null;
                }
            }

            if ($this->collSgpiTranss !== null) {
                foreach ($this->collSgpiTranss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->shiftTypessScheduledForDeletion !== null) {
                if (!$this->shiftTypessScheduledForDeletion->isEmpty()) {
                    \entities\ShiftTypesQuery::create()
                        ->filterByPrimaryKeys($this->shiftTypessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->shiftTypessScheduledForDeletion = null;
                }
            }

            if ($this->collShiftTypess !== null) {
                foreach ($this->collShiftTypess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->shippinglinessScheduledForDeletion !== null) {
                if (!$this->shippinglinessScheduledForDeletion->isEmpty()) {
                    \entities\ShippinglinesQuery::create()
                        ->filterByPrimaryKeys($this->shippinglinessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->shippinglinessScheduledForDeletion = null;
                }
            }

            if ($this->collShippingliness !== null) {
                foreach ($this->collShippingliness as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->shippingordersScheduledForDeletion !== null) {
                if (!$this->shippingordersScheduledForDeletion->isEmpty()) {
                    \entities\ShippingorderQuery::create()
                        ->filterByPrimaryKeys($this->shippingordersScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->shippingordersScheduledForDeletion = null;
                }
            }

            if ($this->collShippingorders !== null) {
                foreach ($this->collShippingorders as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->stockTransactionsScheduledForDeletion !== null) {
                if (!$this->stockTransactionsScheduledForDeletion->isEmpty()) {
                    \entities\StockTransactionQuery::create()
                        ->filterByPrimaryKeys($this->stockTransactionsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->stockTransactionsScheduledForDeletion = null;
                }
            }

            if ($this->collStockTransactions !== null) {
                foreach ($this->collStockTransactions as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->stockVouchersScheduledForDeletion !== null) {
                if (!$this->stockVouchersScheduledForDeletion->isEmpty()) {
                    \entities\StockVoucherQuery::create()
                        ->filterByPrimaryKeys($this->stockVouchersScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->stockVouchersScheduledForDeletion = null;
                }
            }

            if ($this->collStockVouchers !== null) {
                foreach ($this->collStockVouchers as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->surveysScheduledForDeletion !== null) {
                if (!$this->surveysScheduledForDeletion->isEmpty()) {
                    foreach ($this->surveysScheduledForDeletion as $survey) {
                        // need to save related object because we set the relation to null
                        $survey->save($con);
                    }
                    $this->surveysScheduledForDeletion = null;
                }
            }

            if ($this->collSurveys !== null) {
                foreach ($this->collSurveys as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->surveyCategoriesScheduledForDeletion !== null) {
                if (!$this->surveyCategoriesScheduledForDeletion->isEmpty()) {
                    foreach ($this->surveyCategoriesScheduledForDeletion as $surveyCategory) {
                        // need to save related object because we set the relation to null
                        $surveyCategory->save($con);
                    }
                    $this->surveyCategoriesScheduledForDeletion = null;
                }
            }

            if ($this->collSurveyCategories !== null) {
                foreach ($this->collSurveyCategories as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->surveyQuestionsScheduledForDeletion !== null) {
                if (!$this->surveyQuestionsScheduledForDeletion->isEmpty()) {
                    foreach ($this->surveyQuestionsScheduledForDeletion as $surveyQuestion) {
                        // need to save related object because we set the relation to null
                        $surveyQuestion->save($con);
                    }
                    $this->surveyQuestionsScheduledForDeletion = null;
                }
            }

            if ($this->collSurveyQuestions !== null) {
                foreach ($this->collSurveyQuestions as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->surveySubmitedsScheduledForDeletion !== null) {
                if (!$this->surveySubmitedsScheduledForDeletion->isEmpty()) {
                    foreach ($this->surveySubmitedsScheduledForDeletion as $surveySubmited) {
                        // need to save related object because we set the relation to null
                        $surveySubmited->save($con);
                    }
                    $this->surveySubmitedsScheduledForDeletion = null;
                }
            }

            if ($this->collSurveySubmiteds !== null) {
                foreach ($this->collSurveySubmiteds as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->taConfigurationsScheduledForDeletion !== null) {
                if (!$this->taConfigurationsScheduledForDeletion->isEmpty()) {
                    foreach ($this->taConfigurationsScheduledForDeletion as $taConfiguration) {
                        // need to save related object because we set the relation to null
                        $taConfiguration->save($con);
                    }
                    $this->taConfigurationsScheduledForDeletion = null;
                }
            }

            if ($this->collTaConfigurations !== null) {
                foreach ($this->collTaConfigurations as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->tagssScheduledForDeletion !== null) {
                if (!$this->tagssScheduledForDeletion->isEmpty()) {
                    \entities\TagsQuery::create()
                        ->filterByPrimaryKeys($this->tagssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->tagssScheduledForDeletion = null;
                }
            }

            if ($this->collTagss !== null) {
                foreach ($this->collTagss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->territoriessScheduledForDeletion !== null) {
                if (!$this->territoriessScheduledForDeletion->isEmpty()) {
                    \entities\TerritoriesQuery::create()
                        ->filterByPrimaryKeys($this->territoriessScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->territoriessScheduledForDeletion = null;
                }
            }

            if ($this->collTerritoriess !== null) {
                foreach ($this->collTerritoriess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->territoryTownssScheduledForDeletion !== null) {
                if (!$this->territoryTownssScheduledForDeletion->isEmpty()) {
                    \entities\TerritoryTownsQuery::create()
                        ->filterByPrimaryKeys($this->territoryTownssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->territoryTownssScheduledForDeletion = null;
                }
            }

            if ($this->collTerritoryTownss !== null) {
                foreach ($this->collTerritoryTownss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ticketRepliessScheduledForDeletion !== null) {
                if (!$this->ticketRepliessScheduledForDeletion->isEmpty()) {
                    foreach ($this->ticketRepliessScheduledForDeletion as $ticketReplies) {
                        // need to save related object because we set the relation to null
                        $ticketReplies->save($con);
                    }
                    $this->ticketRepliessScheduledForDeletion = null;
                }
            }

            if ($this->collTicketRepliess !== null) {
                foreach ($this->collTicketRepliess as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ticketTypesScheduledForDeletion !== null) {
                if (!$this->ticketTypesScheduledForDeletion->isEmpty()) {
                    foreach ($this->ticketTypesScheduledForDeletion as $ticketType) {
                        // need to save related object because we set the relation to null
                        $ticketType->save($con);
                    }
                    $this->ticketTypesScheduledForDeletion = null;
                }
            }

            if ($this->collTicketTypes !== null) {
                foreach ($this->collTicketTypes as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->ticketssScheduledForDeletion !== null) {
                if (!$this->ticketssScheduledForDeletion->isEmpty()) {
                    \entities\TicketsQuery::create()
                        ->filterByPrimaryKeys($this->ticketssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->ticketssScheduledForDeletion = null;
                }
            }

            if ($this->collTicketss !== null) {
                foreach ($this->collTicketss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->tourplanssScheduledForDeletion !== null) {
                if (!$this->tourplanssScheduledForDeletion->isEmpty()) {
                    foreach ($this->tourplanssScheduledForDeletion as $tourplans) {
                        // need to save related object because we set the relation to null
                        $tourplans->save($con);
                    }
                    $this->tourplanssScheduledForDeletion = null;
                }
            }

            if ($this->collTourplanss !== null) {
                foreach ($this->collTourplanss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->transactionssScheduledForDeletion !== null) {
                if (!$this->transactionssScheduledForDeletion->isEmpty()) {
                    \entities\TransactionsQuery::create()
                        ->filterByPrimaryKeys($this->transactionssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->transactionssScheduledForDeletion = null;
                }
            }

            if ($this->collTransactionss !== null) {
                foreach ($this->collTransactionss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->userssScheduledForDeletion !== null) {
                if (!$this->userssScheduledForDeletion->isEmpty()) {
                    foreach ($this->userssScheduledForDeletion as $users) {
                        // need to save related object because we set the relation to null
                        $users->save($con);
                    }
                    $this->userssScheduledForDeletion = null;
                }
            }

            if ($this->collUserss !== null) {
                foreach ($this->collUserss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->wdbSyncLogsScheduledForDeletion !== null) {
                if (!$this->wdbSyncLogsScheduledForDeletion->isEmpty()) {
                    \entities\WdbSyncLogQuery::create()
                        ->filterByPrimaryKeys($this->wdbSyncLogsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->wdbSyncLogsScheduledForDeletion = null;
                }
            }

            if ($this->collWdbSyncLogs !== null) {
                foreach ($this->collWdbSyncLogs as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->wfRequestssScheduledForDeletion !== null) {
                if (!$this->wfRequestssScheduledForDeletion->isEmpty()) {
                    \entities\WfRequestsQuery::create()
                        ->filterByPrimaryKeys($this->wfRequestssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->wfRequestssScheduledForDeletion = null;
                }
            }

            if ($this->collWfRequestss !== null) {
                foreach ($this->collWfRequestss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->stpsScheduledForDeletion !== null) {
                if (!$this->stpsScheduledForDeletion->isEmpty()) {
                    \entities\StpQuery::create()
                        ->filterByPrimaryKeys($this->stpsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->stpsScheduledForDeletion = null;
                }
            }

            if ($this->collStps !== null) {
                foreach ($this->collStps as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->stpWeeksScheduledForDeletion !== null) {
                if (!$this->stpWeeksScheduledForDeletion->isEmpty()) {
                    \entities\StpWeekQuery::create()
                        ->filterByPrimaryKeys($this->stpWeeksScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->stpWeeksScheduledForDeletion = null;
                }
            }

            if ($this->collStpWeeks !== null) {
                foreach ($this->collStpWeeks as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->outletOrgDataKeyssScheduledForDeletion !== null) {
                if (!$this->outletOrgDataKeyssScheduledForDeletion->isEmpty()) {
                    \entities\OutletOrgDataKeysQuery::create()
                        ->filterByPrimaryKeys($this->outletOrgDataKeyssScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->outletOrgDataKeyssScheduledForDeletion = null;
                }
            }

            if ($this->collOutletOrgDataKeyss !== null) {
                foreach ($this->collOutletOrgDataKeyss as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->notificationConfigurationsScheduledForDeletion !== null) {
                if (!$this->notificationConfigurationsScheduledForDeletion->isEmpty()) {
                    \entities\NotificationConfigurationQuery::create()
                        ->filterByPrimaryKeys($this->notificationConfigurationsScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->notificationConfigurationsScheduledForDeletion = null;
                }
            }

            if ($this->collNotificationConfigurations !== null) {
                foreach ($this->collNotificationConfigurations as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            if ($this->leaveTypesScheduledForDeletion !== null) {
                if (!$this->leaveTypesScheduledForDeletion->isEmpty()) {
                    \entities\LeaveTypeQuery::create()
                        ->filterByPrimaryKeys($this->leaveTypesScheduledForDeletion->getPrimaryKeys(false))
                        ->delete($con);
                    $this->leaveTypesScheduledForDeletion = null;
                }
            }

            if ($this->collLeaveTypes !== null) {
                foreach ($this->collLeaveTypes as $referrerFK) {
                    if (!$referrerFK->isDeleted() && ($referrerFK->isNew() || $referrerFK->isModified())) {
                        $affectedRows += $referrerFK->save($con);
                    }
                }
            }

            $this->alreadyInSave = false;

        }

        return $affectedRows;
    }

    /**
     * Insert the row in the database.
     *
     * @param ConnectionInterface $con
     *
     * @throws \Propel\Runtime\Exception\PropelException
     * @see doSave()
     */
    protected function doInsert(ConnectionInterface $con): void
    {
        $modifiedColumns = [];
        $index = 0;

        $this->modifiedColumns[CompanyTableMap::COL_COMPANY_ID] = true;
        if (null !== $this->company_id) {
            throw new PropelException('Cannot insert a value for auto-increment primary key (' . CompanyTableMap::COL_COMPANY_ID . ')');
        }
        if (null === $this->company_id) {
            try {
                $dataFetcher = $con->query("SELECT nextval('company_company_id_seq')");
                $this->company_id = (int) $dataFetcher->fetchColumn();
            } catch (Exception $e) {
                throw new PropelException('Unable to get sequence id.', 0, $e);
            }
        }


         // check the columns in natural order for more readable SQL queries
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_ID)) {
            $modifiedColumns[':p' . $index++]  = 'company_id';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_CODE)) {
            $modifiedColumns[':p' . $index++]  = 'company_code';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_NAME)) {
            $modifiedColumns[':p' . $index++]  = 'company_name';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_OWNER_NAME)) {
            $modifiedColumns[':p' . $index++]  = 'owner_name';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_PHONE_NUMBER)) {
            $modifiedColumns[':p' . $index++]  = 'company_phone_number';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_CONTACT_NUMBER)) {
            $modifiedColumns[':p' . $index++]  = 'company_contact_number';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_LOGO)) {
            $modifiedColumns[':p' . $index++]  = 'company_logo';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_ADDRESS_1)) {
            $modifiedColumns[':p' . $index++]  = 'company_address_1';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_ADDRESS_2)) {
            $modifiedColumns[':p' . $index++]  = 'company_address_2';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_DEFAULT_CURRENCY)) {
            $modifiedColumns[':p' . $index++]  = 'company_default_currency';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_TIMEZONE)) {
            $modifiedColumns[':p' . $index++]  = 'timezone';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_FIRST_SETUP)) {
            $modifiedColumns[':p' . $index++]  = 'company_first_setup';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_OWNER_EMAIL)) {
            $modifiedColumns[':p' . $index++]  = 'owner_email';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_EXPENSE_REMINDER)) {
            $modifiedColumns[':p' . $index++]  = 'expense_reminder';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_CURRENTMONTHSUBMIT)) {
            $modifiedColumns[':p' . $index++]  = 'currentmonthsubmit';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_TRIPAPPROVALREQ)) {
            $modifiedColumns[':p' . $index++]  = 'tripapprovalreq';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_EXPENSEONLYONTRIP)) {
            $modifiedColumns[':p' . $index++]  = 'expenseonlyontrip';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_ALLOWBACKDATEDTRIP)) {
            $modifiedColumns[':p' . $index++]  = 'allowbackdatedtrip';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_PAYMENTSYSTEM)) {
            $modifiedColumns[':p' . $index++]  = 'paymentsystem';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_AUTO_SETTLE)) {
            $modifiedColumns[':p' . $index++]  = 'auto_settle';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_ALLOWRADIUS)) {
            $modifiedColumns[':p' . $index++]  = 'allowradius';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_ORDER_SEQ)) {
            $modifiedColumns[':p' . $index++]  = 'order_seq';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_SHIPPINGORDER_SEQ)) {
            $modifiedColumns[':p' . $index++]  = 'shippingorder_seq';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_GOOGLEMAPKEY)) {
            $modifiedColumns[':p' . $index++]  = 'googlemapkey';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_WORKINGDAYSINWEEK)) {
            $modifiedColumns[':p' . $index++]  = 'workingdaysinweek';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_AUTO_CALCULATED_TA)) {
            $modifiedColumns[':p' . $index++]  = 'auto_calculated_ta';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_REPORTING_DAYS)) {
            $modifiedColumns[':p' . $index++]  = 'reporting_days';
        }
        if ($this->isColumnModified(CompanyTableMap::COL_EXPENSE_MONTHS)) {
            $modifiedColumns[':p' . $index++]  = 'expense_months';
        }

        $sql = sprintf(
            'INSERT INTO company (%s) VALUES (%s)',
            implode(', ', $modifiedColumns),
            implode(', ', array_keys($modifiedColumns))
        );

        try {
            $stmt = $con->prepare($sql);
            foreach ($modifiedColumns as $identifier => $columnName) {
                switch ($columnName) {
                    case 'company_id':
                        $stmt->bindValue($identifier, $this->company_id, PDO::PARAM_INT);

                        break;
                    case 'company_code':
                        $stmt->bindValue($identifier, $this->company_code, PDO::PARAM_STR);

                        break;
                    case 'company_name':
                        $stmt->bindValue($identifier, $this->company_name, PDO::PARAM_STR);

                        break;
                    case 'owner_name':
                        $stmt->bindValue($identifier, $this->owner_name, PDO::PARAM_STR);

                        break;
                    case 'company_phone_number':
                        $stmt->bindValue($identifier, $this->company_phone_number, PDO::PARAM_STR);

                        break;
                    case 'company_contact_number':
                        $stmt->bindValue($identifier, $this->company_contact_number, PDO::PARAM_STR);

                        break;
                    case 'company_logo':
                        $stmt->bindValue($identifier, $this->company_logo, PDO::PARAM_STR);

                        break;
                    case 'company_address_1':
                        $stmt->bindValue($identifier, $this->company_address_1, PDO::PARAM_STR);

                        break;
                    case 'company_address_2':
                        $stmt->bindValue($identifier, $this->company_address_2, PDO::PARAM_STR);

                        break;
                    case 'company_default_currency':
                        $stmt->bindValue($identifier, $this->company_default_currency, PDO::PARAM_INT);

                        break;
                    case 'timezone':
                        $stmt->bindValue($identifier, $this->timezone, PDO::PARAM_STR);

                        break;
                    case 'company_first_setup':
                        $stmt->bindValue($identifier, $this->company_first_setup, PDO::PARAM_INT);

                        break;
                    case 'owner_email':
                        $stmt->bindValue($identifier, $this->owner_email, PDO::PARAM_STR);

                        break;
                    case 'expense_reminder':
                        $stmt->bindValue($identifier, $this->expense_reminder, PDO::PARAM_INT);

                        break;
                    case 'currentmonthsubmit':
                        $stmt->bindValue($identifier, $this->currentmonthsubmit, PDO::PARAM_INT);

                        break;
                    case 'tripapprovalreq':
                        $stmt->bindValue($identifier, $this->tripapprovalreq, PDO::PARAM_INT);

                        break;
                    case 'expenseonlyontrip':
                        $stmt->bindValue($identifier, $this->expenseonlyontrip, PDO::PARAM_INT);

                        break;
                    case 'allowbackdatedtrip':
                        $stmt->bindValue($identifier, $this->allowbackdatedtrip, PDO::PARAM_INT);

                        break;
                    case 'paymentsystem':
                        $stmt->bindValue($identifier, $this->paymentsystem, PDO::PARAM_INT);

                        break;
                    case 'auto_settle':
                        $stmt->bindValue($identifier, $this->auto_settle, PDO::PARAM_INT);

                        break;
                    case 'allowradius':
                        $stmt->bindValue($identifier, $this->allowradius, PDO::PARAM_INT);

                        break;
                    case 'order_seq':
                        $stmt->bindValue($identifier, $this->order_seq, PDO::PARAM_INT);

                        break;
                    case 'shippingorder_seq':
                        $stmt->bindValue($identifier, $this->shippingorder_seq, PDO::PARAM_INT);

                        break;
                    case 'googlemapkey':
                        $stmt->bindValue($identifier, $this->googlemapkey, PDO::PARAM_STR);

                        break;
                    case 'workingdaysinweek':
                        $stmt->bindValue($identifier, $this->workingdaysinweek, PDO::PARAM_INT);

                        break;
                    case 'auto_calculated_ta':
                        $stmt->bindValue($identifier, $this->auto_calculated_ta, PDO::PARAM_INT);

                        break;
                    case 'reporting_days':
                        $stmt->bindValue($identifier, $this->reporting_days, PDO::PARAM_STR);

                        break;
                    case 'expense_months':
                        $stmt->bindValue($identifier, $this->expense_months, PDO::PARAM_INT);

                        break;
                }
            }
            $stmt->execute();
        } catch (Exception $e) {
            Propel::log($e->getMessage(), Propel::LOG_ERR);
            throw new PropelException(sprintf('Unable to execute INSERT statement [%s]', $sql), 0, $e);
        }

        $this->setNew(false);
    }

    /**
     * Update the row in the database.
     *
     * @param ConnectionInterface $con
     *
     * @return int Number of updated rows
     * @see doSave()
     */
    protected function doUpdate(ConnectionInterface $con): int
    {
        $selectCriteria = $this->buildPkeyCriteria();
        $valuesCriteria = $this->buildCriteria();

        return $selectCriteria->doUpdate($valuesCriteria, $con);
    }

    /**
     * Retrieves a field from the object by name passed in as a string.
     *
     * @param string $name name
     * @param string $type The type of fieldname the $name is of:
     *                     one of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_CAMELNAME
     *                     TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM.
     *                     Defaults to TableMap::TYPE_PHPNAME.
     * @return mixed Value of field.
     */
    public function getByName(string $name, string $type = TableMap::TYPE_PHPNAME)
    {
        $pos = CompanyTableMap::translateFieldName($name, $type, TableMap::TYPE_NUM);
        $field = $this->getByPosition($pos);

        return $field;
    }

    /**
     * Retrieves a field from the object by Position as specified in the xml schema.
     * Zero-based.
     *
     * @param int $pos Position in XML schema
     * @return mixed Value of field at $pos
     */
    public function getByPosition(int $pos)
    {
        switch ($pos) {
            case 0:
                return $this->getCompanyId();

            case 1:
                return $this->getCompanyCode();

            case 2:
                return $this->getCompanyName();

            case 3:
                return $this->getOwnerName();

            case 4:
                return $this->getCompanyPhoneNumber();

            case 5:
                return $this->getCompanyContactNumber();

            case 6:
                return $this->getCompanyLogo();

            case 7:
                return $this->getCompanyAddress1();

            case 8:
                return $this->getCompanyAddress2();

            case 9:
                return $this->getCompanyDefaultCurrency();

            case 10:
                return $this->getTimezone();

            case 11:
                return $this->getCompanyFirstSetup();

            case 12:
                return $this->getOwnerEmail();

            case 13:
                return $this->getExpenseReminder();

            case 14:
                return $this->getCurrentmonthsubmit();

            case 15:
                return $this->getTripapprovalreq();

            case 16:
                return $this->getExpenseonlyontrip();

            case 17:
                return $this->getAllowbackdatedtrip();

            case 18:
                return $this->getPaymentsystem();

            case 19:
                return $this->getAutoSettle();

            case 20:
                return $this->getAllowradius();

            case 21:
                return $this->getOrderSeq();

            case 22:
                return $this->getShippingorderSeq();

            case 23:
                return $this->getGooglemapkey();

            case 24:
                return $this->getWorkingdaysinweek();

            case 25:
                return $this->getAutoCalculatedTa();

            case 26:
                return $this->getReportingDays();

            case 27:
                return $this->getExpenseMonths();

            default:
                return null;
        } // switch()
    }

    /**
     * Exports the object as an array.
     *
     * You can specify the key type of the array by passing one of the class
     * type constants.
     *
     * @param string $keyType (optional) One of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_CAMELNAME,
     *                    TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM.
     *                    Defaults to TableMap::TYPE_PHPNAME.
     * @param bool $includeLazyLoadColumns (optional) Whether to include lazy loaded columns. Defaults to TRUE.
     * @param array $alreadyDumpedObjects List of objects to skip to avoid recursion
     * @param bool $includeForeignObjects (optional) Whether to include hydrated related objects. Default to FALSE.
     *
     * @return array An associative array containing the field names (as keys) and field values
     */
    public function toArray(string $keyType = TableMap::TYPE_PHPNAME, bool $includeLazyLoadColumns = true, array $alreadyDumpedObjects = [], bool $includeForeignObjects = false): array
    {
        if (isset($alreadyDumpedObjects['Company'][$this->hashCode()])) {
            return ['*RECURSION*'];
        }
        $alreadyDumpedObjects['Company'][$this->hashCode()] = true;
        $keys = CompanyTableMap::getFieldNames($keyType);
        $result = [
            $keys[0] => $this->getCompanyId(),
            $keys[1] => $this->getCompanyCode(),
            $keys[2] => $this->getCompanyName(),
            $keys[3] => $this->getOwnerName(),
            $keys[4] => $this->getCompanyPhoneNumber(),
            $keys[5] => $this->getCompanyContactNumber(),
            $keys[6] => $this->getCompanyLogo(),
            $keys[7] => $this->getCompanyAddress1(),
            $keys[8] => $this->getCompanyAddress2(),
            $keys[9] => $this->getCompanyDefaultCurrency(),
            $keys[10] => $this->getTimezone(),
            $keys[11] => $this->getCompanyFirstSetup(),
            $keys[12] => $this->getOwnerEmail(),
            $keys[13] => $this->getExpenseReminder(),
            $keys[14] => $this->getCurrentmonthsubmit(),
            $keys[15] => $this->getTripapprovalreq(),
            $keys[16] => $this->getExpenseonlyontrip(),
            $keys[17] => $this->getAllowbackdatedtrip(),
            $keys[18] => $this->getPaymentsystem(),
            $keys[19] => $this->getAutoSettle(),
            $keys[20] => $this->getAllowradius(),
            $keys[21] => $this->getOrderSeq(),
            $keys[22] => $this->getShippingorderSeq(),
            $keys[23] => $this->getGooglemapkey(),
            $keys[24] => $this->getWorkingdaysinweek(),
            $keys[25] => $this->getAutoCalculatedTa(),
            $keys[26] => $this->getReportingDays(),
            $keys[27] => $this->getExpenseMonths(),
        ];
        $virtualColumns = $this->virtualColumns;
        foreach ($virtualColumns as $key => $virtualColumn) {
            $result[$key] = $virtualColumn;
        }

        if ($includeForeignObjects) {
            if (null !== $this->aExpenseMasterRelatedByAutoCalculatedTa) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'expenseMaster';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'expense_master';
                        break;
                    default:
                        $key = 'ExpenseMaster';
                }

                $result[$key] = $this->aExpenseMasterRelatedByAutoCalculatedTa->toArray($keyType, $includeLazyLoadColumns,  $alreadyDumpedObjects, true);
            }
            if (null !== $this->aCurrencies) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'currencies';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'currencies';
                        break;
                    default:
                        $key = 'Currencies';
                }

                $result[$key] = $this->aCurrencies->toArray($keyType, $includeLazyLoadColumns,  $alreadyDumpedObjects, true);
            }
            if (null !== $this->collAgendatypess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'agendatypess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'agendatypess';
                        break;
                    default:
                        $key = 'Agendatypess';
                }

                $result[$key] = $this->collAgendatypess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collAnnouncementss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'announcementss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'announcementss';
                        break;
                    default:
                        $key = 'Announcementss';
                }

                $result[$key] = $this->collAnnouncementss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collApiKeyss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'apiKeyss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'api_keyss';
                        break;
                    default:
                        $key = 'ApiKeyss';
                }

                $result[$key] = $this->collApiKeyss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collAttendances) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'attendances';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'attendances';
                        break;
                    default:
                        $key = 'Attendances';
                }

                $result[$key] = $this->collAttendances->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBeatOutletss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'beatOutletss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'beat_outletss';
                        break;
                    default:
                        $key = 'BeatOutletss';
                }

                $result[$key] = $this->collBeatOutletss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBeatss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'beatss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'beatss';
                        break;
                    default:
                        $key = 'Beatss';
                }

                $result[$key] = $this->collBeatss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBranches) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'branches';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'branches';
                        break;
                    default:
                        $key = 'Branches';
                }

                $result[$key] = $this->collBranches->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBrandCampiagns) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'brandCampiagns';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'brand_campiagns';
                        break;
                    default:
                        $key = 'BrandCampiagns';
                }

                $result[$key] = $this->collBrandCampiagns->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBrandCampiagnDoctorss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'brandCampiagnDoctorss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'brand_campiagn_doctorss';
                        break;
                    default:
                        $key = 'BrandCampiagnDoctorss';
                }

                $result[$key] = $this->collBrandCampiagnDoctorss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBrandCampiagnVisitPlans) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'brandCampiagnVisitPlans';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'brand_campiagn_visit_plans';
                        break;
                    default:
                        $key = 'BrandCampiagnVisitPlans';
                }

                $result[$key] = $this->collBrandCampiagnVisitPlans->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBrandCompetitions) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'brandCompetitions';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'brand_competitions';
                        break;
                    default:
                        $key = 'BrandCompetitions';
                }

                $result[$key] = $this->collBrandCompetitions->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBrandRcpas) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'brandRcpas';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'brand_rcpas';
                        break;
                    default:
                        $key = 'BrandRcpas';
                }

                $result[$key] = $this->collBrandRcpas->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBrandss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'brandss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'brandss';
                        break;
                    default:
                        $key = 'Brandss';
                }

                $result[$key] = $this->collBrandss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collBudgetGroups) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'budgetGroups';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'budget_groups';
                        break;
                    default:
                        $key = 'BudgetGroups';
                }

                $result[$key] = $this->collBudgetGroups->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collCategoriess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'categoriess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'categoriess';
                        break;
                    default:
                        $key = 'Categoriess';
                }

                $result[$key] = $this->collCategoriess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collCheckinoutOutcomess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'checkinoutOutcomess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'checkinout_outcomess';
                        break;
                    default:
                        $key = 'CheckinoutOutcomess';
                }

                $result[$key] = $this->collCheckinoutOutcomess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collCitycategories) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'citycategories';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'citycategories';
                        break;
                    default:
                        $key = 'Citycategories';
                }

                $result[$key] = $this->collCitycategories->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collClassifications) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'classifications';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'classifications';
                        break;
                    default:
                        $key = 'Classifications';
                }

                $result[$key] = $this->collClassifications->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collCompetitionMappings) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'competitionMappings';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'competition_mappings';
                        break;
                    default:
                        $key = 'CompetitionMappings';
                }

                $result[$key] = $this->collCompetitionMappings->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collCompetitors) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'competitors';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'competitors';
                        break;
                    default:
                        $key = 'Competitors';
                }

                $result[$key] = $this->collCompetitors->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collConfigurations) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'configurations';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'configurations';
                        break;
                    default:
                        $key = 'Configurations';
                }

                $result[$key] = $this->collConfigurations->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collCronCommandLogss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'cronCommandLogss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'cron_command_logss';
                        break;
                    default:
                        $key = 'CronCommandLogss';
                }

                $result[$key] = $this->collCronCommandLogss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collCronCommandss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'cronCommandss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'cron_commandss';
                        break;
                    default:
                        $key = 'CronCommandss';
                }

                $result[$key] = $this->collCronCommandss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collDailycallss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'dailycallss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'dailycallss';
                        break;
                    default:
                        $key = 'Dailycallss';
                }

                $result[$key] = $this->collDailycallss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collDailycallsSgpiouts) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'dailycallsSgpiouts';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'dailycalls_sgpiouts';
                        break;
                    default:
                        $key = 'DailycallsSgpiouts';
                }

                $result[$key] = $this->collDailycallsSgpiouts->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collDataExceptionLogss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'dataExceptionLogss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'data_exception_logss';
                        break;
                    default:
                        $key = 'DataExceptionLogss';
                }

                $result[$key] = $this->collDataExceptionLogss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collDataExceptionss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'dataExceptionss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'data_exceptionss';
                        break;
                    default:
                        $key = 'DataExceptionss';
                }

                $result[$key] = $this->collDataExceptionss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collDesignationss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'designationss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'designationss';
                        break;
                    default:
                        $key = 'Designationss';
                }

                $result[$key] = $this->collDesignationss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEdFeedbackss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'edFeedbackss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ed_feedbackss';
                        break;
                    default:
                        $key = 'EdFeedbackss';
                }

                $result[$key] = $this->collEdFeedbackss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEdPlaylists) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'edPlaylists';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ed_playlists';
                        break;
                    default:
                        $key = 'EdPlaylists';
                }

                $result[$key] = $this->collEdPlaylists->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEdPresentationss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'edPresentationss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ed_presentationss';
                        break;
                    default:
                        $key = 'EdPresentationss';
                }

                $result[$key] = $this->collEdPresentationss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEdSessions) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'edSessions';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ed_sessions';
                        break;
                    default:
                        $key = 'EdSessions';
                }

                $result[$key] = $this->collEdSessions->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEdStatss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'edStatss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ed_statss';
                        break;
                    default:
                        $key = 'EdStatss';
                }

                $result[$key] = $this->collEdStatss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEmployees) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'employees';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'employees';
                        break;
                    default:
                        $key = 'Employees';
                }

                $result[$key] = $this->collEmployees->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEmployeeIncentives) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'employeeIncentives';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'employee_incentives';
                        break;
                    default:
                        $key = 'EmployeeIncentives';
                }

                $result[$key] = $this->collEmployeeIncentives->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEventTypess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'eventTypess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'event_typess';
                        break;
                    default:
                        $key = 'EventTypess';
                }

                $result[$key] = $this->collEventTypess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collEventss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'eventss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'eventss';
                        break;
                    default:
                        $key = 'Eventss';
                }

                $result[$key] = $this->collEventss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collExpenseLists) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'expenseLists';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'expense_lists';
                        break;
                    default:
                        $key = 'ExpenseLists';
                }

                $result[$key] = $this->collExpenseLists->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collExpenseMastersRelatedByCompanyId) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'expenseMasters';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'expense_masters';
                        break;
                    default:
                        $key = 'ExpenseMasters';
                }

                $result[$key] = $this->collExpenseMastersRelatedByCompanyId->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collExpensePaymentss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'expensePaymentss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'expense_paymentss';
                        break;
                    default:
                        $key = 'ExpensePaymentss';
                }

                $result[$key] = $this->collExpensePaymentss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collExpensess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'expensess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'expensess';
                        break;
                    default:
                        $key = 'Expensess';
                }

                $result[$key] = $this->collExpensess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collFtpConfigss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'ftpConfigss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ftp_configss';
                        break;
                    default:
                        $key = 'FtpConfigss';
                }

                $result[$key] = $this->collFtpConfigss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collFtpExportBatchess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'ftpExportBatchess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ftp_export_batchess';
                        break;
                    default:
                        $key = 'FtpExportBatchess';
                }

                $result[$key] = $this->collFtpExportBatchess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collFtpExportLogss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'ftpExportLogss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ftp_export_logss';
                        break;
                    default:
                        $key = 'FtpExportLogss';
                }

                $result[$key] = $this->collFtpExportLogss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collFtpImportBatchess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'ftpImportBatchess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ftp_import_batchess';
                        break;
                    default:
                        $key = 'FtpImportBatchess';
                }

                $result[$key] = $this->collFtpImportBatchess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collFtpImportLogss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'ftpImportLogss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ftp_import_logss';
                        break;
                    default:
                        $key = 'FtpImportLogss';
                }

                $result[$key] = $this->collFtpImportLogss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collGradeMasters) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'gradeMasters';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'grade_masters';
                        break;
                    default:
                        $key = 'GradeMasters';
                }

                $result[$key] = $this->collGradeMasters->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collHolidayss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'holidayss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'holidayss';
                        break;
                    default:
                        $key = 'Holidayss';
                }

                $result[$key] = $this->collHolidayss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collIntegrationApiLogss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'integrationApiLogss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'integration_api_logss';
                        break;
                    default:
                        $key = 'IntegrationApiLogss';
                }

                $result[$key] = $this->collIntegrationApiLogss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collLeaveRequests) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'leaveRequests';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'leave_requests';
                        break;
                    default:
                        $key = 'LeaveRequests';
                }

                $result[$key] = $this->collLeaveRequests->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collLeavess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'leavess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'leavess';
                        break;
                    default:
                        $key = 'Leavess';
                }

                $result[$key] = $this->collLeavess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMaterialFolderss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'materialFolderss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'material_folderss';
                        break;
                    default:
                        $key = 'MaterialFolderss';
                }

                $result[$key] = $this->collMaterialFolderss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMediaFiless) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'mediaFiless';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'media_filess';
                        break;
                    default:
                        $key = 'MediaFiless';
                }

                $result[$key] = $this->collMediaFiless->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMediaFolderss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'mediaFolderss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'media_folderss';
                        break;
                    default:
                        $key = 'MediaFolderss';
                }

                $result[$key] = $this->collMediaFolderss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMtps) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'mtps';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'mtps';
                        break;
                    default:
                        $key = 'Mtps';
                }

                $result[$key] = $this->collMtps->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMtpDays) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'mtpDays';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'mtp_days';
                        break;
                    default:
                        $key = 'MtpDays';
                }

                $result[$key] = $this->collMtpDays->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collMtpLogss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'mtpLogss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'mtp_logss';
                        break;
                    default:
                        $key = 'MtpLogss';
                }

                $result[$key] = $this->collMtpLogss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOfferss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'offerss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'offerss';
                        break;
                    default:
                        $key = 'Offerss';
                }

                $result[$key] = $this->collOfferss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOnBoardRequests) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'onBoardRequests';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'on_board_requests';
                        break;
                    default:
                        $key = 'OnBoardRequests';
                }

                $result[$key] = $this->collOnBoardRequests->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOnBoardRequestAddresses) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'onBoardRequestAddresses';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'on_board_request_addresses';
                        break;
                    default:
                        $key = 'OnBoardRequestAddresses';
                }

                $result[$key] = $this->collOnBoardRequestAddresses->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOnBoardRequiredFieldss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'onBoardRequiredFieldss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'on_board_required_fieldss';
                        break;
                    default:
                        $key = 'OnBoardRequiredFieldss';
                }

                $result[$key] = $this->collOnBoardRequiredFieldss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOrderLogs) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'orderLogs';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'order_logs';
                        break;
                    default:
                        $key = 'OrderLogs';
                }

                $result[$key] = $this->collOrderLogs->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOrderliness) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'orderliness';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'orderliness';
                        break;
                    default:
                        $key = 'Orderliness';
                }

                $result[$key] = $this->collOrderliness->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOrderss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'orderss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'orderss';
                        break;
                    default:
                        $key = 'Orderss';
                }

                $result[$key] = $this->collOrderss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOrgUnits) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'orgUnits';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'org_units';
                        break;
                    default:
                        $key = 'OrgUnits';
                }

                $result[$key] = $this->collOrgUnits->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOtpRequestss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'otpRequestss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'otp_requestss';
                        break;
                    default:
                        $key = 'OtpRequestss';
                }

                $result[$key] = $this->collOtpRequestss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletAddresses) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletAddresses';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_addresses';
                        break;
                    default:
                        $key = 'OutletAddresses';
                }

                $result[$key] = $this->collOutletAddresses->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletOrgDatas) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletOrgDatas';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_org_datas';
                        break;
                    default:
                        $key = 'OutletOrgDatas';
                }

                $result[$key] = $this->collOutletOrgDatas->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletOrgNotess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletOrgNotess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_org_notess';
                        break;
                    default:
                        $key = 'OutletOrgNotess';
                }

                $result[$key] = $this->collOutletOrgNotess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletOutcomess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletOutcomess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_outcomess';
                        break;
                    default:
                        $key = 'OutletOutcomess';
                }

                $result[$key] = $this->collOutletOutcomess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletStocks) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletStocks';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_stocks';
                        break;
                    default:
                        $key = 'OutletStocks';
                }

                $result[$key] = $this->collOutletStocks->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletStockOtherSummaries) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletStockOtherSummaries';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_stock_other_summaries';
                        break;
                    default:
                        $key = 'OutletStockOtherSummaries';
                }

                $result[$key] = $this->collOutletStockOtherSummaries->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletStockSummaries) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletStockSummaries';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_stock_summaries';
                        break;
                    default:
                        $key = 'OutletStockSummaries';
                }

                $result[$key] = $this->collOutletStockSummaries->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletTagss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletTagss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_tagss';
                        break;
                    default:
                        $key = 'OutletTagss';
                }

                $result[$key] = $this->collOutletTagss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletTypes) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletTypes';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_types';
                        break;
                    default:
                        $key = 'OutletTypes';
                }

                $result[$key] = $this->collOutletTypes->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outletss';
                        break;
                    default:
                        $key = 'Outletss';
                }

                $result[$key] = $this->collOutletss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPolicyMasters) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'policyMasters';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'policy_masters';
                        break;
                    default:
                        $key = 'PolicyMasters';
                }

                $result[$key] = $this->collPolicyMasters->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPolicykeyss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'policykeyss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'policykeyss';
                        break;
                    default:
                        $key = 'Policykeyss';
                }

                $result[$key] = $this->collPolicykeyss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPositionss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'positionss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'positionss';
                        break;
                    default:
                        $key = 'Positionss';
                }

                $result[$key] = $this->collPositionss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPricebookliness) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'pricebookliness';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'pricebookliness';
                        break;
                    default:
                        $key = 'Pricebookliness';
                }

                $result[$key] = $this->collPricebookliness->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collPricebookss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'pricebookss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'pricebookss';
                        break;
                    default:
                        $key = 'Pricebookss';
                }

                $result[$key] = $this->collPricebookss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collProductss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'productss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'productss';
                        break;
                    default:
                        $key = 'Productss';
                }

                $result[$key] = $this->collProductss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collReminderss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'reminderss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'reminderss';
                        break;
                    default:
                        $key = 'Reminderss';
                }

                $result[$key] = $this->collReminderss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSgpiAccountss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'sgpiAccountss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'sgpi_accountss';
                        break;
                    default:
                        $key = 'SgpiAccountss';
                }

                $result[$key] = $this->collSgpiAccountss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSgpiMasters) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'sgpiMasters';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'sgpi_masters';
                        break;
                    default:
                        $key = 'SgpiMasters';
                }

                $result[$key] = $this->collSgpiMasters->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSgpiTranss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'sgpiTranss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'sgpi_transs';
                        break;
                    default:
                        $key = 'SgpiTranss';
                }

                $result[$key] = $this->collSgpiTranss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collShiftTypess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'shiftTypess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'shift_typess';
                        break;
                    default:
                        $key = 'ShiftTypess';
                }

                $result[$key] = $this->collShiftTypess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collShippingliness) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'shippingliness';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'shippingliness';
                        break;
                    default:
                        $key = 'Shippingliness';
                }

                $result[$key] = $this->collShippingliness->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collShippingorders) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'shippingorders';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'shippingorders';
                        break;
                    default:
                        $key = 'Shippingorders';
                }

                $result[$key] = $this->collShippingorders->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collStockTransactions) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'stockTransactions';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'stock_transactions';
                        break;
                    default:
                        $key = 'StockTransactions';
                }

                $result[$key] = $this->collStockTransactions->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collStockVouchers) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'stockVouchers';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'stock_vouchers';
                        break;
                    default:
                        $key = 'StockVouchers';
                }

                $result[$key] = $this->collStockVouchers->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSurveys) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'surveys';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'surveys';
                        break;
                    default:
                        $key = 'Surveys';
                }

                $result[$key] = $this->collSurveys->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSurveyCategories) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'surveyCategories';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'survey_categories';
                        break;
                    default:
                        $key = 'SurveyCategories';
                }

                $result[$key] = $this->collSurveyCategories->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSurveyQuestions) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'surveyQuestions';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'survey_questions';
                        break;
                    default:
                        $key = 'SurveyQuestions';
                }

                $result[$key] = $this->collSurveyQuestions->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collSurveySubmiteds) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'surveySubmiteds';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'survey_submiteds';
                        break;
                    default:
                        $key = 'SurveySubmiteds';
                }

                $result[$key] = $this->collSurveySubmiteds->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTaConfigurations) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'taConfigurations';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ta_configurations';
                        break;
                    default:
                        $key = 'TaConfigurations';
                }

                $result[$key] = $this->collTaConfigurations->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTagss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'tagss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'tagss';
                        break;
                    default:
                        $key = 'Tagss';
                }

                $result[$key] = $this->collTagss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTerritoriess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'territoriess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'territoriess';
                        break;
                    default:
                        $key = 'Territoriess';
                }

                $result[$key] = $this->collTerritoriess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTerritoryTownss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'territoryTownss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'territory_townss';
                        break;
                    default:
                        $key = 'TerritoryTownss';
                }

                $result[$key] = $this->collTerritoryTownss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTicketRepliess) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'ticketRepliess';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ticket_repliess';
                        break;
                    default:
                        $key = 'TicketRepliess';
                }

                $result[$key] = $this->collTicketRepliess->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTicketTypes) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'ticketTypes';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ticket_types';
                        break;
                    default:
                        $key = 'TicketTypes';
                }

                $result[$key] = $this->collTicketTypes->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTicketss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'ticketss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'ticketss';
                        break;
                    default:
                        $key = 'Ticketss';
                }

                $result[$key] = $this->collTicketss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTourplanss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'tourplanss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'tourplanss';
                        break;
                    default:
                        $key = 'Tourplanss';
                }

                $result[$key] = $this->collTourplanss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collTransactionss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'transactionss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'transactionss';
                        break;
                    default:
                        $key = 'Transactionss';
                }

                $result[$key] = $this->collTransactionss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collUserss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'userss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'userss';
                        break;
                    default:
                        $key = 'Userss';
                }

                $result[$key] = $this->collUserss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collWdbSyncLogs) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'wdbSyncLogs';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'wdb_sync_logs';
                        break;
                    default:
                        $key = 'WdbSyncLogs';
                }

                $result[$key] = $this->collWdbSyncLogs->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collWfRequestss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'wfRequestss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'wf_requestss';
                        break;
                    default:
                        $key = 'WfRequestss';
                }

                $result[$key] = $this->collWfRequestss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collStps) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'stps';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'stps';
                        break;
                    default:
                        $key = 'Stps';
                }

                $result[$key] = $this->collStps->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collStpWeeks) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'stpWeeks';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'stp_weeks';
                        break;
                    default:
                        $key = 'StpWeeks';
                }

                $result[$key] = $this->collStpWeeks->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collOutletOrgDataKeyss) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'outletOrgDataKeyss';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'outlet_org_data_keyss';
                        break;
                    default:
                        $key = 'OutletOrgDataKeyss';
                }

                $result[$key] = $this->collOutletOrgDataKeyss->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collNotificationConfigurations) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'notificationConfigurations';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'notification_configurations';
                        break;
                    default:
                        $key = 'NotificationConfigurations';
                }

                $result[$key] = $this->collNotificationConfigurations->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
            if (null !== $this->collLeaveTypes) {

                switch ($keyType) {
                    case TableMap::TYPE_CAMELNAME:
                        $key = 'leaveTypes';
                        break;
                    case TableMap::TYPE_FIELDNAME:
                        $key = 'leave_types';
                        break;
                    default:
                        $key = 'LeaveTypes';
                }

                $result[$key] = $this->collLeaveTypes->toArray(null, false, $keyType, $includeLazyLoadColumns, $alreadyDumpedObjects);
            }
        }

        return $result;
    }

    /**
     * Sets a field from the object by name passed in as a string.
     *
     * @param string $name
     * @param mixed $value field value
     * @param string $type The type of fieldname the $name is of:
     *                one of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_CAMELNAME
     *                TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM.
     *                Defaults to TableMap::TYPE_PHPNAME.
     * @return $this
     */
    public function setByName(string $name, $value, string $type = TableMap::TYPE_PHPNAME)
    {
        $pos = CompanyTableMap::translateFieldName($name, $type, TableMap::TYPE_NUM);

        $this->setByPosition($pos, $value);

        return $this;
    }

    /**
     * Sets a field from the object by Position as specified in the xml schema.
     * Zero-based.
     *
     * @param int $pos position in xml schema
     * @param mixed $value field value
     * @return $this
     */
    public function setByPosition(int $pos, $value)
    {
        switch ($pos) {
            case 0:
                $this->setCompanyId($value);
                break;
            case 1:
                $this->setCompanyCode($value);
                break;
            case 2:
                $this->setCompanyName($value);
                break;
            case 3:
                $this->setOwnerName($value);
                break;
            case 4:
                $this->setCompanyPhoneNumber($value);
                break;
            case 5:
                $this->setCompanyContactNumber($value);
                break;
            case 6:
                $this->setCompanyLogo($value);
                break;
            case 7:
                $this->setCompanyAddress1($value);
                break;
            case 8:
                $this->setCompanyAddress2($value);
                break;
            case 9:
                $this->setCompanyDefaultCurrency($value);
                break;
            case 10:
                $this->setTimezone($value);
                break;
            case 11:
                $this->setCompanyFirstSetup($value);
                break;
            case 12:
                $this->setOwnerEmail($value);
                break;
            case 13:
                $this->setExpenseReminder($value);
                break;
            case 14:
                $this->setCurrentmonthsubmit($value);
                break;
            case 15:
                $this->setTripapprovalreq($value);
                break;
            case 16:
                $this->setExpenseonlyontrip($value);
                break;
            case 17:
                $this->setAllowbackdatedtrip($value);
                break;
            case 18:
                $this->setPaymentsystem($value);
                break;
            case 19:
                $this->setAutoSettle($value);
                break;
            case 20:
                $this->setAllowradius($value);
                break;
            case 21:
                $this->setOrderSeq($value);
                break;
            case 22:
                $this->setShippingorderSeq($value);
                break;
            case 23:
                $this->setGooglemapkey($value);
                break;
            case 24:
                $this->setWorkingdaysinweek($value);
                break;
            case 25:
                $this->setAutoCalculatedTa($value);
                break;
            case 26:
                $this->setReportingDays($value);
                break;
            case 27:
                $this->setExpenseMonths($value);
                break;
        } // switch()

        return $this;
    }

    /**
     * Populates the object using an array.
     *
     * This is particularly useful when populating an object from one of the
     * request arrays (e.g. $_POST).  This method goes through the column
     * names, checking to see whether a matching key exists in populated
     * array. If so the setByName() method is called for that column.
     *
     * You can specify the key type of the array by additionally passing one
     * of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_CAMELNAME,
     * TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM.
     * The default key type is the column's TableMap::TYPE_PHPNAME.
     *
     * @param array $arr An array to populate the object from.
     * @param string $keyType The type of keys the array uses.
     * @return $this
     */
    public function fromArray(array $arr, string $keyType = TableMap::TYPE_PHPNAME)
    {
        $keys = CompanyTableMap::getFieldNames($keyType);

        if (array_key_exists($keys[0], $arr)) {
            $this->setCompanyId($arr[$keys[0]]);
        }
        if (array_key_exists($keys[1], $arr)) {
            $this->setCompanyCode($arr[$keys[1]]);
        }
        if (array_key_exists($keys[2], $arr)) {
            $this->setCompanyName($arr[$keys[2]]);
        }
        if (array_key_exists($keys[3], $arr)) {
            $this->setOwnerName($arr[$keys[3]]);
        }
        if (array_key_exists($keys[4], $arr)) {
            $this->setCompanyPhoneNumber($arr[$keys[4]]);
        }
        if (array_key_exists($keys[5], $arr)) {
            $this->setCompanyContactNumber($arr[$keys[5]]);
        }
        if (array_key_exists($keys[6], $arr)) {
            $this->setCompanyLogo($arr[$keys[6]]);
        }
        if (array_key_exists($keys[7], $arr)) {
            $this->setCompanyAddress1($arr[$keys[7]]);
        }
        if (array_key_exists($keys[8], $arr)) {
            $this->setCompanyAddress2($arr[$keys[8]]);
        }
        if (array_key_exists($keys[9], $arr)) {
            $this->setCompanyDefaultCurrency($arr[$keys[9]]);
        }
        if (array_key_exists($keys[10], $arr)) {
            $this->setTimezone($arr[$keys[10]]);
        }
        if (array_key_exists($keys[11], $arr)) {
            $this->setCompanyFirstSetup($arr[$keys[11]]);
        }
        if (array_key_exists($keys[12], $arr)) {
            $this->setOwnerEmail($arr[$keys[12]]);
        }
        if (array_key_exists($keys[13], $arr)) {
            $this->setExpenseReminder($arr[$keys[13]]);
        }
        if (array_key_exists($keys[14], $arr)) {
            $this->setCurrentmonthsubmit($arr[$keys[14]]);
        }
        if (array_key_exists($keys[15], $arr)) {
            $this->setTripapprovalreq($arr[$keys[15]]);
        }
        if (array_key_exists($keys[16], $arr)) {
            $this->setExpenseonlyontrip($arr[$keys[16]]);
        }
        if (array_key_exists($keys[17], $arr)) {
            $this->setAllowbackdatedtrip($arr[$keys[17]]);
        }
        if (array_key_exists($keys[18], $arr)) {
            $this->setPaymentsystem($arr[$keys[18]]);
        }
        if (array_key_exists($keys[19], $arr)) {
            $this->setAutoSettle($arr[$keys[19]]);
        }
        if (array_key_exists($keys[20], $arr)) {
            $this->setAllowradius($arr[$keys[20]]);
        }
        if (array_key_exists($keys[21], $arr)) {
            $this->setOrderSeq($arr[$keys[21]]);
        }
        if (array_key_exists($keys[22], $arr)) {
            $this->setShippingorderSeq($arr[$keys[22]]);
        }
        if (array_key_exists($keys[23], $arr)) {
            $this->setGooglemapkey($arr[$keys[23]]);
        }
        if (array_key_exists($keys[24], $arr)) {
            $this->setWorkingdaysinweek($arr[$keys[24]]);
        }
        if (array_key_exists($keys[25], $arr)) {
            $this->setAutoCalculatedTa($arr[$keys[25]]);
        }
        if (array_key_exists($keys[26], $arr)) {
            $this->setReportingDays($arr[$keys[26]]);
        }
        if (array_key_exists($keys[27], $arr)) {
            $this->setExpenseMonths($arr[$keys[27]]);
        }

        return $this;
    }

     /**
     * Populate the current object from a string, using a given parser format
     * <code>
     * $book = new Book();
     * $book->importFrom('JSON', '{"Id":9012,"Title":"Don Juan","ISBN":"0140422161","Price":12.99,"PublisherId":1234,"AuthorId":5678}');
     * </code>
     *
     * You can specify the key type of the array by additionally passing one
     * of the class type constants TableMap::TYPE_PHPNAME, TableMap::TYPE_CAMELNAME,
     * TableMap::TYPE_COLNAME, TableMap::TYPE_FIELDNAME, TableMap::TYPE_NUM.
     * The default key type is the column's TableMap::TYPE_PHPNAME.
     *
     * @param mixed $parser A AbstractParser instance,
     *                       or a format name ('XML', 'YAML', 'JSON', 'CSV')
     * @param string $data The source data to import from
     * @param string $keyType The type of keys the array uses.
     *
     * @return $this The current object, for fluid interface
     */
    public function importFrom($parser, string $data, string $keyType = TableMap::TYPE_PHPNAME)
    {
        if (!$parser instanceof AbstractParser) {
            $parser = AbstractParser::getParser($parser);
        }

        $this->fromArray($parser->toArray($data), $keyType);

        return $this;
    }

    /**
     * Build a Criteria object containing the values of all modified columns in this object.
     *
     * @return \Propel\Runtime\ActiveQuery\Criteria The Criteria object containing all modified values.
     */
    public function buildCriteria(): Criteria
    {
        $criteria = new Criteria(CompanyTableMap::DATABASE_NAME);

        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_ID)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_ID, $this->company_id);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_CODE)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_CODE, $this->company_code);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_NAME)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_NAME, $this->company_name);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_OWNER_NAME)) {
            $criteria->add(CompanyTableMap::COL_OWNER_NAME, $this->owner_name);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_PHONE_NUMBER)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_PHONE_NUMBER, $this->company_phone_number);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_CONTACT_NUMBER)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_CONTACT_NUMBER, $this->company_contact_number);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_LOGO)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_LOGO, $this->company_logo);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_ADDRESS_1)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_ADDRESS_1, $this->company_address_1);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_ADDRESS_2)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_ADDRESS_2, $this->company_address_2);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_DEFAULT_CURRENCY)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_DEFAULT_CURRENCY, $this->company_default_currency);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_TIMEZONE)) {
            $criteria->add(CompanyTableMap::COL_TIMEZONE, $this->timezone);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_COMPANY_FIRST_SETUP)) {
            $criteria->add(CompanyTableMap::COL_COMPANY_FIRST_SETUP, $this->company_first_setup);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_OWNER_EMAIL)) {
            $criteria->add(CompanyTableMap::COL_OWNER_EMAIL, $this->owner_email);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_EXPENSE_REMINDER)) {
            $criteria->add(CompanyTableMap::COL_EXPENSE_REMINDER, $this->expense_reminder);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_CURRENTMONTHSUBMIT)) {
            $criteria->add(CompanyTableMap::COL_CURRENTMONTHSUBMIT, $this->currentmonthsubmit);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_TRIPAPPROVALREQ)) {
            $criteria->add(CompanyTableMap::COL_TRIPAPPROVALREQ, $this->tripapprovalreq);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_EXPENSEONLYONTRIP)) {
            $criteria->add(CompanyTableMap::COL_EXPENSEONLYONTRIP, $this->expenseonlyontrip);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_ALLOWBACKDATEDTRIP)) {
            $criteria->add(CompanyTableMap::COL_ALLOWBACKDATEDTRIP, $this->allowbackdatedtrip);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_PAYMENTSYSTEM)) {
            $criteria->add(CompanyTableMap::COL_PAYMENTSYSTEM, $this->paymentsystem);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_AUTO_SETTLE)) {
            $criteria->add(CompanyTableMap::COL_AUTO_SETTLE, $this->auto_settle);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_ALLOWRADIUS)) {
            $criteria->add(CompanyTableMap::COL_ALLOWRADIUS, $this->allowradius);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_ORDER_SEQ)) {
            $criteria->add(CompanyTableMap::COL_ORDER_SEQ, $this->order_seq);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_SHIPPINGORDER_SEQ)) {
            $criteria->add(CompanyTableMap::COL_SHIPPINGORDER_SEQ, $this->shippingorder_seq);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_GOOGLEMAPKEY)) {
            $criteria->add(CompanyTableMap::COL_GOOGLEMAPKEY, $this->googlemapkey);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_WORKINGDAYSINWEEK)) {
            $criteria->add(CompanyTableMap::COL_WORKINGDAYSINWEEK, $this->workingdaysinweek);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_AUTO_CALCULATED_TA)) {
            $criteria->add(CompanyTableMap::COL_AUTO_CALCULATED_TA, $this->auto_calculated_ta);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_REPORTING_DAYS)) {
            $criteria->add(CompanyTableMap::COL_REPORTING_DAYS, $this->reporting_days);
        }
        if ($this->isColumnModified(CompanyTableMap::COL_EXPENSE_MONTHS)) {
            $criteria->add(CompanyTableMap::COL_EXPENSE_MONTHS, $this->expense_months);
        }

        return $criteria;
    }

    /**
     * Builds a Criteria object containing the primary key for this object.
     *
     * Unlike buildCriteria() this method includes the primary key values regardless
     * of whether they have been modified.
     *
     * @throws LogicException if no primary key is defined
     *
     * @return \Propel\Runtime\ActiveQuery\Criteria The Criteria object containing value(s) for primary key(s).
     */
    public function buildPkeyCriteria(): Criteria
    {
        $criteria = ChildCompanyQuery::create();
        $criteria->add(CompanyTableMap::COL_COMPANY_ID, $this->company_id);

        return $criteria;
    }

    /**
     * If the primary key is not null, return the hashcode of the
     * primary key. Otherwise, return the hash code of the object.
     *
     * @return int|string Hashcode
     */
    public function hashCode()
    {
        $validPk = null !== $this->getCompanyId();

        $validPrimaryKeyFKs = 0;
        $primaryKeyFKs = [];

        if ($validPk) {
            return crc32(json_encode($this->getPrimaryKey(), JSON_UNESCAPED_UNICODE));
        } elseif ($validPrimaryKeyFKs) {
            return crc32(json_encode($primaryKeyFKs, JSON_UNESCAPED_UNICODE));
        }

        return spl_object_hash($this);
    }

    /**
     * Returns the primary key for this object (row).
     * @return int
     */
    public function getPrimaryKey()
    {
        return $this->getCompanyId();
    }

    /**
     * Generic method to set the primary key (company_id column).
     *
     * @param int|null $key Primary key.
     * @return void
     */
    public function setPrimaryKey(?int $key = null): void
    {
        $this->setCompanyId($key);
    }

    /**
     * Returns true if the primary key for this object is null.
     *
     * @return bool
     */
    public function isPrimaryKeyNull(): bool
    {
        return null === $this->getCompanyId();
    }

    /**
     * Sets contents of passed object to values from current object.
     *
     * If desired, this method can also make copies of all associated (fkey referrers)
     * objects.
     *
     * @param object $copyObj An object of \entities\Company (or compatible) type.
     * @param bool $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
     * @param bool $makeNew Whether to reset autoincrement PKs and make the object new.
     * @throws \Propel\Runtime\Exception\PropelException
     * @return void
     */
    public function copyInto(object $copyObj, bool $deepCopy = false, bool $makeNew = true): void
    {
        $copyObj->setCompanyCode($this->getCompanyCode());
        $copyObj->setCompanyName($this->getCompanyName());
        $copyObj->setOwnerName($this->getOwnerName());
        $copyObj->setCompanyPhoneNumber($this->getCompanyPhoneNumber());
        $copyObj->setCompanyContactNumber($this->getCompanyContactNumber());
        $copyObj->setCompanyLogo($this->getCompanyLogo());
        $copyObj->setCompanyAddress1($this->getCompanyAddress1());
        $copyObj->setCompanyAddress2($this->getCompanyAddress2());
        $copyObj->setCompanyDefaultCurrency($this->getCompanyDefaultCurrency());
        $copyObj->setTimezone($this->getTimezone());
        $copyObj->setCompanyFirstSetup($this->getCompanyFirstSetup());
        $copyObj->setOwnerEmail($this->getOwnerEmail());
        $copyObj->setExpenseReminder($this->getExpenseReminder());
        $copyObj->setCurrentmonthsubmit($this->getCurrentmonthsubmit());
        $copyObj->setTripapprovalreq($this->getTripapprovalreq());
        $copyObj->setExpenseonlyontrip($this->getExpenseonlyontrip());
        $copyObj->setAllowbackdatedtrip($this->getAllowbackdatedtrip());
        $copyObj->setPaymentsystem($this->getPaymentsystem());
        $copyObj->setAutoSettle($this->getAutoSettle());
        $copyObj->setAllowradius($this->getAllowradius());
        $copyObj->setOrderSeq($this->getOrderSeq());
        $copyObj->setShippingorderSeq($this->getShippingorderSeq());
        $copyObj->setGooglemapkey($this->getGooglemapkey());
        $copyObj->setWorkingdaysinweek($this->getWorkingdaysinweek());
        $copyObj->setAutoCalculatedTa($this->getAutoCalculatedTa());
        $copyObj->setReportingDays($this->getReportingDays());
        $copyObj->setExpenseMonths($this->getExpenseMonths());

        if ($deepCopy) {
            // important: temporarily setNew(false) because this affects the behavior of
            // the getter/setter methods for fkey referrer objects.
            $copyObj->setNew(false);

            foreach ($this->getAgendatypess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addAgendatypes($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getAnnouncementss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addAnnouncements($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getApiKeyss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addApiKeys($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getAttendances() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addAttendance($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBeatOutletss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBeatOutlets($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBeatss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBeats($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBranches() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBranch($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBrandCampiagns() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBrandCampiagn($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBrandCampiagnDoctorss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBrandCampiagnDoctors($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBrandCampiagnVisitPlans() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBrandCampiagnVisitPlan($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBrandCompetitions() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBrandCompetition($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBrandRcpas() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBrandRcpa($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBrandss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBrands($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getBudgetGroups() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addBudgetGroup($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getCategoriess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addCategories($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getCheckinoutOutcomess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addCheckinoutOutcomes($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getCitycategories() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addCitycategory($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getClassifications() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addClassification($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getCompetitionMappings() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addCompetitionMapping($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getCompetitors() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addCompetitor($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getConfigurations() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addConfiguration($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getCronCommandLogss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addCronCommandLogs($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getCronCommandss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addCronCommands($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getDailycallss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addDailycalls($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getDailycallsSgpiouts() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addDailycallsSgpiout($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getDataExceptionLogss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addDataExceptionLogs($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getDataExceptionss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addDataExceptions($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getDesignationss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addDesignations($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEdFeedbackss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEdFeedbacks($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEdPlaylists() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEdPlaylist($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEdPresentationss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEdPresentations($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEdSessions() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEdSession($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEdStatss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEdStats($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEmployees() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEmployee($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEmployeeIncentives() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEmployeeIncentive($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEventTypess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEventTypes($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getEventss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addEvents($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getExpenseLists() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addExpenseList($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getExpenseMastersRelatedByCompanyId() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addExpenseMasterRelatedByCompanyId($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getExpensePaymentss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addExpensePayments($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getExpensess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addExpenses($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getFtpConfigss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addFtpConfigs($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getFtpExportBatchess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addFtpExportBatches($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getFtpExportLogss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addFtpExportLogs($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getFtpImportBatchess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addFtpImportBatches($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getFtpImportLogss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addFtpImportLogs($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getGradeMasters() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addGradeMaster($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getHolidayss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addHolidays($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getIntegrationApiLogss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addIntegrationApiLogs($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getLeaveRequests() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addLeaveRequest($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getLeavess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addLeaves($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMaterialFolderss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMaterialFolders($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMediaFiless() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMediaFiles($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMediaFolderss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMediaFolders($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMtps() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMtp($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMtpDays() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMtpDay($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getMtpLogss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addMtpLogs($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOfferss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOffers($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOnBoardRequests() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOnBoardRequest($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOnBoardRequestAddresses() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOnBoardRequestAddress($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOnBoardRequiredFieldss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOnBoardRequiredFields($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOrderLogs() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOrderLog($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOrderliness() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOrderlines($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOrderss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOrders($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOrgUnits() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOrgUnit($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOtpRequestss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOtpRequests($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletAddresses() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletAddress($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletOrgDatas() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletOrgData($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletOrgNotess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletOrgNotes($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletOutcomess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletOutcomes($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletStocks() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletStock($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletStockOtherSummaries() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletStockOtherSummary($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletStockSummaries() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletStockSummary($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletTagss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletTags($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletTypes() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletType($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutlets($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPolicyMasters() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPolicyMaster($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPolicykeyss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPolicykeys($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPositionss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPositions($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPricebookliness() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPricebooklines($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getPricebookss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addPricebooks($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getProductss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addProducts($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getReminderss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addReminders($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSgpiAccountss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSgpiAccounts($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSgpiMasters() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSgpiMaster($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSgpiTranss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSgpiTrans($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getShiftTypess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addShiftTypes($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getShippingliness() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addShippinglines($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getShippingorders() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addShippingorder($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getStockTransactions() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addStockTransaction($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getStockVouchers() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addStockVoucher($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSurveys() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSurvey($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSurveyCategories() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSurveyCategory($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSurveyQuestions() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSurveyQuestion($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getSurveySubmiteds() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addSurveySubmited($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTaConfigurations() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTaConfiguration($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTagss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTags($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTerritoriess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTerritories($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTerritoryTownss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTerritoryTowns($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTicketRepliess() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTicketReplies($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTicketTypes() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTicketType($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTicketss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTickets($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTourplanss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTourplans($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getTransactionss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addTransactions($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getUserss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addUsers($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getWdbSyncLogs() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addWdbSyncLog($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getWfRequestss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addWfRequests($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getStps() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addStp($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getStpWeeks() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addStpWeek($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getOutletOrgDataKeyss() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addOutletOrgDataKeys($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getNotificationConfigurations() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addNotificationConfiguration($relObj->copy($deepCopy));
                }
            }

            foreach ($this->getLeaveTypes() as $relObj) {
                if ($relObj !== $this) {  // ensure that we don't try to copy a reference to ourselves
                    $copyObj->addLeaveType($relObj->copy($deepCopy));
                }
            }

        } // if ($deepCopy)

        if ($makeNew) {
            $copyObj->setNew(true);
            $copyObj->setCompanyId(NULL); // this is a auto-increment column, so set to default value
        }
    }

    /**
     * Makes a copy of this object that will be inserted as a new row in table when saved.
     * It creates a new object filling in the simple attributes, but skipping any primary
     * keys that are defined for the table.
     *
     * If desired, this method can also make copies of all associated (fkey referrers)
     * objects.
     *
     * @param bool $deepCopy Whether to also copy all rows that refer (by fkey) to the current row.
     * @return \entities\Company Clone of current object.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function copy(bool $deepCopy = false)
    {
        // we use get_class(), because this might be a subclass
        $clazz = get_class($this);
        $copyObj = new $clazz();
        $this->copyInto($copyObj, $deepCopy);

        return $copyObj;
    }

    /**
     * Declares an association between this object and a ChildExpenseMaster object.
     *
     * @param ChildExpenseMaster|null $v
     * @return $this The current object (for fluent API support)
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function setExpenseMasterRelatedByAutoCalculatedTa(ChildExpenseMaster $v = null)
    {
        if ($v === null) {
            $this->setAutoCalculatedTa(NULL);
        } else {
            $this->setAutoCalculatedTa($v->getExpenseId());
        }

        $this->aExpenseMasterRelatedByAutoCalculatedTa = $v;

        // Add binding for other direction of this n:n relationship.
        // If this object has already been added to the ChildExpenseMaster object, it will not be re-added.
        if ($v !== null) {
            $v->addCompanyRelatedByAutoCalculatedTa($this);
        }


        return $this;
    }


    /**
     * Get the associated ChildExpenseMaster object
     *
     * @param ConnectionInterface $con Optional Connection object.
     * @return ChildExpenseMaster|null The associated ChildExpenseMaster object.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getExpenseMasterRelatedByAutoCalculatedTa(?ConnectionInterface $con = null)
    {
        if ($this->aExpenseMasterRelatedByAutoCalculatedTa === null && ($this->auto_calculated_ta != 0)) {
            $this->aExpenseMasterRelatedByAutoCalculatedTa = ChildExpenseMasterQuery::create()->findPk($this->auto_calculated_ta, $con);
            /* The following can be used additionally to
                guarantee the related object contains a reference
                to this object.  This level of coupling may, however, be
                undesirable since it could result in an only partially populated collection
                in the referenced object.
                $this->aExpenseMasterRelatedByAutoCalculatedTa->addCompaniesRelatedByAutoCalculatedTa($this);
             */
        }

        return $this->aExpenseMasterRelatedByAutoCalculatedTa;
    }

    /**
     * Declares an association between this object and a ChildCurrencies object.
     *
     * @param ChildCurrencies|null $v
     * @return $this The current object (for fluent API support)
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function setCurrencies(ChildCurrencies $v = null)
    {
        if ($v === null) {
            $this->setCompanyDefaultCurrency(NULL);
        } else {
            $this->setCompanyDefaultCurrency($v->getCurrencyId());
        }

        $this->aCurrencies = $v;

        // Add binding for other direction of this n:n relationship.
        // If this object has already been added to the ChildCurrencies object, it will not be re-added.
        if ($v !== null) {
            $v->addCompany($this);
        }


        return $this;
    }


    /**
     * Get the associated ChildCurrencies object
     *
     * @param ConnectionInterface $con Optional Connection object.
     * @return ChildCurrencies|null The associated ChildCurrencies object.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getCurrencies(?ConnectionInterface $con = null)
    {
        if ($this->aCurrencies === null && ($this->company_default_currency != 0)) {
            $this->aCurrencies = ChildCurrenciesQuery::create()->findPk($this->company_default_currency, $con);
            /* The following can be used additionally to
                guarantee the related object contains a reference
                to this object.  This level of coupling may, however, be
                undesirable since it could result in an only partially populated collection
                in the referenced object.
                $this->aCurrencies->addCompanies($this);
             */
        }

        return $this->aCurrencies;
    }


    /**
     * Initializes a collection based on the name of a relation.
     * Avoids crafting an 'init[$relationName]s' method name
     * that wouldn't work when StandardEnglishPluralizer is used.
     *
     * @param string $relationName The name of the relation to initialize
     * @return void
     */
    public function initRelation($relationName): void
    {
        if ('Agendatypes' === $relationName) {
            $this->initAgendatypess();
            return;
        }
        if ('Announcements' === $relationName) {
            $this->initAnnouncementss();
            return;
        }
        if ('ApiKeys' === $relationName) {
            $this->initApiKeyss();
            return;
        }
        if ('Attendance' === $relationName) {
            $this->initAttendances();
            return;
        }
        if ('BeatOutlets' === $relationName) {
            $this->initBeatOutletss();
            return;
        }
        if ('Beats' === $relationName) {
            $this->initBeatss();
            return;
        }
        if ('Branch' === $relationName) {
            $this->initBranches();
            return;
        }
        if ('BrandCampiagn' === $relationName) {
            $this->initBrandCampiagns();
            return;
        }
        if ('BrandCampiagnDoctors' === $relationName) {
            $this->initBrandCampiagnDoctorss();
            return;
        }
        if ('BrandCampiagnVisitPlan' === $relationName) {
            $this->initBrandCampiagnVisitPlans();
            return;
        }
        if ('BrandCompetition' === $relationName) {
            $this->initBrandCompetitions();
            return;
        }
        if ('BrandRcpa' === $relationName) {
            $this->initBrandRcpas();
            return;
        }
        if ('Brands' === $relationName) {
            $this->initBrandss();
            return;
        }
        if ('BudgetGroup' === $relationName) {
            $this->initBudgetGroups();
            return;
        }
        if ('Categories' === $relationName) {
            $this->initCategoriess();
            return;
        }
        if ('CheckinoutOutcomes' === $relationName) {
            $this->initCheckinoutOutcomess();
            return;
        }
        if ('Citycategory' === $relationName) {
            $this->initCitycategories();
            return;
        }
        if ('Classification' === $relationName) {
            $this->initClassifications();
            return;
        }
        if ('CompetitionMapping' === $relationName) {
            $this->initCompetitionMappings();
            return;
        }
        if ('Competitor' === $relationName) {
            $this->initCompetitors();
            return;
        }
        if ('Configuration' === $relationName) {
            $this->initConfigurations();
            return;
        }
        if ('CronCommandLogs' === $relationName) {
            $this->initCronCommandLogss();
            return;
        }
        if ('CronCommands' === $relationName) {
            $this->initCronCommandss();
            return;
        }
        if ('Dailycalls' === $relationName) {
            $this->initDailycallss();
            return;
        }
        if ('DailycallsSgpiout' === $relationName) {
            $this->initDailycallsSgpiouts();
            return;
        }
        if ('DataExceptionLogs' === $relationName) {
            $this->initDataExceptionLogss();
            return;
        }
        if ('DataExceptions' === $relationName) {
            $this->initDataExceptionss();
            return;
        }
        if ('Designations' === $relationName) {
            $this->initDesignationss();
            return;
        }
        if ('EdFeedbacks' === $relationName) {
            $this->initEdFeedbackss();
            return;
        }
        if ('EdPlaylist' === $relationName) {
            $this->initEdPlaylists();
            return;
        }
        if ('EdPresentations' === $relationName) {
            $this->initEdPresentationss();
            return;
        }
        if ('EdSession' === $relationName) {
            $this->initEdSessions();
            return;
        }
        if ('EdStats' === $relationName) {
            $this->initEdStatss();
            return;
        }
        if ('Employee' === $relationName) {
            $this->initEmployees();
            return;
        }
        if ('EmployeeIncentive' === $relationName) {
            $this->initEmployeeIncentives();
            return;
        }
        if ('EventTypes' === $relationName) {
            $this->initEventTypess();
            return;
        }
        if ('Events' === $relationName) {
            $this->initEventss();
            return;
        }
        if ('ExpenseList' === $relationName) {
            $this->initExpenseLists();
            return;
        }
        if ('ExpenseMasterRelatedByCompanyId' === $relationName) {
            $this->initExpenseMastersRelatedByCompanyId();
            return;
        }
        if ('ExpensePayments' === $relationName) {
            $this->initExpensePaymentss();
            return;
        }
        if ('Expenses' === $relationName) {
            $this->initExpensess();
            return;
        }
        if ('FtpConfigs' === $relationName) {
            $this->initFtpConfigss();
            return;
        }
        if ('FtpExportBatches' === $relationName) {
            $this->initFtpExportBatchess();
            return;
        }
        if ('FtpExportLogs' === $relationName) {
            $this->initFtpExportLogss();
            return;
        }
        if ('FtpImportBatches' === $relationName) {
            $this->initFtpImportBatchess();
            return;
        }
        if ('FtpImportLogs' === $relationName) {
            $this->initFtpImportLogss();
            return;
        }
        if ('GradeMaster' === $relationName) {
            $this->initGradeMasters();
            return;
        }
        if ('Holidays' === $relationName) {
            $this->initHolidayss();
            return;
        }
        if ('IntegrationApiLogs' === $relationName) {
            $this->initIntegrationApiLogss();
            return;
        }
        if ('LeaveRequest' === $relationName) {
            $this->initLeaveRequests();
            return;
        }
        if ('Leaves' === $relationName) {
            $this->initLeavess();
            return;
        }
        if ('MaterialFolders' === $relationName) {
            $this->initMaterialFolderss();
            return;
        }
        if ('MediaFiles' === $relationName) {
            $this->initMediaFiless();
            return;
        }
        if ('MediaFolders' === $relationName) {
            $this->initMediaFolderss();
            return;
        }
        if ('Mtp' === $relationName) {
            $this->initMtps();
            return;
        }
        if ('MtpDay' === $relationName) {
            $this->initMtpDays();
            return;
        }
        if ('MtpLogs' === $relationName) {
            $this->initMtpLogss();
            return;
        }
        if ('Offers' === $relationName) {
            $this->initOfferss();
            return;
        }
        if ('OnBoardRequest' === $relationName) {
            $this->initOnBoardRequests();
            return;
        }
        if ('OnBoardRequestAddress' === $relationName) {
            $this->initOnBoardRequestAddresses();
            return;
        }
        if ('OnBoardRequiredFields' === $relationName) {
            $this->initOnBoardRequiredFieldss();
            return;
        }
        if ('OrderLog' === $relationName) {
            $this->initOrderLogs();
            return;
        }
        if ('Orderlines' === $relationName) {
            $this->initOrderliness();
            return;
        }
        if ('Orders' === $relationName) {
            $this->initOrderss();
            return;
        }
        if ('OrgUnit' === $relationName) {
            $this->initOrgUnits();
            return;
        }
        if ('OtpRequests' === $relationName) {
            $this->initOtpRequestss();
            return;
        }
        if ('OutletAddress' === $relationName) {
            $this->initOutletAddresses();
            return;
        }
        if ('OutletOrgData' === $relationName) {
            $this->initOutletOrgDatas();
            return;
        }
        if ('OutletOrgNotes' === $relationName) {
            $this->initOutletOrgNotess();
            return;
        }
        if ('OutletOutcomes' === $relationName) {
            $this->initOutletOutcomess();
            return;
        }
        if ('OutletStock' === $relationName) {
            $this->initOutletStocks();
            return;
        }
        if ('OutletStockOtherSummary' === $relationName) {
            $this->initOutletStockOtherSummaries();
            return;
        }
        if ('OutletStockSummary' === $relationName) {
            $this->initOutletStockSummaries();
            return;
        }
        if ('OutletTags' === $relationName) {
            $this->initOutletTagss();
            return;
        }
        if ('OutletType' === $relationName) {
            $this->initOutletTypes();
            return;
        }
        if ('Outlets' === $relationName) {
            $this->initOutletss();
            return;
        }
        if ('PolicyMaster' === $relationName) {
            $this->initPolicyMasters();
            return;
        }
        if ('Policykeys' === $relationName) {
            $this->initPolicykeyss();
            return;
        }
        if ('Positions' === $relationName) {
            $this->initPositionss();
            return;
        }
        if ('Pricebooklines' === $relationName) {
            $this->initPricebookliness();
            return;
        }
        if ('Pricebooks' === $relationName) {
            $this->initPricebookss();
            return;
        }
        if ('Products' === $relationName) {
            $this->initProductss();
            return;
        }
        if ('Reminders' === $relationName) {
            $this->initReminderss();
            return;
        }
        if ('SgpiAccounts' === $relationName) {
            $this->initSgpiAccountss();
            return;
        }
        if ('SgpiMaster' === $relationName) {
            $this->initSgpiMasters();
            return;
        }
        if ('SgpiTrans' === $relationName) {
            $this->initSgpiTranss();
            return;
        }
        if ('ShiftTypes' === $relationName) {
            $this->initShiftTypess();
            return;
        }
        if ('Shippinglines' === $relationName) {
            $this->initShippingliness();
            return;
        }
        if ('Shippingorder' === $relationName) {
            $this->initShippingorders();
            return;
        }
        if ('StockTransaction' === $relationName) {
            $this->initStockTransactions();
            return;
        }
        if ('StockVoucher' === $relationName) {
            $this->initStockVouchers();
            return;
        }
        if ('Survey' === $relationName) {
            $this->initSurveys();
            return;
        }
        if ('SurveyCategory' === $relationName) {
            $this->initSurveyCategories();
            return;
        }
        if ('SurveyQuestion' === $relationName) {
            $this->initSurveyQuestions();
            return;
        }
        if ('SurveySubmited' === $relationName) {
            $this->initSurveySubmiteds();
            return;
        }
        if ('TaConfiguration' === $relationName) {
            $this->initTaConfigurations();
            return;
        }
        if ('Tags' === $relationName) {
            $this->initTagss();
            return;
        }
        if ('Territories' === $relationName) {
            $this->initTerritoriess();
            return;
        }
        if ('TerritoryTowns' === $relationName) {
            $this->initTerritoryTownss();
            return;
        }
        if ('TicketReplies' === $relationName) {
            $this->initTicketRepliess();
            return;
        }
        if ('TicketType' === $relationName) {
            $this->initTicketTypes();
            return;
        }
        if ('Tickets' === $relationName) {
            $this->initTicketss();
            return;
        }
        if ('Tourplans' === $relationName) {
            $this->initTourplanss();
            return;
        }
        if ('Transactions' === $relationName) {
            $this->initTransactionss();
            return;
        }
        if ('Users' === $relationName) {
            $this->initUserss();
            return;
        }
        if ('WdbSyncLog' === $relationName) {
            $this->initWdbSyncLogs();
            return;
        }
        if ('WfRequests' === $relationName) {
            $this->initWfRequestss();
            return;
        }
        if ('Stp' === $relationName) {
            $this->initStps();
            return;
        }
        if ('StpWeek' === $relationName) {
            $this->initStpWeeks();
            return;
        }
        if ('OutletOrgDataKeys' === $relationName) {
            $this->initOutletOrgDataKeyss();
            return;
        }
        if ('NotificationConfiguration' === $relationName) {
            $this->initNotificationConfigurations();
            return;
        }
        if ('LeaveType' === $relationName) {
            $this->initLeaveTypes();
            return;
        }
    }

    /**
     * Clears out the collAgendatypess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addAgendatypess()
     */
    public function clearAgendatypess()
    {
        $this->collAgendatypess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collAgendatypess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialAgendatypess($v = true): void
    {
        $this->collAgendatypessPartial = $v;
    }

    /**
     * Initializes the collAgendatypess collection.
     *
     * By default this just sets the collAgendatypess collection to an empty array (like clearcollAgendatypess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initAgendatypess(bool $overrideExisting = true): void
    {
        if (null !== $this->collAgendatypess && !$overrideExisting) {
            return;
        }

        $collectionClassName = AgendatypesTableMap::getTableMap()->getCollectionClassName();

        $this->collAgendatypess = new $collectionClassName;
        $this->collAgendatypess->setModel('\entities\Agendatypes');
    }

    /**
     * Gets an array of ChildAgendatypes objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildAgendatypes[] List of ChildAgendatypes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAgendatypes> List of ChildAgendatypes objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getAgendatypess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collAgendatypessPartial && !$this->isNew();
        if (null === $this->collAgendatypess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collAgendatypess) {
                    $this->initAgendatypess();
                } else {
                    $collectionClassName = AgendatypesTableMap::getTableMap()->getCollectionClassName();

                    $collAgendatypess = new $collectionClassName;
                    $collAgendatypess->setModel('\entities\Agendatypes');

                    return $collAgendatypess;
                }
            } else {
                $collAgendatypess = ChildAgendatypesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collAgendatypessPartial && count($collAgendatypess)) {
                        $this->initAgendatypess(false);

                        foreach ($collAgendatypess as $obj) {
                            if (false == $this->collAgendatypess->contains($obj)) {
                                $this->collAgendatypess->append($obj);
                            }
                        }

                        $this->collAgendatypessPartial = true;
                    }

                    return $collAgendatypess;
                }

                if ($partial && $this->collAgendatypess) {
                    foreach ($this->collAgendatypess as $obj) {
                        if ($obj->isNew()) {
                            $collAgendatypess[] = $obj;
                        }
                    }
                }

                $this->collAgendatypess = $collAgendatypess;
                $this->collAgendatypessPartial = false;
            }
        }

        return $this->collAgendatypess;
    }

    /**
     * Sets a collection of ChildAgendatypes objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $agendatypess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setAgendatypess(Collection $agendatypess, ?ConnectionInterface $con = null)
    {
        /** @var ChildAgendatypes[] $agendatypessToDelete */
        $agendatypessToDelete = $this->getAgendatypess(new Criteria(), $con)->diff($agendatypess);


        $this->agendatypessScheduledForDeletion = $agendatypessToDelete;

        foreach ($agendatypessToDelete as $agendatypesRemoved) {
            $agendatypesRemoved->setCompany(null);
        }

        $this->collAgendatypess = null;
        foreach ($agendatypess as $agendatypes) {
            $this->addAgendatypes($agendatypes);
        }

        $this->collAgendatypess = $agendatypess;
        $this->collAgendatypessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Agendatypes objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Agendatypes objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countAgendatypess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collAgendatypessPartial && !$this->isNew();
        if (null === $this->collAgendatypess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collAgendatypess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getAgendatypess());
            }

            $query = ChildAgendatypesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collAgendatypess);
    }

    /**
     * Method called to associate a ChildAgendatypes object to this object
     * through the ChildAgendatypes foreign key attribute.
     *
     * @param ChildAgendatypes $l ChildAgendatypes
     * @return $this The current object (for fluent API support)
     */
    public function addAgendatypes(ChildAgendatypes $l)
    {
        if ($this->collAgendatypess === null) {
            $this->initAgendatypess();
            $this->collAgendatypessPartial = true;
        }

        if (!$this->collAgendatypess->contains($l)) {
            $this->doAddAgendatypes($l);

            if ($this->agendatypessScheduledForDeletion and $this->agendatypessScheduledForDeletion->contains($l)) {
                $this->agendatypessScheduledForDeletion->remove($this->agendatypessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildAgendatypes $agendatypes The ChildAgendatypes object to add.
     */
    protected function doAddAgendatypes(ChildAgendatypes $agendatypes): void
    {
        $this->collAgendatypess[]= $agendatypes;
        $agendatypes->setCompany($this);
    }

    /**
     * @param ChildAgendatypes $agendatypes The ChildAgendatypes object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeAgendatypes(ChildAgendatypes $agendatypes)
    {
        if ($this->getAgendatypess()->contains($agendatypes)) {
            $pos = $this->collAgendatypess->search($agendatypes);
            $this->collAgendatypess->remove($pos);
            if (null === $this->agendatypessScheduledForDeletion) {
                $this->agendatypessScheduledForDeletion = clone $this->collAgendatypess;
                $this->agendatypessScheduledForDeletion->clear();
            }
            $this->agendatypessScheduledForDeletion[]= clone $agendatypes;
            $agendatypes->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Agendatypess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildAgendatypes[] List of ChildAgendatypes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAgendatypes}> List of ChildAgendatypes objects
     */
    public function getAgendatypessJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildAgendatypesQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getAgendatypess($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Agendatypess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildAgendatypes[] List of ChildAgendatypes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAgendatypes}> List of ChildAgendatypes objects
     */
    public function getAgendatypessJoinMediaFiles(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildAgendatypesQuery::create(null, $criteria);
        $query->joinWith('MediaFiles', $joinBehavior);

        return $this->getAgendatypess($query, $con);
    }

    /**
     * Clears out the collAnnouncementss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addAnnouncementss()
     */
    public function clearAnnouncementss()
    {
        $this->collAnnouncementss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collAnnouncementss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialAnnouncementss($v = true): void
    {
        $this->collAnnouncementssPartial = $v;
    }

    /**
     * Initializes the collAnnouncementss collection.
     *
     * By default this just sets the collAnnouncementss collection to an empty array (like clearcollAnnouncementss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initAnnouncementss(bool $overrideExisting = true): void
    {
        if (null !== $this->collAnnouncementss && !$overrideExisting) {
            return;
        }

        $collectionClassName = AnnouncementsTableMap::getTableMap()->getCollectionClassName();

        $this->collAnnouncementss = new $collectionClassName;
        $this->collAnnouncementss->setModel('\entities\Announcements');
    }

    /**
     * Gets an array of ChildAnnouncements objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildAnnouncements[] List of ChildAnnouncements objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAnnouncements> List of ChildAnnouncements objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getAnnouncementss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collAnnouncementssPartial && !$this->isNew();
        if (null === $this->collAnnouncementss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collAnnouncementss) {
                    $this->initAnnouncementss();
                } else {
                    $collectionClassName = AnnouncementsTableMap::getTableMap()->getCollectionClassName();

                    $collAnnouncementss = new $collectionClassName;
                    $collAnnouncementss->setModel('\entities\Announcements');

                    return $collAnnouncementss;
                }
            } else {
                $collAnnouncementss = ChildAnnouncementsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collAnnouncementssPartial && count($collAnnouncementss)) {
                        $this->initAnnouncementss(false);

                        foreach ($collAnnouncementss as $obj) {
                            if (false == $this->collAnnouncementss->contains($obj)) {
                                $this->collAnnouncementss->append($obj);
                            }
                        }

                        $this->collAnnouncementssPartial = true;
                    }

                    return $collAnnouncementss;
                }

                if ($partial && $this->collAnnouncementss) {
                    foreach ($this->collAnnouncementss as $obj) {
                        if ($obj->isNew()) {
                            $collAnnouncementss[] = $obj;
                        }
                    }
                }

                $this->collAnnouncementss = $collAnnouncementss;
                $this->collAnnouncementssPartial = false;
            }
        }

        return $this->collAnnouncementss;
    }

    /**
     * Sets a collection of ChildAnnouncements objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $announcementss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setAnnouncementss(Collection $announcementss, ?ConnectionInterface $con = null)
    {
        /** @var ChildAnnouncements[] $announcementssToDelete */
        $announcementssToDelete = $this->getAnnouncementss(new Criteria(), $con)->diff($announcementss);


        $this->announcementssScheduledForDeletion = $announcementssToDelete;

        foreach ($announcementssToDelete as $announcementsRemoved) {
            $announcementsRemoved->setCompany(null);
        }

        $this->collAnnouncementss = null;
        foreach ($announcementss as $announcements) {
            $this->addAnnouncements($announcements);
        }

        $this->collAnnouncementss = $announcementss;
        $this->collAnnouncementssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Announcements objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Announcements objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countAnnouncementss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collAnnouncementssPartial && !$this->isNew();
        if (null === $this->collAnnouncementss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collAnnouncementss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getAnnouncementss());
            }

            $query = ChildAnnouncementsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collAnnouncementss);
    }

    /**
     * Method called to associate a ChildAnnouncements object to this object
     * through the ChildAnnouncements foreign key attribute.
     *
     * @param ChildAnnouncements $l ChildAnnouncements
     * @return $this The current object (for fluent API support)
     */
    public function addAnnouncements(ChildAnnouncements $l)
    {
        if ($this->collAnnouncementss === null) {
            $this->initAnnouncementss();
            $this->collAnnouncementssPartial = true;
        }

        if (!$this->collAnnouncementss->contains($l)) {
            $this->doAddAnnouncements($l);

            if ($this->announcementssScheduledForDeletion and $this->announcementssScheduledForDeletion->contains($l)) {
                $this->announcementssScheduledForDeletion->remove($this->announcementssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildAnnouncements $announcements The ChildAnnouncements object to add.
     */
    protected function doAddAnnouncements(ChildAnnouncements $announcements): void
    {
        $this->collAnnouncementss[]= $announcements;
        $announcements->setCompany($this);
    }

    /**
     * @param ChildAnnouncements $announcements The ChildAnnouncements object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeAnnouncements(ChildAnnouncements $announcements)
    {
        if ($this->getAnnouncementss()->contains($announcements)) {
            $pos = $this->collAnnouncementss->search($announcements);
            $this->collAnnouncementss->remove($pos);
            if (null === $this->announcementssScheduledForDeletion) {
                $this->announcementssScheduledForDeletion = clone $this->collAnnouncementss;
                $this->announcementssScheduledForDeletion->clear();
            }
            $this->announcementssScheduledForDeletion[]= clone $announcements;
            $announcements->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collApiKeyss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addApiKeyss()
     */
    public function clearApiKeyss()
    {
        $this->collApiKeyss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collApiKeyss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialApiKeyss($v = true): void
    {
        $this->collApiKeyssPartial = $v;
    }

    /**
     * Initializes the collApiKeyss collection.
     *
     * By default this just sets the collApiKeyss collection to an empty array (like clearcollApiKeyss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initApiKeyss(bool $overrideExisting = true): void
    {
        if (null !== $this->collApiKeyss && !$overrideExisting) {
            return;
        }

        $collectionClassName = ApiKeysTableMap::getTableMap()->getCollectionClassName();

        $this->collApiKeyss = new $collectionClassName;
        $this->collApiKeyss->setModel('\entities\ApiKeys');
    }

    /**
     * Gets an array of ChildApiKeys objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildApiKeys[] List of ChildApiKeys objects
     * @phpstan-return ObjectCollection&\Traversable<ChildApiKeys> List of ChildApiKeys objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getApiKeyss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collApiKeyssPartial && !$this->isNew();
        if (null === $this->collApiKeyss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collApiKeyss) {
                    $this->initApiKeyss();
                } else {
                    $collectionClassName = ApiKeysTableMap::getTableMap()->getCollectionClassName();

                    $collApiKeyss = new $collectionClassName;
                    $collApiKeyss->setModel('\entities\ApiKeys');

                    return $collApiKeyss;
                }
            } else {
                $collApiKeyss = ChildApiKeysQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collApiKeyssPartial && count($collApiKeyss)) {
                        $this->initApiKeyss(false);

                        foreach ($collApiKeyss as $obj) {
                            if (false == $this->collApiKeyss->contains($obj)) {
                                $this->collApiKeyss->append($obj);
                            }
                        }

                        $this->collApiKeyssPartial = true;
                    }

                    return $collApiKeyss;
                }

                if ($partial && $this->collApiKeyss) {
                    foreach ($this->collApiKeyss as $obj) {
                        if ($obj->isNew()) {
                            $collApiKeyss[] = $obj;
                        }
                    }
                }

                $this->collApiKeyss = $collApiKeyss;
                $this->collApiKeyssPartial = false;
            }
        }

        return $this->collApiKeyss;
    }

    /**
     * Sets a collection of ChildApiKeys objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $apiKeyss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setApiKeyss(Collection $apiKeyss, ?ConnectionInterface $con = null)
    {
        /** @var ChildApiKeys[] $apiKeyssToDelete */
        $apiKeyssToDelete = $this->getApiKeyss(new Criteria(), $con)->diff($apiKeyss);


        $this->apiKeyssScheduledForDeletion = $apiKeyssToDelete;

        foreach ($apiKeyssToDelete as $apiKeysRemoved) {
            $apiKeysRemoved->setCompany(null);
        }

        $this->collApiKeyss = null;
        foreach ($apiKeyss as $apiKeys) {
            $this->addApiKeys($apiKeys);
        }

        $this->collApiKeyss = $apiKeyss;
        $this->collApiKeyssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related ApiKeys objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related ApiKeys objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countApiKeyss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collApiKeyssPartial && !$this->isNew();
        if (null === $this->collApiKeyss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collApiKeyss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getApiKeyss());
            }

            $query = ChildApiKeysQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collApiKeyss);
    }

    /**
     * Method called to associate a ChildApiKeys object to this object
     * through the ChildApiKeys foreign key attribute.
     *
     * @param ChildApiKeys $l ChildApiKeys
     * @return $this The current object (for fluent API support)
     */
    public function addApiKeys(ChildApiKeys $l)
    {
        if ($this->collApiKeyss === null) {
            $this->initApiKeyss();
            $this->collApiKeyssPartial = true;
        }

        if (!$this->collApiKeyss->contains($l)) {
            $this->doAddApiKeys($l);

            if ($this->apiKeyssScheduledForDeletion and $this->apiKeyssScheduledForDeletion->contains($l)) {
                $this->apiKeyssScheduledForDeletion->remove($this->apiKeyssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildApiKeys $apiKeys The ChildApiKeys object to add.
     */
    protected function doAddApiKeys(ChildApiKeys $apiKeys): void
    {
        $this->collApiKeyss[]= $apiKeys;
        $apiKeys->setCompany($this);
    }

    /**
     * @param ChildApiKeys $apiKeys The ChildApiKeys object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeApiKeys(ChildApiKeys $apiKeys)
    {
        if ($this->getApiKeyss()->contains($apiKeys)) {
            $pos = $this->collApiKeyss->search($apiKeys);
            $this->collApiKeyss->remove($pos);
            if (null === $this->apiKeyssScheduledForDeletion) {
                $this->apiKeyssScheduledForDeletion = clone $this->collApiKeyss;
                $this->apiKeyssScheduledForDeletion->clear();
            }
            $this->apiKeyssScheduledForDeletion[]= $apiKeys;
            $apiKeys->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collAttendances collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addAttendances()
     */
    public function clearAttendances()
    {
        $this->collAttendances = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collAttendances collection loaded partially.
     *
     * @return void
     */
    public function resetPartialAttendances($v = true): void
    {
        $this->collAttendancesPartial = $v;
    }

    /**
     * Initializes the collAttendances collection.
     *
     * By default this just sets the collAttendances collection to an empty array (like clearcollAttendances());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initAttendances(bool $overrideExisting = true): void
    {
        if (null !== $this->collAttendances && !$overrideExisting) {
            return;
        }

        $collectionClassName = AttendanceTableMap::getTableMap()->getCollectionClassName();

        $this->collAttendances = new $collectionClassName;
        $this->collAttendances->setModel('\entities\Attendance');
    }

    /**
     * Gets an array of ChildAttendance objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildAttendance[] List of ChildAttendance objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAttendance> List of ChildAttendance objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getAttendances(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collAttendancesPartial && !$this->isNew();
        if (null === $this->collAttendances || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collAttendances) {
                    $this->initAttendances();
                } else {
                    $collectionClassName = AttendanceTableMap::getTableMap()->getCollectionClassName();

                    $collAttendances = new $collectionClassName;
                    $collAttendances->setModel('\entities\Attendance');

                    return $collAttendances;
                }
            } else {
                $collAttendances = ChildAttendanceQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collAttendancesPartial && count($collAttendances)) {
                        $this->initAttendances(false);

                        foreach ($collAttendances as $obj) {
                            if (false == $this->collAttendances->contains($obj)) {
                                $this->collAttendances->append($obj);
                            }
                        }

                        $this->collAttendancesPartial = true;
                    }

                    return $collAttendances;
                }

                if ($partial && $this->collAttendances) {
                    foreach ($this->collAttendances as $obj) {
                        if ($obj->isNew()) {
                            $collAttendances[] = $obj;
                        }
                    }
                }

                $this->collAttendances = $collAttendances;
                $this->collAttendancesPartial = false;
            }
        }

        return $this->collAttendances;
    }

    /**
     * Sets a collection of ChildAttendance objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $attendances A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setAttendances(Collection $attendances, ?ConnectionInterface $con = null)
    {
        /** @var ChildAttendance[] $attendancesToDelete */
        $attendancesToDelete = $this->getAttendances(new Criteria(), $con)->diff($attendances);


        $this->attendancesScheduledForDeletion = $attendancesToDelete;

        foreach ($attendancesToDelete as $attendanceRemoved) {
            $attendanceRemoved->setCompany(null);
        }

        $this->collAttendances = null;
        foreach ($attendances as $attendance) {
            $this->addAttendance($attendance);
        }

        $this->collAttendances = $attendances;
        $this->collAttendancesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Attendance objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Attendance objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countAttendances(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collAttendancesPartial && !$this->isNew();
        if (null === $this->collAttendances || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collAttendances) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getAttendances());
            }

            $query = ChildAttendanceQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collAttendances);
    }

    /**
     * Method called to associate a ChildAttendance object to this object
     * through the ChildAttendance foreign key attribute.
     *
     * @param ChildAttendance $l ChildAttendance
     * @return $this The current object (for fluent API support)
     */
    public function addAttendance(ChildAttendance $l)
    {
        if ($this->collAttendances === null) {
            $this->initAttendances();
            $this->collAttendancesPartial = true;
        }

        if (!$this->collAttendances->contains($l)) {
            $this->doAddAttendance($l);

            if ($this->attendancesScheduledForDeletion and $this->attendancesScheduledForDeletion->contains($l)) {
                $this->attendancesScheduledForDeletion->remove($this->attendancesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildAttendance $attendance The ChildAttendance object to add.
     */
    protected function doAddAttendance(ChildAttendance $attendance): void
    {
        $this->collAttendances[]= $attendance;
        $attendance->setCompany($this);
    }

    /**
     * @param ChildAttendance $attendance The ChildAttendance object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeAttendance(ChildAttendance $attendance)
    {
        if ($this->getAttendances()->contains($attendance)) {
            $pos = $this->collAttendances->search($attendance);
            $this->collAttendances->remove($pos);
            if (null === $this->attendancesScheduledForDeletion) {
                $this->attendancesScheduledForDeletion = clone $this->collAttendances;
                $this->attendancesScheduledForDeletion->clear();
            }
            $this->attendancesScheduledForDeletion[]= clone $attendance;
            $attendance->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Attendances from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildAttendance[] List of ChildAttendance objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAttendance}> List of ChildAttendance objects
     */
    public function getAttendancesJoinGeoTownsRelatedByEndItownid(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildAttendanceQuery::create(null, $criteria);
        $query->joinWith('GeoTownsRelatedByEndItownid', $joinBehavior);

        return $this->getAttendances($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Attendances from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildAttendance[] List of ChildAttendance objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAttendance}> List of ChildAttendance objects
     */
    public function getAttendancesJoinExpenses(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildAttendanceQuery::create(null, $criteria);
        $query->joinWith('Expenses', $joinBehavior);

        return $this->getAttendances($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Attendances from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildAttendance[] List of ChildAttendance objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAttendance}> List of ChildAttendance objects
     */
    public function getAttendancesJoinGeoTownsRelatedByStartItownid(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildAttendanceQuery::create(null, $criteria);
        $query->joinWith('GeoTownsRelatedByStartItownid', $joinBehavior);

        return $this->getAttendances($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Attendances from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildAttendance[] List of ChildAttendance objects
     * @phpstan-return ObjectCollection&\Traversable<ChildAttendance}> List of ChildAttendance objects
     */
    public function getAttendancesJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildAttendanceQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getAttendances($query, $con);
    }

    /**
     * Clears out the collBeatOutletss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBeatOutletss()
     */
    public function clearBeatOutletss()
    {
        $this->collBeatOutletss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBeatOutletss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBeatOutletss($v = true): void
    {
        $this->collBeatOutletssPartial = $v;
    }

    /**
     * Initializes the collBeatOutletss collection.
     *
     * By default this just sets the collBeatOutletss collection to an empty array (like clearcollBeatOutletss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBeatOutletss(bool $overrideExisting = true): void
    {
        if (null !== $this->collBeatOutletss && !$overrideExisting) {
            return;
        }

        $collectionClassName = BeatOutletsTableMap::getTableMap()->getCollectionClassName();

        $this->collBeatOutletss = new $collectionClassName;
        $this->collBeatOutletss->setModel('\entities\BeatOutlets');
    }

    /**
     * Gets an array of ChildBeatOutlets objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBeatOutlets[] List of ChildBeatOutlets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBeatOutlets> List of ChildBeatOutlets objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBeatOutletss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBeatOutletssPartial && !$this->isNew();
        if (null === $this->collBeatOutletss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBeatOutletss) {
                    $this->initBeatOutletss();
                } else {
                    $collectionClassName = BeatOutletsTableMap::getTableMap()->getCollectionClassName();

                    $collBeatOutletss = new $collectionClassName;
                    $collBeatOutletss->setModel('\entities\BeatOutlets');

                    return $collBeatOutletss;
                }
            } else {
                $collBeatOutletss = ChildBeatOutletsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBeatOutletssPartial && count($collBeatOutletss)) {
                        $this->initBeatOutletss(false);

                        foreach ($collBeatOutletss as $obj) {
                            if (false == $this->collBeatOutletss->contains($obj)) {
                                $this->collBeatOutletss->append($obj);
                            }
                        }

                        $this->collBeatOutletssPartial = true;
                    }

                    return $collBeatOutletss;
                }

                if ($partial && $this->collBeatOutletss) {
                    foreach ($this->collBeatOutletss as $obj) {
                        if ($obj->isNew()) {
                            $collBeatOutletss[] = $obj;
                        }
                    }
                }

                $this->collBeatOutletss = $collBeatOutletss;
                $this->collBeatOutletssPartial = false;
            }
        }

        return $this->collBeatOutletss;
    }

    /**
     * Sets a collection of ChildBeatOutlets objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $beatOutletss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBeatOutletss(Collection $beatOutletss, ?ConnectionInterface $con = null)
    {
        /** @var ChildBeatOutlets[] $beatOutletssToDelete */
        $beatOutletssToDelete = $this->getBeatOutletss(new Criteria(), $con)->diff($beatOutletss);


        $this->beatOutletssScheduledForDeletion = $beatOutletssToDelete;

        foreach ($beatOutletssToDelete as $beatOutletsRemoved) {
            $beatOutletsRemoved->setCompany(null);
        }

        $this->collBeatOutletss = null;
        foreach ($beatOutletss as $beatOutlets) {
            $this->addBeatOutlets($beatOutlets);
        }

        $this->collBeatOutletss = $beatOutletss;
        $this->collBeatOutletssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related BeatOutlets objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related BeatOutlets objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBeatOutletss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBeatOutletssPartial && !$this->isNew();
        if (null === $this->collBeatOutletss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBeatOutletss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBeatOutletss());
            }

            $query = ChildBeatOutletsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBeatOutletss);
    }

    /**
     * Method called to associate a ChildBeatOutlets object to this object
     * through the ChildBeatOutlets foreign key attribute.
     *
     * @param ChildBeatOutlets $l ChildBeatOutlets
     * @return $this The current object (for fluent API support)
     */
    public function addBeatOutlets(ChildBeatOutlets $l)
    {
        if ($this->collBeatOutletss === null) {
            $this->initBeatOutletss();
            $this->collBeatOutletssPartial = true;
        }

        if (!$this->collBeatOutletss->contains($l)) {
            $this->doAddBeatOutlets($l);

            if ($this->beatOutletssScheduledForDeletion and $this->beatOutletssScheduledForDeletion->contains($l)) {
                $this->beatOutletssScheduledForDeletion->remove($this->beatOutletssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBeatOutlets $beatOutlets The ChildBeatOutlets object to add.
     */
    protected function doAddBeatOutlets(ChildBeatOutlets $beatOutlets): void
    {
        $this->collBeatOutletss[]= $beatOutlets;
        $beatOutlets->setCompany($this);
    }

    /**
     * @param ChildBeatOutlets $beatOutlets The ChildBeatOutlets object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBeatOutlets(ChildBeatOutlets $beatOutlets)
    {
        if ($this->getBeatOutletss()->contains($beatOutlets)) {
            $pos = $this->collBeatOutletss->search($beatOutlets);
            $this->collBeatOutletss->remove($pos);
            if (null === $this->beatOutletssScheduledForDeletion) {
                $this->beatOutletssScheduledForDeletion = clone $this->collBeatOutletss;
                $this->beatOutletssScheduledForDeletion->clear();
            }
            $this->beatOutletssScheduledForDeletion[]= clone $beatOutlets;
            $beatOutlets->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BeatOutletss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBeatOutlets[] List of ChildBeatOutlets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBeatOutlets}> List of ChildBeatOutlets objects
     */
    public function getBeatOutletssJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBeatOutletsQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getBeatOutletss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BeatOutletss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBeatOutlets[] List of ChildBeatOutlets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBeatOutlets}> List of ChildBeatOutlets objects
     */
    public function getBeatOutletssJoinBeats(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBeatOutletsQuery::create(null, $criteria);
        $query->joinWith('Beats', $joinBehavior);

        return $this->getBeatOutletss($query, $con);
    }

    /**
     * Clears out the collBeatss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBeatss()
     */
    public function clearBeatss()
    {
        $this->collBeatss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBeatss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBeatss($v = true): void
    {
        $this->collBeatssPartial = $v;
    }

    /**
     * Initializes the collBeatss collection.
     *
     * By default this just sets the collBeatss collection to an empty array (like clearcollBeatss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBeatss(bool $overrideExisting = true): void
    {
        if (null !== $this->collBeatss && !$overrideExisting) {
            return;
        }

        $collectionClassName = BeatsTableMap::getTableMap()->getCollectionClassName();

        $this->collBeatss = new $collectionClassName;
        $this->collBeatss->setModel('\entities\Beats');
    }

    /**
     * Gets an array of ChildBeats objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBeats[] List of ChildBeats objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBeats> List of ChildBeats objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBeatss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBeatssPartial && !$this->isNew();
        if (null === $this->collBeatss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBeatss) {
                    $this->initBeatss();
                } else {
                    $collectionClassName = BeatsTableMap::getTableMap()->getCollectionClassName();

                    $collBeatss = new $collectionClassName;
                    $collBeatss->setModel('\entities\Beats');

                    return $collBeatss;
                }
            } else {
                $collBeatss = ChildBeatsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBeatssPartial && count($collBeatss)) {
                        $this->initBeatss(false);

                        foreach ($collBeatss as $obj) {
                            if (false == $this->collBeatss->contains($obj)) {
                                $this->collBeatss->append($obj);
                            }
                        }

                        $this->collBeatssPartial = true;
                    }

                    return $collBeatss;
                }

                if ($partial && $this->collBeatss) {
                    foreach ($this->collBeatss as $obj) {
                        if ($obj->isNew()) {
                            $collBeatss[] = $obj;
                        }
                    }
                }

                $this->collBeatss = $collBeatss;
                $this->collBeatssPartial = false;
            }
        }

        return $this->collBeatss;
    }

    /**
     * Sets a collection of ChildBeats objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $beatss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBeatss(Collection $beatss, ?ConnectionInterface $con = null)
    {
        /** @var ChildBeats[] $beatssToDelete */
        $beatssToDelete = $this->getBeatss(new Criteria(), $con)->diff($beatss);


        $this->beatssScheduledForDeletion = $beatssToDelete;

        foreach ($beatssToDelete as $beatsRemoved) {
            $beatsRemoved->setCompany(null);
        }

        $this->collBeatss = null;
        foreach ($beatss as $beats) {
            $this->addBeats($beats);
        }

        $this->collBeatss = $beatss;
        $this->collBeatssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Beats objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Beats objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBeatss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBeatssPartial && !$this->isNew();
        if (null === $this->collBeatss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBeatss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBeatss());
            }

            $query = ChildBeatsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBeatss);
    }

    /**
     * Method called to associate a ChildBeats object to this object
     * through the ChildBeats foreign key attribute.
     *
     * @param ChildBeats $l ChildBeats
     * @return $this The current object (for fluent API support)
     */
    public function addBeats(ChildBeats $l)
    {
        if ($this->collBeatss === null) {
            $this->initBeatss();
            $this->collBeatssPartial = true;
        }

        if (!$this->collBeatss->contains($l)) {
            $this->doAddBeats($l);

            if ($this->beatssScheduledForDeletion and $this->beatssScheduledForDeletion->contains($l)) {
                $this->beatssScheduledForDeletion->remove($this->beatssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBeats $beats The ChildBeats object to add.
     */
    protected function doAddBeats(ChildBeats $beats): void
    {
        $this->collBeatss[]= $beats;
        $beats->setCompany($this);
    }

    /**
     * @param ChildBeats $beats The ChildBeats object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBeats(ChildBeats $beats)
    {
        if ($this->getBeatss()->contains($beats)) {
            $pos = $this->collBeatss->search($beats);
            $this->collBeatss->remove($pos);
            if (null === $this->beatssScheduledForDeletion) {
                $this->beatssScheduledForDeletion = clone $this->collBeatss;
                $this->beatssScheduledForDeletion->clear();
            }
            $this->beatssScheduledForDeletion[]= clone $beats;
            $beats->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Beatss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBeats[] List of ChildBeats objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBeats}> List of ChildBeats objects
     */
    public function getBeatssJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBeatsQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getBeatss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Beatss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBeats[] List of ChildBeats objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBeats}> List of ChildBeats objects
     */
    public function getBeatssJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBeatsQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getBeatss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Beatss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBeats[] List of ChildBeats objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBeats}> List of ChildBeats objects
     */
    public function getBeatssJoinTerritories(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBeatsQuery::create(null, $criteria);
        $query->joinWith('Territories', $joinBehavior);

        return $this->getBeatss($query, $con);
    }

    /**
     * Clears out the collBranches collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBranches()
     */
    public function clearBranches()
    {
        $this->collBranches = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBranches collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBranches($v = true): void
    {
        $this->collBranchesPartial = $v;
    }

    /**
     * Initializes the collBranches collection.
     *
     * By default this just sets the collBranches collection to an empty array (like clearcollBranches());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBranches(bool $overrideExisting = true): void
    {
        if (null !== $this->collBranches && !$overrideExisting) {
            return;
        }

        $collectionClassName = BranchTableMap::getTableMap()->getCollectionClassName();

        $this->collBranches = new $collectionClassName;
        $this->collBranches->setModel('\entities\Branch');
    }

    /**
     * Gets an array of ChildBranch objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBranch[] List of ChildBranch objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBranch> List of ChildBranch objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBranches(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBranchesPartial && !$this->isNew();
        if (null === $this->collBranches || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBranches) {
                    $this->initBranches();
                } else {
                    $collectionClassName = BranchTableMap::getTableMap()->getCollectionClassName();

                    $collBranches = new $collectionClassName;
                    $collBranches->setModel('\entities\Branch');

                    return $collBranches;
                }
            } else {
                $collBranches = ChildBranchQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBranchesPartial && count($collBranches)) {
                        $this->initBranches(false);

                        foreach ($collBranches as $obj) {
                            if (false == $this->collBranches->contains($obj)) {
                                $this->collBranches->append($obj);
                            }
                        }

                        $this->collBranchesPartial = true;
                    }

                    return $collBranches;
                }

                if ($partial && $this->collBranches) {
                    foreach ($this->collBranches as $obj) {
                        if ($obj->isNew()) {
                            $collBranches[] = $obj;
                        }
                    }
                }

                $this->collBranches = $collBranches;
                $this->collBranchesPartial = false;
            }
        }

        return $this->collBranches;
    }

    /**
     * Sets a collection of ChildBranch objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $branches A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBranches(Collection $branches, ?ConnectionInterface $con = null)
    {
        /** @var ChildBranch[] $branchesToDelete */
        $branchesToDelete = $this->getBranches(new Criteria(), $con)->diff($branches);


        $this->branchesScheduledForDeletion = $branchesToDelete;

        foreach ($branchesToDelete as $branchRemoved) {
            $branchRemoved->setCompany(null);
        }

        $this->collBranches = null;
        foreach ($branches as $branch) {
            $this->addBranch($branch);
        }

        $this->collBranches = $branches;
        $this->collBranchesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Branch objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Branch objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBranches(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBranchesPartial && !$this->isNew();
        if (null === $this->collBranches || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBranches) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBranches());
            }

            $query = ChildBranchQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBranches);
    }

    /**
     * Method called to associate a ChildBranch object to this object
     * through the ChildBranch foreign key attribute.
     *
     * @param ChildBranch $l ChildBranch
     * @return $this The current object (for fluent API support)
     */
    public function addBranch(ChildBranch $l)
    {
        if ($this->collBranches === null) {
            $this->initBranches();
            $this->collBranchesPartial = true;
        }

        if (!$this->collBranches->contains($l)) {
            $this->doAddBranch($l);

            if ($this->branchesScheduledForDeletion and $this->branchesScheduledForDeletion->contains($l)) {
                $this->branchesScheduledForDeletion->remove($this->branchesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBranch $branch The ChildBranch object to add.
     */
    protected function doAddBranch(ChildBranch $branch): void
    {
        $this->collBranches[]= $branch;
        $branch->setCompany($this);
    }

    /**
     * @param ChildBranch $branch The ChildBranch object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBranch(ChildBranch $branch)
    {
        if ($this->getBranches()->contains($branch)) {
            $pos = $this->collBranches->search($branch);
            $this->collBranches->remove($pos);
            if (null === $this->branchesScheduledForDeletion) {
                $this->branchesScheduledForDeletion = clone $this->collBranches;
                $this->branchesScheduledForDeletion->clear();
            }
            $this->branchesScheduledForDeletion[]= clone $branch;
            $branch->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Branches from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBranch[] List of ChildBranch objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBranch}> List of ChildBranch objects
     */
    public function getBranchesJoinGeoState(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBranchQuery::create(null, $criteria);
        $query->joinWith('GeoState', $joinBehavior);

        return $this->getBranches($query, $con);
    }

    /**
     * Clears out the collBrandCampiagns collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBrandCampiagns()
     */
    public function clearBrandCampiagns()
    {
        $this->collBrandCampiagns = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBrandCampiagns collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBrandCampiagns($v = true): void
    {
        $this->collBrandCampiagnsPartial = $v;
    }

    /**
     * Initializes the collBrandCampiagns collection.
     *
     * By default this just sets the collBrandCampiagns collection to an empty array (like clearcollBrandCampiagns());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBrandCampiagns(bool $overrideExisting = true): void
    {
        if (null !== $this->collBrandCampiagns && !$overrideExisting) {
            return;
        }

        $collectionClassName = BrandCampiagnTableMap::getTableMap()->getCollectionClassName();

        $this->collBrandCampiagns = new $collectionClassName;
        $this->collBrandCampiagns->setModel('\entities\BrandCampiagn');
    }

    /**
     * Gets an array of ChildBrandCampiagn objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBrandCampiagn[] List of ChildBrandCampiagn objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagn> List of ChildBrandCampiagn objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBrandCampiagns(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBrandCampiagnsPartial && !$this->isNew();
        if (null === $this->collBrandCampiagns || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBrandCampiagns) {
                    $this->initBrandCampiagns();
                } else {
                    $collectionClassName = BrandCampiagnTableMap::getTableMap()->getCollectionClassName();

                    $collBrandCampiagns = new $collectionClassName;
                    $collBrandCampiagns->setModel('\entities\BrandCampiagn');

                    return $collBrandCampiagns;
                }
            } else {
                $collBrandCampiagns = ChildBrandCampiagnQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBrandCampiagnsPartial && count($collBrandCampiagns)) {
                        $this->initBrandCampiagns(false);

                        foreach ($collBrandCampiagns as $obj) {
                            if (false == $this->collBrandCampiagns->contains($obj)) {
                                $this->collBrandCampiagns->append($obj);
                            }
                        }

                        $this->collBrandCampiagnsPartial = true;
                    }

                    return $collBrandCampiagns;
                }

                if ($partial && $this->collBrandCampiagns) {
                    foreach ($this->collBrandCampiagns as $obj) {
                        if ($obj->isNew()) {
                            $collBrandCampiagns[] = $obj;
                        }
                    }
                }

                $this->collBrandCampiagns = $collBrandCampiagns;
                $this->collBrandCampiagnsPartial = false;
            }
        }

        return $this->collBrandCampiagns;
    }

    /**
     * Sets a collection of ChildBrandCampiagn objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $brandCampiagns A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBrandCampiagns(Collection $brandCampiagns, ?ConnectionInterface $con = null)
    {
        /** @var ChildBrandCampiagn[] $brandCampiagnsToDelete */
        $brandCampiagnsToDelete = $this->getBrandCampiagns(new Criteria(), $con)->diff($brandCampiagns);


        $this->brandCampiagnsScheduledForDeletion = $brandCampiagnsToDelete;

        foreach ($brandCampiagnsToDelete as $brandCampiagnRemoved) {
            $brandCampiagnRemoved->setCompany(null);
        }

        $this->collBrandCampiagns = null;
        foreach ($brandCampiagns as $brandCampiagn) {
            $this->addBrandCampiagn($brandCampiagn);
        }

        $this->collBrandCampiagns = $brandCampiagns;
        $this->collBrandCampiagnsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related BrandCampiagn objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related BrandCampiagn objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBrandCampiagns(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBrandCampiagnsPartial && !$this->isNew();
        if (null === $this->collBrandCampiagns || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBrandCampiagns) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBrandCampiagns());
            }

            $query = ChildBrandCampiagnQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBrandCampiagns);
    }

    /**
     * Method called to associate a ChildBrandCampiagn object to this object
     * through the ChildBrandCampiagn foreign key attribute.
     *
     * @param ChildBrandCampiagn $l ChildBrandCampiagn
     * @return $this The current object (for fluent API support)
     */
    public function addBrandCampiagn(ChildBrandCampiagn $l)
    {
        if ($this->collBrandCampiagns === null) {
            $this->initBrandCampiagns();
            $this->collBrandCampiagnsPartial = true;
        }

        if (!$this->collBrandCampiagns->contains($l)) {
            $this->doAddBrandCampiagn($l);

            if ($this->brandCampiagnsScheduledForDeletion and $this->brandCampiagnsScheduledForDeletion->contains($l)) {
                $this->brandCampiagnsScheduledForDeletion->remove($this->brandCampiagnsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBrandCampiagn $brandCampiagn The ChildBrandCampiagn object to add.
     */
    protected function doAddBrandCampiagn(ChildBrandCampiagn $brandCampiagn): void
    {
        $this->collBrandCampiagns[]= $brandCampiagn;
        $brandCampiagn->setCompany($this);
    }

    /**
     * @param ChildBrandCampiagn $brandCampiagn The ChildBrandCampiagn object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBrandCampiagn(ChildBrandCampiagn $brandCampiagn)
    {
        if ($this->getBrandCampiagns()->contains($brandCampiagn)) {
            $pos = $this->collBrandCampiagns->search($brandCampiagn);
            $this->collBrandCampiagns->remove($pos);
            if (null === $this->brandCampiagnsScheduledForDeletion) {
                $this->brandCampiagnsScheduledForDeletion = clone $this->collBrandCampiagns;
                $this->brandCampiagnsScheduledForDeletion->clear();
            }
            $this->brandCampiagnsScheduledForDeletion[]= $brandCampiagn;
            $brandCampiagn->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagns from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagn[] List of ChildBrandCampiagn objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagn}> List of ChildBrandCampiagn objects
     */
    public function getBrandCampiagnsJoinDesignations(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnQuery::create(null, $criteria);
        $query->joinWith('Designations', $joinBehavior);

        return $this->getBrandCampiagns($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagns from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagn[] List of ChildBrandCampiagn objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagn}> List of ChildBrandCampiagn objects
     */
    public function getBrandCampiagnsJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getBrandCampiagns($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagns from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagn[] List of ChildBrandCampiagn objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagn}> List of ChildBrandCampiagn objects
     */
    public function getBrandCampiagnsJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getBrandCampiagns($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagns from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagn[] List of ChildBrandCampiagn objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagn}> List of ChildBrandCampiagn objects
     */
    public function getBrandCampiagnsJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getBrandCampiagns($query, $con);
    }

    /**
     * Clears out the collBrandCampiagnDoctorss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBrandCampiagnDoctorss()
     */
    public function clearBrandCampiagnDoctorss()
    {
        $this->collBrandCampiagnDoctorss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBrandCampiagnDoctorss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBrandCampiagnDoctorss($v = true): void
    {
        $this->collBrandCampiagnDoctorssPartial = $v;
    }

    /**
     * Initializes the collBrandCampiagnDoctorss collection.
     *
     * By default this just sets the collBrandCampiagnDoctorss collection to an empty array (like clearcollBrandCampiagnDoctorss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBrandCampiagnDoctorss(bool $overrideExisting = true): void
    {
        if (null !== $this->collBrandCampiagnDoctorss && !$overrideExisting) {
            return;
        }

        $collectionClassName = BrandCampiagnDoctorsTableMap::getTableMap()->getCollectionClassName();

        $this->collBrandCampiagnDoctorss = new $collectionClassName;
        $this->collBrandCampiagnDoctorss->setModel('\entities\BrandCampiagnDoctors');
    }

    /**
     * Gets an array of ChildBrandCampiagnDoctors objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBrandCampiagnDoctors[] List of ChildBrandCampiagnDoctors objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnDoctors> List of ChildBrandCampiagnDoctors objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBrandCampiagnDoctorss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBrandCampiagnDoctorssPartial && !$this->isNew();
        if (null === $this->collBrandCampiagnDoctorss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBrandCampiagnDoctorss) {
                    $this->initBrandCampiagnDoctorss();
                } else {
                    $collectionClassName = BrandCampiagnDoctorsTableMap::getTableMap()->getCollectionClassName();

                    $collBrandCampiagnDoctorss = new $collectionClassName;
                    $collBrandCampiagnDoctorss->setModel('\entities\BrandCampiagnDoctors');

                    return $collBrandCampiagnDoctorss;
                }
            } else {
                $collBrandCampiagnDoctorss = ChildBrandCampiagnDoctorsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBrandCampiagnDoctorssPartial && count($collBrandCampiagnDoctorss)) {
                        $this->initBrandCampiagnDoctorss(false);

                        foreach ($collBrandCampiagnDoctorss as $obj) {
                            if (false == $this->collBrandCampiagnDoctorss->contains($obj)) {
                                $this->collBrandCampiagnDoctorss->append($obj);
                            }
                        }

                        $this->collBrandCampiagnDoctorssPartial = true;
                    }

                    return $collBrandCampiagnDoctorss;
                }

                if ($partial && $this->collBrandCampiagnDoctorss) {
                    foreach ($this->collBrandCampiagnDoctorss as $obj) {
                        if ($obj->isNew()) {
                            $collBrandCampiagnDoctorss[] = $obj;
                        }
                    }
                }

                $this->collBrandCampiagnDoctorss = $collBrandCampiagnDoctorss;
                $this->collBrandCampiagnDoctorssPartial = false;
            }
        }

        return $this->collBrandCampiagnDoctorss;
    }

    /**
     * Sets a collection of ChildBrandCampiagnDoctors objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $brandCampiagnDoctorss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBrandCampiagnDoctorss(Collection $brandCampiagnDoctorss, ?ConnectionInterface $con = null)
    {
        /** @var ChildBrandCampiagnDoctors[] $brandCampiagnDoctorssToDelete */
        $brandCampiagnDoctorssToDelete = $this->getBrandCampiagnDoctorss(new Criteria(), $con)->diff($brandCampiagnDoctorss);


        $this->brandCampiagnDoctorssScheduledForDeletion = $brandCampiagnDoctorssToDelete;

        foreach ($brandCampiagnDoctorssToDelete as $brandCampiagnDoctorsRemoved) {
            $brandCampiagnDoctorsRemoved->setCompany(null);
        }

        $this->collBrandCampiagnDoctorss = null;
        foreach ($brandCampiagnDoctorss as $brandCampiagnDoctors) {
            $this->addBrandCampiagnDoctors($brandCampiagnDoctors);
        }

        $this->collBrandCampiagnDoctorss = $brandCampiagnDoctorss;
        $this->collBrandCampiagnDoctorssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related BrandCampiagnDoctors objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related BrandCampiagnDoctors objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBrandCampiagnDoctorss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBrandCampiagnDoctorssPartial && !$this->isNew();
        if (null === $this->collBrandCampiagnDoctorss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBrandCampiagnDoctorss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBrandCampiagnDoctorss());
            }

            $query = ChildBrandCampiagnDoctorsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBrandCampiagnDoctorss);
    }

    /**
     * Method called to associate a ChildBrandCampiagnDoctors object to this object
     * through the ChildBrandCampiagnDoctors foreign key attribute.
     *
     * @param ChildBrandCampiagnDoctors $l ChildBrandCampiagnDoctors
     * @return $this The current object (for fluent API support)
     */
    public function addBrandCampiagnDoctors(ChildBrandCampiagnDoctors $l)
    {
        if ($this->collBrandCampiagnDoctorss === null) {
            $this->initBrandCampiagnDoctorss();
            $this->collBrandCampiagnDoctorssPartial = true;
        }

        if (!$this->collBrandCampiagnDoctorss->contains($l)) {
            $this->doAddBrandCampiagnDoctors($l);

            if ($this->brandCampiagnDoctorssScheduledForDeletion and $this->brandCampiagnDoctorssScheduledForDeletion->contains($l)) {
                $this->brandCampiagnDoctorssScheduledForDeletion->remove($this->brandCampiagnDoctorssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBrandCampiagnDoctors $brandCampiagnDoctors The ChildBrandCampiagnDoctors object to add.
     */
    protected function doAddBrandCampiagnDoctors(ChildBrandCampiagnDoctors $brandCampiagnDoctors): void
    {
        $this->collBrandCampiagnDoctorss[]= $brandCampiagnDoctors;
        $brandCampiagnDoctors->setCompany($this);
    }

    /**
     * @param ChildBrandCampiagnDoctors $brandCampiagnDoctors The ChildBrandCampiagnDoctors object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBrandCampiagnDoctors(ChildBrandCampiagnDoctors $brandCampiagnDoctors)
    {
        if ($this->getBrandCampiagnDoctorss()->contains($brandCampiagnDoctors)) {
            $pos = $this->collBrandCampiagnDoctorss->search($brandCampiagnDoctors);
            $this->collBrandCampiagnDoctorss->remove($pos);
            if (null === $this->brandCampiagnDoctorssScheduledForDeletion) {
                $this->brandCampiagnDoctorssScheduledForDeletion = clone $this->collBrandCampiagnDoctorss;
                $this->brandCampiagnDoctorssScheduledForDeletion->clear();
            }
            $this->brandCampiagnDoctorssScheduledForDeletion[]= $brandCampiagnDoctors;
            $brandCampiagnDoctors->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagnDoctorss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagnDoctors[] List of ChildBrandCampiagnDoctors objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnDoctors}> List of ChildBrandCampiagnDoctors objects
     */
    public function getBrandCampiagnDoctorssJoinPositions(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnDoctorsQuery::create(null, $criteria);
        $query->joinWith('Positions', $joinBehavior);

        return $this->getBrandCampiagnDoctorss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagnDoctorss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagnDoctors[] List of ChildBrandCampiagnDoctors objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnDoctors}> List of ChildBrandCampiagnDoctors objects
     */
    public function getBrandCampiagnDoctorssJoinBrandCampiagn(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnDoctorsQuery::create(null, $criteria);
        $query->joinWith('BrandCampiagn', $joinBehavior);

        return $this->getBrandCampiagnDoctorss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagnDoctorss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagnDoctors[] List of ChildBrandCampiagnDoctors objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnDoctors}> List of ChildBrandCampiagnDoctors objects
     */
    public function getBrandCampiagnDoctorssJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnDoctorsQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getBrandCampiagnDoctorss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagnDoctorss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagnDoctors[] List of ChildBrandCampiagnDoctors objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnDoctors}> List of ChildBrandCampiagnDoctors objects
     */
    public function getBrandCampiagnDoctorssJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnDoctorsQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getBrandCampiagnDoctorss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagnDoctorss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagnDoctors[] List of ChildBrandCampiagnDoctors objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnDoctors}> List of ChildBrandCampiagnDoctors objects
     */
    public function getBrandCampiagnDoctorssJoinClassification(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnDoctorsQuery::create(null, $criteria);
        $query->joinWith('Classification', $joinBehavior);

        return $this->getBrandCampiagnDoctorss($query, $con);
    }

    /**
     * Clears out the collBrandCampiagnVisitPlans collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBrandCampiagnVisitPlans()
     */
    public function clearBrandCampiagnVisitPlans()
    {
        $this->collBrandCampiagnVisitPlans = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBrandCampiagnVisitPlans collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBrandCampiagnVisitPlans($v = true): void
    {
        $this->collBrandCampiagnVisitPlansPartial = $v;
    }

    /**
     * Initializes the collBrandCampiagnVisitPlans collection.
     *
     * By default this just sets the collBrandCampiagnVisitPlans collection to an empty array (like clearcollBrandCampiagnVisitPlans());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBrandCampiagnVisitPlans(bool $overrideExisting = true): void
    {
        if (null !== $this->collBrandCampiagnVisitPlans && !$overrideExisting) {
            return;
        }

        $collectionClassName = BrandCampiagnVisitPlanTableMap::getTableMap()->getCollectionClassName();

        $this->collBrandCampiagnVisitPlans = new $collectionClassName;
        $this->collBrandCampiagnVisitPlans->setModel('\entities\BrandCampiagnVisitPlan');
    }

    /**
     * Gets an array of ChildBrandCampiagnVisitPlan objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBrandCampiagnVisitPlan[] List of ChildBrandCampiagnVisitPlan objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnVisitPlan> List of ChildBrandCampiagnVisitPlan objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBrandCampiagnVisitPlans(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBrandCampiagnVisitPlansPartial && !$this->isNew();
        if (null === $this->collBrandCampiagnVisitPlans || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBrandCampiagnVisitPlans) {
                    $this->initBrandCampiagnVisitPlans();
                } else {
                    $collectionClassName = BrandCampiagnVisitPlanTableMap::getTableMap()->getCollectionClassName();

                    $collBrandCampiagnVisitPlans = new $collectionClassName;
                    $collBrandCampiagnVisitPlans->setModel('\entities\BrandCampiagnVisitPlan');

                    return $collBrandCampiagnVisitPlans;
                }
            } else {
                $collBrandCampiagnVisitPlans = ChildBrandCampiagnVisitPlanQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBrandCampiagnVisitPlansPartial && count($collBrandCampiagnVisitPlans)) {
                        $this->initBrandCampiagnVisitPlans(false);

                        foreach ($collBrandCampiagnVisitPlans as $obj) {
                            if (false == $this->collBrandCampiagnVisitPlans->contains($obj)) {
                                $this->collBrandCampiagnVisitPlans->append($obj);
                            }
                        }

                        $this->collBrandCampiagnVisitPlansPartial = true;
                    }

                    return $collBrandCampiagnVisitPlans;
                }

                if ($partial && $this->collBrandCampiagnVisitPlans) {
                    foreach ($this->collBrandCampiagnVisitPlans as $obj) {
                        if ($obj->isNew()) {
                            $collBrandCampiagnVisitPlans[] = $obj;
                        }
                    }
                }

                $this->collBrandCampiagnVisitPlans = $collBrandCampiagnVisitPlans;
                $this->collBrandCampiagnVisitPlansPartial = false;
            }
        }

        return $this->collBrandCampiagnVisitPlans;
    }

    /**
     * Sets a collection of ChildBrandCampiagnVisitPlan objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $brandCampiagnVisitPlans A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBrandCampiagnVisitPlans(Collection $brandCampiagnVisitPlans, ?ConnectionInterface $con = null)
    {
        /** @var ChildBrandCampiagnVisitPlan[] $brandCampiagnVisitPlansToDelete */
        $brandCampiagnVisitPlansToDelete = $this->getBrandCampiagnVisitPlans(new Criteria(), $con)->diff($brandCampiagnVisitPlans);


        $this->brandCampiagnVisitPlansScheduledForDeletion = $brandCampiagnVisitPlansToDelete;

        foreach ($brandCampiagnVisitPlansToDelete as $brandCampiagnVisitPlanRemoved) {
            $brandCampiagnVisitPlanRemoved->setCompany(null);
        }

        $this->collBrandCampiagnVisitPlans = null;
        foreach ($brandCampiagnVisitPlans as $brandCampiagnVisitPlan) {
            $this->addBrandCampiagnVisitPlan($brandCampiagnVisitPlan);
        }

        $this->collBrandCampiagnVisitPlans = $brandCampiagnVisitPlans;
        $this->collBrandCampiagnVisitPlansPartial = false;

        return $this;
    }

    /**
     * Returns the number of related BrandCampiagnVisitPlan objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related BrandCampiagnVisitPlan objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBrandCampiagnVisitPlans(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBrandCampiagnVisitPlansPartial && !$this->isNew();
        if (null === $this->collBrandCampiagnVisitPlans || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBrandCampiagnVisitPlans) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBrandCampiagnVisitPlans());
            }

            $query = ChildBrandCampiagnVisitPlanQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBrandCampiagnVisitPlans);
    }

    /**
     * Method called to associate a ChildBrandCampiagnVisitPlan object to this object
     * through the ChildBrandCampiagnVisitPlan foreign key attribute.
     *
     * @param ChildBrandCampiagnVisitPlan $l ChildBrandCampiagnVisitPlan
     * @return $this The current object (for fluent API support)
     */
    public function addBrandCampiagnVisitPlan(ChildBrandCampiagnVisitPlan $l)
    {
        if ($this->collBrandCampiagnVisitPlans === null) {
            $this->initBrandCampiagnVisitPlans();
            $this->collBrandCampiagnVisitPlansPartial = true;
        }

        if (!$this->collBrandCampiagnVisitPlans->contains($l)) {
            $this->doAddBrandCampiagnVisitPlan($l);

            if ($this->brandCampiagnVisitPlansScheduledForDeletion and $this->brandCampiagnVisitPlansScheduledForDeletion->contains($l)) {
                $this->brandCampiagnVisitPlansScheduledForDeletion->remove($this->brandCampiagnVisitPlansScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBrandCampiagnVisitPlan $brandCampiagnVisitPlan The ChildBrandCampiagnVisitPlan object to add.
     */
    protected function doAddBrandCampiagnVisitPlan(ChildBrandCampiagnVisitPlan $brandCampiagnVisitPlan): void
    {
        $this->collBrandCampiagnVisitPlans[]= $brandCampiagnVisitPlan;
        $brandCampiagnVisitPlan->setCompany($this);
    }

    /**
     * @param ChildBrandCampiagnVisitPlan $brandCampiagnVisitPlan The ChildBrandCampiagnVisitPlan object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBrandCampiagnVisitPlan(ChildBrandCampiagnVisitPlan $brandCampiagnVisitPlan)
    {
        if ($this->getBrandCampiagnVisitPlans()->contains($brandCampiagnVisitPlan)) {
            $pos = $this->collBrandCampiagnVisitPlans->search($brandCampiagnVisitPlan);
            $this->collBrandCampiagnVisitPlans->remove($pos);
            if (null === $this->brandCampiagnVisitPlansScheduledForDeletion) {
                $this->brandCampiagnVisitPlansScheduledForDeletion = clone $this->collBrandCampiagnVisitPlans;
                $this->brandCampiagnVisitPlansScheduledForDeletion->clear();
            }
            $this->brandCampiagnVisitPlansScheduledForDeletion[]= $brandCampiagnVisitPlan;
            $brandCampiagnVisitPlan->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagnVisitPlans from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagnVisitPlan[] List of ChildBrandCampiagnVisitPlan objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnVisitPlan}> List of ChildBrandCampiagnVisitPlan objects
     */
    public function getBrandCampiagnVisitPlansJoinBrandCampiagn(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnVisitPlanQuery::create(null, $criteria);
        $query->joinWith('BrandCampiagn', $joinBehavior);

        return $this->getBrandCampiagnVisitPlans($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagnVisitPlans from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagnVisitPlan[] List of ChildBrandCampiagnVisitPlan objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnVisitPlan}> List of ChildBrandCampiagnVisitPlan objects
     */
    public function getBrandCampiagnVisitPlansJoinAgendatypes(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnVisitPlanQuery::create(null, $criteria);
        $query->joinWith('Agendatypes', $joinBehavior);

        return $this->getBrandCampiagnVisitPlans($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCampiagnVisitPlans from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCampiagnVisitPlan[] List of ChildBrandCampiagnVisitPlan objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCampiagnVisitPlan}> List of ChildBrandCampiagnVisitPlan objects
     */
    public function getBrandCampiagnVisitPlansJoinSurvey(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCampiagnVisitPlanQuery::create(null, $criteria);
        $query->joinWith('Survey', $joinBehavior);

        return $this->getBrandCampiagnVisitPlans($query, $con);
    }

    /**
     * Clears out the collBrandCompetitions collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBrandCompetitions()
     */
    public function clearBrandCompetitions()
    {
        $this->collBrandCompetitions = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBrandCompetitions collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBrandCompetitions($v = true): void
    {
        $this->collBrandCompetitionsPartial = $v;
    }

    /**
     * Initializes the collBrandCompetitions collection.
     *
     * By default this just sets the collBrandCompetitions collection to an empty array (like clearcollBrandCompetitions());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBrandCompetitions(bool $overrideExisting = true): void
    {
        if (null !== $this->collBrandCompetitions && !$overrideExisting) {
            return;
        }

        $collectionClassName = BrandCompetitionTableMap::getTableMap()->getCollectionClassName();

        $this->collBrandCompetitions = new $collectionClassName;
        $this->collBrandCompetitions->setModel('\entities\BrandCompetition');
    }

    /**
     * Gets an array of ChildBrandCompetition objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBrandCompetition[] List of ChildBrandCompetition objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCompetition> List of ChildBrandCompetition objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBrandCompetitions(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBrandCompetitionsPartial && !$this->isNew();
        if (null === $this->collBrandCompetitions || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBrandCompetitions) {
                    $this->initBrandCompetitions();
                } else {
                    $collectionClassName = BrandCompetitionTableMap::getTableMap()->getCollectionClassName();

                    $collBrandCompetitions = new $collectionClassName;
                    $collBrandCompetitions->setModel('\entities\BrandCompetition');

                    return $collBrandCompetitions;
                }
            } else {
                $collBrandCompetitions = ChildBrandCompetitionQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBrandCompetitionsPartial && count($collBrandCompetitions)) {
                        $this->initBrandCompetitions(false);

                        foreach ($collBrandCompetitions as $obj) {
                            if (false == $this->collBrandCompetitions->contains($obj)) {
                                $this->collBrandCompetitions->append($obj);
                            }
                        }

                        $this->collBrandCompetitionsPartial = true;
                    }

                    return $collBrandCompetitions;
                }

                if ($partial && $this->collBrandCompetitions) {
                    foreach ($this->collBrandCompetitions as $obj) {
                        if ($obj->isNew()) {
                            $collBrandCompetitions[] = $obj;
                        }
                    }
                }

                $this->collBrandCompetitions = $collBrandCompetitions;
                $this->collBrandCompetitionsPartial = false;
            }
        }

        return $this->collBrandCompetitions;
    }

    /**
     * Sets a collection of ChildBrandCompetition objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $brandCompetitions A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBrandCompetitions(Collection $brandCompetitions, ?ConnectionInterface $con = null)
    {
        /** @var ChildBrandCompetition[] $brandCompetitionsToDelete */
        $brandCompetitionsToDelete = $this->getBrandCompetitions(new Criteria(), $con)->diff($brandCompetitions);


        $this->brandCompetitionsScheduledForDeletion = $brandCompetitionsToDelete;

        foreach ($brandCompetitionsToDelete as $brandCompetitionRemoved) {
            $brandCompetitionRemoved->setCompany(null);
        }

        $this->collBrandCompetitions = null;
        foreach ($brandCompetitions as $brandCompetition) {
            $this->addBrandCompetition($brandCompetition);
        }

        $this->collBrandCompetitions = $brandCompetitions;
        $this->collBrandCompetitionsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related BrandCompetition objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related BrandCompetition objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBrandCompetitions(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBrandCompetitionsPartial && !$this->isNew();
        if (null === $this->collBrandCompetitions || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBrandCompetitions) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBrandCompetitions());
            }

            $query = ChildBrandCompetitionQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBrandCompetitions);
    }

    /**
     * Method called to associate a ChildBrandCompetition object to this object
     * through the ChildBrandCompetition foreign key attribute.
     *
     * @param ChildBrandCompetition $l ChildBrandCompetition
     * @return $this The current object (for fluent API support)
     */
    public function addBrandCompetition(ChildBrandCompetition $l)
    {
        if ($this->collBrandCompetitions === null) {
            $this->initBrandCompetitions();
            $this->collBrandCompetitionsPartial = true;
        }

        if (!$this->collBrandCompetitions->contains($l)) {
            $this->doAddBrandCompetition($l);

            if ($this->brandCompetitionsScheduledForDeletion and $this->brandCompetitionsScheduledForDeletion->contains($l)) {
                $this->brandCompetitionsScheduledForDeletion->remove($this->brandCompetitionsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBrandCompetition $brandCompetition The ChildBrandCompetition object to add.
     */
    protected function doAddBrandCompetition(ChildBrandCompetition $brandCompetition): void
    {
        $this->collBrandCompetitions[]= $brandCompetition;
        $brandCompetition->setCompany($this);
    }

    /**
     * @param ChildBrandCompetition $brandCompetition The ChildBrandCompetition object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBrandCompetition(ChildBrandCompetition $brandCompetition)
    {
        if ($this->getBrandCompetitions()->contains($brandCompetition)) {
            $pos = $this->collBrandCompetitions->search($brandCompetition);
            $this->collBrandCompetitions->remove($pos);
            if (null === $this->brandCompetitionsScheduledForDeletion) {
                $this->brandCompetitionsScheduledForDeletion = clone $this->collBrandCompetitions;
                $this->brandCompetitionsScheduledForDeletion->clear();
            }
            $this->brandCompetitionsScheduledForDeletion[]= $brandCompetition;
            $brandCompetition->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCompetitions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCompetition[] List of ChildBrandCompetition objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCompetition}> List of ChildBrandCompetition objects
     */
    public function getBrandCompetitionsJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCompetitionQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getBrandCompetitions($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCompetitions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCompetition[] List of ChildBrandCompetition objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCompetition}> List of ChildBrandCompetition objects
     */
    public function getBrandCompetitionsJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCompetitionQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getBrandCompetitions($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandCompetitions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandCompetition[] List of ChildBrandCompetition objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandCompetition}> List of ChildBrandCompetition objects
     */
    public function getBrandCompetitionsJoinProducts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandCompetitionQuery::create(null, $criteria);
        $query->joinWith('Products', $joinBehavior);

        return $this->getBrandCompetitions($query, $con);
    }

    /**
     * Clears out the collBrandRcpas collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBrandRcpas()
     */
    public function clearBrandRcpas()
    {
        $this->collBrandRcpas = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBrandRcpas collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBrandRcpas($v = true): void
    {
        $this->collBrandRcpasPartial = $v;
    }

    /**
     * Initializes the collBrandRcpas collection.
     *
     * By default this just sets the collBrandRcpas collection to an empty array (like clearcollBrandRcpas());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBrandRcpas(bool $overrideExisting = true): void
    {
        if (null !== $this->collBrandRcpas && !$overrideExisting) {
            return;
        }

        $collectionClassName = BrandRcpaTableMap::getTableMap()->getCollectionClassName();

        $this->collBrandRcpas = new $collectionClassName;
        $this->collBrandRcpas->setModel('\entities\BrandRcpa');
    }

    /**
     * Gets an array of ChildBrandRcpa objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBrandRcpa[] List of ChildBrandRcpa objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandRcpa> List of ChildBrandRcpa objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBrandRcpas(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBrandRcpasPartial && !$this->isNew();
        if (null === $this->collBrandRcpas || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBrandRcpas) {
                    $this->initBrandRcpas();
                } else {
                    $collectionClassName = BrandRcpaTableMap::getTableMap()->getCollectionClassName();

                    $collBrandRcpas = new $collectionClassName;
                    $collBrandRcpas->setModel('\entities\BrandRcpa');

                    return $collBrandRcpas;
                }
            } else {
                $collBrandRcpas = ChildBrandRcpaQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBrandRcpasPartial && count($collBrandRcpas)) {
                        $this->initBrandRcpas(false);

                        foreach ($collBrandRcpas as $obj) {
                            if (false == $this->collBrandRcpas->contains($obj)) {
                                $this->collBrandRcpas->append($obj);
                            }
                        }

                        $this->collBrandRcpasPartial = true;
                    }

                    return $collBrandRcpas;
                }

                if ($partial && $this->collBrandRcpas) {
                    foreach ($this->collBrandRcpas as $obj) {
                        if ($obj->isNew()) {
                            $collBrandRcpas[] = $obj;
                        }
                    }
                }

                $this->collBrandRcpas = $collBrandRcpas;
                $this->collBrandRcpasPartial = false;
            }
        }

        return $this->collBrandRcpas;
    }

    /**
     * Sets a collection of ChildBrandRcpa objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $brandRcpas A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBrandRcpas(Collection $brandRcpas, ?ConnectionInterface $con = null)
    {
        /** @var ChildBrandRcpa[] $brandRcpasToDelete */
        $brandRcpasToDelete = $this->getBrandRcpas(new Criteria(), $con)->diff($brandRcpas);


        $this->brandRcpasScheduledForDeletion = $brandRcpasToDelete;

        foreach ($brandRcpasToDelete as $brandRcpaRemoved) {
            $brandRcpaRemoved->setCompany(null);
        }

        $this->collBrandRcpas = null;
        foreach ($brandRcpas as $brandRcpa) {
            $this->addBrandRcpa($brandRcpa);
        }

        $this->collBrandRcpas = $brandRcpas;
        $this->collBrandRcpasPartial = false;

        return $this;
    }

    /**
     * Returns the number of related BrandRcpa objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related BrandRcpa objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBrandRcpas(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBrandRcpasPartial && !$this->isNew();
        if (null === $this->collBrandRcpas || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBrandRcpas) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBrandRcpas());
            }

            $query = ChildBrandRcpaQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBrandRcpas);
    }

    /**
     * Method called to associate a ChildBrandRcpa object to this object
     * through the ChildBrandRcpa foreign key attribute.
     *
     * @param ChildBrandRcpa $l ChildBrandRcpa
     * @return $this The current object (for fluent API support)
     */
    public function addBrandRcpa(ChildBrandRcpa $l)
    {
        if ($this->collBrandRcpas === null) {
            $this->initBrandRcpas();
            $this->collBrandRcpasPartial = true;
        }

        if (!$this->collBrandRcpas->contains($l)) {
            $this->doAddBrandRcpa($l);

            if ($this->brandRcpasScheduledForDeletion and $this->brandRcpasScheduledForDeletion->contains($l)) {
                $this->brandRcpasScheduledForDeletion->remove($this->brandRcpasScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBrandRcpa $brandRcpa The ChildBrandRcpa object to add.
     */
    protected function doAddBrandRcpa(ChildBrandRcpa $brandRcpa): void
    {
        $this->collBrandRcpas[]= $brandRcpa;
        $brandRcpa->setCompany($this);
    }

    /**
     * @param ChildBrandRcpa $brandRcpa The ChildBrandRcpa object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBrandRcpa(ChildBrandRcpa $brandRcpa)
    {
        if ($this->getBrandRcpas()->contains($brandRcpa)) {
            $pos = $this->collBrandRcpas->search($brandRcpa);
            $this->collBrandRcpas->remove($pos);
            if (null === $this->brandRcpasScheduledForDeletion) {
                $this->brandRcpasScheduledForDeletion = clone $this->collBrandRcpas;
                $this->brandRcpasScheduledForDeletion->clear();
            }
            $this->brandRcpasScheduledForDeletion[]= $brandRcpa;
            $brandRcpa->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandRcpas from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandRcpa[] List of ChildBrandRcpa objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandRcpa}> List of ChildBrandRcpa objects
     */
    public function getBrandRcpasJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandRcpaQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getBrandRcpas($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandRcpas from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandRcpa[] List of ChildBrandRcpa objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandRcpa}> List of ChildBrandRcpa objects
     */
    public function getBrandRcpasJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandRcpaQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getBrandRcpas($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related BrandRcpas from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrandRcpa[] List of ChildBrandRcpa objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrandRcpa}> List of ChildBrandRcpa objects
     */
    public function getBrandRcpasJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandRcpaQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getBrandRcpas($query, $con);
    }

    /**
     * Clears out the collBrandss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBrandss()
     */
    public function clearBrandss()
    {
        $this->collBrandss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBrandss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBrandss($v = true): void
    {
        $this->collBrandssPartial = $v;
    }

    /**
     * Initializes the collBrandss collection.
     *
     * By default this just sets the collBrandss collection to an empty array (like clearcollBrandss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBrandss(bool $overrideExisting = true): void
    {
        if (null !== $this->collBrandss && !$overrideExisting) {
            return;
        }

        $collectionClassName = BrandsTableMap::getTableMap()->getCollectionClassName();

        $this->collBrandss = new $collectionClassName;
        $this->collBrandss->setModel('\entities\Brands');
    }

    /**
     * Gets an array of ChildBrands objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBrands[] List of ChildBrands objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrands> List of ChildBrands objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBrandss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBrandssPartial && !$this->isNew();
        if (null === $this->collBrandss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBrandss) {
                    $this->initBrandss();
                } else {
                    $collectionClassName = BrandsTableMap::getTableMap()->getCollectionClassName();

                    $collBrandss = new $collectionClassName;
                    $collBrandss->setModel('\entities\Brands');

                    return $collBrandss;
                }
            } else {
                $collBrandss = ChildBrandsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBrandssPartial && count($collBrandss)) {
                        $this->initBrandss(false);

                        foreach ($collBrandss as $obj) {
                            if (false == $this->collBrandss->contains($obj)) {
                                $this->collBrandss->append($obj);
                            }
                        }

                        $this->collBrandssPartial = true;
                    }

                    return $collBrandss;
                }

                if ($partial && $this->collBrandss) {
                    foreach ($this->collBrandss as $obj) {
                        if ($obj->isNew()) {
                            $collBrandss[] = $obj;
                        }
                    }
                }

                $this->collBrandss = $collBrandss;
                $this->collBrandssPartial = false;
            }
        }

        return $this->collBrandss;
    }

    /**
     * Sets a collection of ChildBrands objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $brandss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBrandss(Collection $brandss, ?ConnectionInterface $con = null)
    {
        /** @var ChildBrands[] $brandssToDelete */
        $brandssToDelete = $this->getBrandss(new Criteria(), $con)->diff($brandss);


        $this->brandssScheduledForDeletion = $brandssToDelete;

        foreach ($brandssToDelete as $brandsRemoved) {
            $brandsRemoved->setCompany(null);
        }

        $this->collBrandss = null;
        foreach ($brandss as $brands) {
            $this->addBrands($brands);
        }

        $this->collBrandss = $brandss;
        $this->collBrandssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Brands objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Brands objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBrandss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBrandssPartial && !$this->isNew();
        if (null === $this->collBrandss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBrandss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBrandss());
            }

            $query = ChildBrandsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBrandss);
    }

    /**
     * Method called to associate a ChildBrands object to this object
     * through the ChildBrands foreign key attribute.
     *
     * @param ChildBrands $l ChildBrands
     * @return $this The current object (for fluent API support)
     */
    public function addBrands(ChildBrands $l)
    {
        if ($this->collBrandss === null) {
            $this->initBrandss();
            $this->collBrandssPartial = true;
        }

        if (!$this->collBrandss->contains($l)) {
            $this->doAddBrands($l);

            if ($this->brandssScheduledForDeletion and $this->brandssScheduledForDeletion->contains($l)) {
                $this->brandssScheduledForDeletion->remove($this->brandssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBrands $brands The ChildBrands object to add.
     */
    protected function doAddBrands(ChildBrands $brands): void
    {
        $this->collBrandss[]= $brands;
        $brands->setCompany($this);
    }

    /**
     * @param ChildBrands $brands The ChildBrands object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBrands(ChildBrands $brands)
    {
        if ($this->getBrandss()->contains($brands)) {
            $pos = $this->collBrandss->search($brands);
            $this->collBrandss->remove($pos);
            if (null === $this->brandssScheduledForDeletion) {
                $this->brandssScheduledForDeletion = clone $this->collBrandss;
                $this->brandssScheduledForDeletion->clear();
            }
            $this->brandssScheduledForDeletion[]= $brands;
            $brands->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Brandss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildBrands[] List of ChildBrands objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBrands}> List of ChildBrands objects
     */
    public function getBrandssJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildBrandsQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getBrandss($query, $con);
    }

    /**
     * Clears out the collBudgetGroups collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addBudgetGroups()
     */
    public function clearBudgetGroups()
    {
        $this->collBudgetGroups = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collBudgetGroups collection loaded partially.
     *
     * @return void
     */
    public function resetPartialBudgetGroups($v = true): void
    {
        $this->collBudgetGroupsPartial = $v;
    }

    /**
     * Initializes the collBudgetGroups collection.
     *
     * By default this just sets the collBudgetGroups collection to an empty array (like clearcollBudgetGroups());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initBudgetGroups(bool $overrideExisting = true): void
    {
        if (null !== $this->collBudgetGroups && !$overrideExisting) {
            return;
        }

        $collectionClassName = BudgetGroupTableMap::getTableMap()->getCollectionClassName();

        $this->collBudgetGroups = new $collectionClassName;
        $this->collBudgetGroups->setModel('\entities\BudgetGroup');
    }

    /**
     * Gets an array of ChildBudgetGroup objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildBudgetGroup[] List of ChildBudgetGroup objects
     * @phpstan-return ObjectCollection&\Traversable<ChildBudgetGroup> List of ChildBudgetGroup objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getBudgetGroups(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collBudgetGroupsPartial && !$this->isNew();
        if (null === $this->collBudgetGroups || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collBudgetGroups) {
                    $this->initBudgetGroups();
                } else {
                    $collectionClassName = BudgetGroupTableMap::getTableMap()->getCollectionClassName();

                    $collBudgetGroups = new $collectionClassName;
                    $collBudgetGroups->setModel('\entities\BudgetGroup');

                    return $collBudgetGroups;
                }
            } else {
                $collBudgetGroups = ChildBudgetGroupQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collBudgetGroupsPartial && count($collBudgetGroups)) {
                        $this->initBudgetGroups(false);

                        foreach ($collBudgetGroups as $obj) {
                            if (false == $this->collBudgetGroups->contains($obj)) {
                                $this->collBudgetGroups->append($obj);
                            }
                        }

                        $this->collBudgetGroupsPartial = true;
                    }

                    return $collBudgetGroups;
                }

                if ($partial && $this->collBudgetGroups) {
                    foreach ($this->collBudgetGroups as $obj) {
                        if ($obj->isNew()) {
                            $collBudgetGroups[] = $obj;
                        }
                    }
                }

                $this->collBudgetGroups = $collBudgetGroups;
                $this->collBudgetGroupsPartial = false;
            }
        }

        return $this->collBudgetGroups;
    }

    /**
     * Sets a collection of ChildBudgetGroup objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $budgetGroups A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setBudgetGroups(Collection $budgetGroups, ?ConnectionInterface $con = null)
    {
        /** @var ChildBudgetGroup[] $budgetGroupsToDelete */
        $budgetGroupsToDelete = $this->getBudgetGroups(new Criteria(), $con)->diff($budgetGroups);


        $this->budgetGroupsScheduledForDeletion = $budgetGroupsToDelete;

        foreach ($budgetGroupsToDelete as $budgetGroupRemoved) {
            $budgetGroupRemoved->setCompany(null);
        }

        $this->collBudgetGroups = null;
        foreach ($budgetGroups as $budgetGroup) {
            $this->addBudgetGroup($budgetGroup);
        }

        $this->collBudgetGroups = $budgetGroups;
        $this->collBudgetGroupsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related BudgetGroup objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related BudgetGroup objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countBudgetGroups(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collBudgetGroupsPartial && !$this->isNew();
        if (null === $this->collBudgetGroups || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collBudgetGroups) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getBudgetGroups());
            }

            $query = ChildBudgetGroupQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collBudgetGroups);
    }

    /**
     * Method called to associate a ChildBudgetGroup object to this object
     * through the ChildBudgetGroup foreign key attribute.
     *
     * @param ChildBudgetGroup $l ChildBudgetGroup
     * @return $this The current object (for fluent API support)
     */
    public function addBudgetGroup(ChildBudgetGroup $l)
    {
        if ($this->collBudgetGroups === null) {
            $this->initBudgetGroups();
            $this->collBudgetGroupsPartial = true;
        }

        if (!$this->collBudgetGroups->contains($l)) {
            $this->doAddBudgetGroup($l);

            if ($this->budgetGroupsScheduledForDeletion and $this->budgetGroupsScheduledForDeletion->contains($l)) {
                $this->budgetGroupsScheduledForDeletion->remove($this->budgetGroupsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildBudgetGroup $budgetGroup The ChildBudgetGroup object to add.
     */
    protected function doAddBudgetGroup(ChildBudgetGroup $budgetGroup): void
    {
        $this->collBudgetGroups[]= $budgetGroup;
        $budgetGroup->setCompany($this);
    }

    /**
     * @param ChildBudgetGroup $budgetGroup The ChildBudgetGroup object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeBudgetGroup(ChildBudgetGroup $budgetGroup)
    {
        if ($this->getBudgetGroups()->contains($budgetGroup)) {
            $pos = $this->collBudgetGroups->search($budgetGroup);
            $this->collBudgetGroups->remove($pos);
            if (null === $this->budgetGroupsScheduledForDeletion) {
                $this->budgetGroupsScheduledForDeletion = clone $this->collBudgetGroups;
                $this->budgetGroupsScheduledForDeletion->clear();
            }
            $this->budgetGroupsScheduledForDeletion[]= clone $budgetGroup;
            $budgetGroup->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collCategoriess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addCategoriess()
     */
    public function clearCategoriess()
    {
        $this->collCategoriess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collCategoriess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialCategoriess($v = true): void
    {
        $this->collCategoriessPartial = $v;
    }

    /**
     * Initializes the collCategoriess collection.
     *
     * By default this just sets the collCategoriess collection to an empty array (like clearcollCategoriess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initCategoriess(bool $overrideExisting = true): void
    {
        if (null !== $this->collCategoriess && !$overrideExisting) {
            return;
        }

        $collectionClassName = CategoriesTableMap::getTableMap()->getCollectionClassName();

        $this->collCategoriess = new $collectionClassName;
        $this->collCategoriess->setModel('\entities\Categories');
    }

    /**
     * Gets an array of ChildCategories objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildCategories[] List of ChildCategories objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCategories> List of ChildCategories objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getCategoriess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collCategoriessPartial && !$this->isNew();
        if (null === $this->collCategoriess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collCategoriess) {
                    $this->initCategoriess();
                } else {
                    $collectionClassName = CategoriesTableMap::getTableMap()->getCollectionClassName();

                    $collCategoriess = new $collectionClassName;
                    $collCategoriess->setModel('\entities\Categories');

                    return $collCategoriess;
                }
            } else {
                $collCategoriess = ChildCategoriesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collCategoriessPartial && count($collCategoriess)) {
                        $this->initCategoriess(false);

                        foreach ($collCategoriess as $obj) {
                            if (false == $this->collCategoriess->contains($obj)) {
                                $this->collCategoriess->append($obj);
                            }
                        }

                        $this->collCategoriessPartial = true;
                    }

                    return $collCategoriess;
                }

                if ($partial && $this->collCategoriess) {
                    foreach ($this->collCategoriess as $obj) {
                        if ($obj->isNew()) {
                            $collCategoriess[] = $obj;
                        }
                    }
                }

                $this->collCategoriess = $collCategoriess;
                $this->collCategoriessPartial = false;
            }
        }

        return $this->collCategoriess;
    }

    /**
     * Sets a collection of ChildCategories objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $categoriess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setCategoriess(Collection $categoriess, ?ConnectionInterface $con = null)
    {
        /** @var ChildCategories[] $categoriessToDelete */
        $categoriessToDelete = $this->getCategoriess(new Criteria(), $con)->diff($categoriess);


        $this->categoriessScheduledForDeletion = $categoriessToDelete;

        foreach ($categoriessToDelete as $categoriesRemoved) {
            $categoriesRemoved->setCompany(null);
        }

        $this->collCategoriess = null;
        foreach ($categoriess as $categories) {
            $this->addCategories($categories);
        }

        $this->collCategoriess = $categoriess;
        $this->collCategoriessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Categories objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Categories objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countCategoriess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collCategoriessPartial && !$this->isNew();
        if (null === $this->collCategoriess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collCategoriess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getCategoriess());
            }

            $query = ChildCategoriesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collCategoriess);
    }

    /**
     * Method called to associate a ChildCategories object to this object
     * through the ChildCategories foreign key attribute.
     *
     * @param ChildCategories $l ChildCategories
     * @return $this The current object (for fluent API support)
     */
    public function addCategories(ChildCategories $l)
    {
        if ($this->collCategoriess === null) {
            $this->initCategoriess();
            $this->collCategoriessPartial = true;
        }

        if (!$this->collCategoriess->contains($l)) {
            $this->doAddCategories($l);

            if ($this->categoriessScheduledForDeletion and $this->categoriessScheduledForDeletion->contains($l)) {
                $this->categoriessScheduledForDeletion->remove($this->categoriessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildCategories $categories The ChildCategories object to add.
     */
    protected function doAddCategories(ChildCategories $categories): void
    {
        $this->collCategoriess[]= $categories;
        $categories->setCompany($this);
    }

    /**
     * @param ChildCategories $categories The ChildCategories object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeCategories(ChildCategories $categories)
    {
        if ($this->getCategoriess()->contains($categories)) {
            $pos = $this->collCategoriess->search($categories);
            $this->collCategoriess->remove($pos);
            if (null === $this->categoriessScheduledForDeletion) {
                $this->categoriessScheduledForDeletion = clone $this->collCategoriess;
                $this->categoriessScheduledForDeletion->clear();
            }
            $this->categoriessScheduledForDeletion[]= $categories;
            $categories->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Categoriess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildCategories[] List of ChildCategories objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCategories}> List of ChildCategories objects
     */
    public function getCategoriessJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildCategoriesQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getCategoriess($query, $con);
    }

    /**
     * Clears out the collCheckinoutOutcomess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addCheckinoutOutcomess()
     */
    public function clearCheckinoutOutcomess()
    {
        $this->collCheckinoutOutcomess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collCheckinoutOutcomess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialCheckinoutOutcomess($v = true): void
    {
        $this->collCheckinoutOutcomessPartial = $v;
    }

    /**
     * Initializes the collCheckinoutOutcomess collection.
     *
     * By default this just sets the collCheckinoutOutcomess collection to an empty array (like clearcollCheckinoutOutcomess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initCheckinoutOutcomess(bool $overrideExisting = true): void
    {
        if (null !== $this->collCheckinoutOutcomess && !$overrideExisting) {
            return;
        }

        $collectionClassName = CheckinoutOutcomesTableMap::getTableMap()->getCollectionClassName();

        $this->collCheckinoutOutcomess = new $collectionClassName;
        $this->collCheckinoutOutcomess->setModel('\entities\CheckinoutOutcomes');
    }

    /**
     * Gets an array of ChildCheckinoutOutcomes objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildCheckinoutOutcomes[] List of ChildCheckinoutOutcomes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCheckinoutOutcomes> List of ChildCheckinoutOutcomes objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getCheckinoutOutcomess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collCheckinoutOutcomessPartial && !$this->isNew();
        if (null === $this->collCheckinoutOutcomess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collCheckinoutOutcomess) {
                    $this->initCheckinoutOutcomess();
                } else {
                    $collectionClassName = CheckinoutOutcomesTableMap::getTableMap()->getCollectionClassName();

                    $collCheckinoutOutcomess = new $collectionClassName;
                    $collCheckinoutOutcomess->setModel('\entities\CheckinoutOutcomes');

                    return $collCheckinoutOutcomess;
                }
            } else {
                $collCheckinoutOutcomess = ChildCheckinoutOutcomesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collCheckinoutOutcomessPartial && count($collCheckinoutOutcomess)) {
                        $this->initCheckinoutOutcomess(false);

                        foreach ($collCheckinoutOutcomess as $obj) {
                            if (false == $this->collCheckinoutOutcomess->contains($obj)) {
                                $this->collCheckinoutOutcomess->append($obj);
                            }
                        }

                        $this->collCheckinoutOutcomessPartial = true;
                    }

                    return $collCheckinoutOutcomess;
                }

                if ($partial && $this->collCheckinoutOutcomess) {
                    foreach ($this->collCheckinoutOutcomess as $obj) {
                        if ($obj->isNew()) {
                            $collCheckinoutOutcomess[] = $obj;
                        }
                    }
                }

                $this->collCheckinoutOutcomess = $collCheckinoutOutcomess;
                $this->collCheckinoutOutcomessPartial = false;
            }
        }

        return $this->collCheckinoutOutcomess;
    }

    /**
     * Sets a collection of ChildCheckinoutOutcomes objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $checkinoutOutcomess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setCheckinoutOutcomess(Collection $checkinoutOutcomess, ?ConnectionInterface $con = null)
    {
        /** @var ChildCheckinoutOutcomes[] $checkinoutOutcomessToDelete */
        $checkinoutOutcomessToDelete = $this->getCheckinoutOutcomess(new Criteria(), $con)->diff($checkinoutOutcomess);


        $this->checkinoutOutcomessScheduledForDeletion = $checkinoutOutcomessToDelete;

        foreach ($checkinoutOutcomessToDelete as $checkinoutOutcomesRemoved) {
            $checkinoutOutcomesRemoved->setCompany(null);
        }

        $this->collCheckinoutOutcomess = null;
        foreach ($checkinoutOutcomess as $checkinoutOutcomes) {
            $this->addCheckinoutOutcomes($checkinoutOutcomes);
        }

        $this->collCheckinoutOutcomess = $checkinoutOutcomess;
        $this->collCheckinoutOutcomessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related CheckinoutOutcomes objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related CheckinoutOutcomes objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countCheckinoutOutcomess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collCheckinoutOutcomessPartial && !$this->isNew();
        if (null === $this->collCheckinoutOutcomess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collCheckinoutOutcomess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getCheckinoutOutcomess());
            }

            $query = ChildCheckinoutOutcomesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collCheckinoutOutcomess);
    }

    /**
     * Method called to associate a ChildCheckinoutOutcomes object to this object
     * through the ChildCheckinoutOutcomes foreign key attribute.
     *
     * @param ChildCheckinoutOutcomes $l ChildCheckinoutOutcomes
     * @return $this The current object (for fluent API support)
     */
    public function addCheckinoutOutcomes(ChildCheckinoutOutcomes $l)
    {
        if ($this->collCheckinoutOutcomess === null) {
            $this->initCheckinoutOutcomess();
            $this->collCheckinoutOutcomessPartial = true;
        }

        if (!$this->collCheckinoutOutcomess->contains($l)) {
            $this->doAddCheckinoutOutcomes($l);

            if ($this->checkinoutOutcomessScheduledForDeletion and $this->checkinoutOutcomessScheduledForDeletion->contains($l)) {
                $this->checkinoutOutcomessScheduledForDeletion->remove($this->checkinoutOutcomessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildCheckinoutOutcomes $checkinoutOutcomes The ChildCheckinoutOutcomes object to add.
     */
    protected function doAddCheckinoutOutcomes(ChildCheckinoutOutcomes $checkinoutOutcomes): void
    {
        $this->collCheckinoutOutcomess[]= $checkinoutOutcomes;
        $checkinoutOutcomes->setCompany($this);
    }

    /**
     * @param ChildCheckinoutOutcomes $checkinoutOutcomes The ChildCheckinoutOutcomes object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeCheckinoutOutcomes(ChildCheckinoutOutcomes $checkinoutOutcomes)
    {
        if ($this->getCheckinoutOutcomess()->contains($checkinoutOutcomes)) {
            $pos = $this->collCheckinoutOutcomess->search($checkinoutOutcomes);
            $this->collCheckinoutOutcomess->remove($pos);
            if (null === $this->checkinoutOutcomessScheduledForDeletion) {
                $this->checkinoutOutcomessScheduledForDeletion = clone $this->collCheckinoutOutcomess;
                $this->checkinoutOutcomessScheduledForDeletion->clear();
            }
            $this->checkinoutOutcomessScheduledForDeletion[]= clone $checkinoutOutcomes;
            $checkinoutOutcomes->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collCitycategories collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addCitycategories()
     */
    public function clearCitycategories()
    {
        $this->collCitycategories = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collCitycategories collection loaded partially.
     *
     * @return void
     */
    public function resetPartialCitycategories($v = true): void
    {
        $this->collCitycategoriesPartial = $v;
    }

    /**
     * Initializes the collCitycategories collection.
     *
     * By default this just sets the collCitycategories collection to an empty array (like clearcollCitycategories());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initCitycategories(bool $overrideExisting = true): void
    {
        if (null !== $this->collCitycategories && !$overrideExisting) {
            return;
        }

        $collectionClassName = CitycategoryTableMap::getTableMap()->getCollectionClassName();

        $this->collCitycategories = new $collectionClassName;
        $this->collCitycategories->setModel('\entities\Citycategory');
    }

    /**
     * Gets an array of ChildCitycategory objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildCitycategory[] List of ChildCitycategory objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCitycategory> List of ChildCitycategory objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getCitycategories(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collCitycategoriesPartial && !$this->isNew();
        if (null === $this->collCitycategories || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collCitycategories) {
                    $this->initCitycategories();
                } else {
                    $collectionClassName = CitycategoryTableMap::getTableMap()->getCollectionClassName();

                    $collCitycategories = new $collectionClassName;
                    $collCitycategories->setModel('\entities\Citycategory');

                    return $collCitycategories;
                }
            } else {
                $collCitycategories = ChildCitycategoryQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collCitycategoriesPartial && count($collCitycategories)) {
                        $this->initCitycategories(false);

                        foreach ($collCitycategories as $obj) {
                            if (false == $this->collCitycategories->contains($obj)) {
                                $this->collCitycategories->append($obj);
                            }
                        }

                        $this->collCitycategoriesPartial = true;
                    }

                    return $collCitycategories;
                }

                if ($partial && $this->collCitycategories) {
                    foreach ($this->collCitycategories as $obj) {
                        if ($obj->isNew()) {
                            $collCitycategories[] = $obj;
                        }
                    }
                }

                $this->collCitycategories = $collCitycategories;
                $this->collCitycategoriesPartial = false;
            }
        }

        return $this->collCitycategories;
    }

    /**
     * Sets a collection of ChildCitycategory objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $citycategories A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setCitycategories(Collection $citycategories, ?ConnectionInterface $con = null)
    {
        /** @var ChildCitycategory[] $citycategoriesToDelete */
        $citycategoriesToDelete = $this->getCitycategories(new Criteria(), $con)->diff($citycategories);


        $this->citycategoriesScheduledForDeletion = $citycategoriesToDelete;

        foreach ($citycategoriesToDelete as $citycategoryRemoved) {
            $citycategoryRemoved->setCompany(null);
        }

        $this->collCitycategories = null;
        foreach ($citycategories as $citycategory) {
            $this->addCitycategory($citycategory);
        }

        $this->collCitycategories = $citycategories;
        $this->collCitycategoriesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Citycategory objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Citycategory objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countCitycategories(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collCitycategoriesPartial && !$this->isNew();
        if (null === $this->collCitycategories || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collCitycategories) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getCitycategories());
            }

            $query = ChildCitycategoryQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collCitycategories);
    }

    /**
     * Method called to associate a ChildCitycategory object to this object
     * through the ChildCitycategory foreign key attribute.
     *
     * @param ChildCitycategory $l ChildCitycategory
     * @return $this The current object (for fluent API support)
     */
    public function addCitycategory(ChildCitycategory $l)
    {
        if ($this->collCitycategories === null) {
            $this->initCitycategories();
            $this->collCitycategoriesPartial = true;
        }

        if (!$this->collCitycategories->contains($l)) {
            $this->doAddCitycategory($l);

            if ($this->citycategoriesScheduledForDeletion and $this->citycategoriesScheduledForDeletion->contains($l)) {
                $this->citycategoriesScheduledForDeletion->remove($this->citycategoriesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildCitycategory $citycategory The ChildCitycategory object to add.
     */
    protected function doAddCitycategory(ChildCitycategory $citycategory): void
    {
        $this->collCitycategories[]= $citycategory;
        $citycategory->setCompany($this);
    }

    /**
     * @param ChildCitycategory $citycategory The ChildCitycategory object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeCitycategory(ChildCitycategory $citycategory)
    {
        if ($this->getCitycategories()->contains($citycategory)) {
            $pos = $this->collCitycategories->search($citycategory);
            $this->collCitycategories->remove($pos);
            if (null === $this->citycategoriesScheduledForDeletion) {
                $this->citycategoriesScheduledForDeletion = clone $this->collCitycategories;
                $this->citycategoriesScheduledForDeletion->clear();
            }
            $this->citycategoriesScheduledForDeletion[]= clone $citycategory;
            $citycategory->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Citycategories from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildCitycategory[] List of ChildCitycategory objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCitycategory}> List of ChildCitycategory objects
     */
    public function getCitycategoriesJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildCitycategoryQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getCitycategories($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Citycategories from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildCitycategory[] List of ChildCitycategory objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCitycategory}> List of ChildCitycategory objects
     */
    public function getCitycategoriesJoinGradeMaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildCitycategoryQuery::create(null, $criteria);
        $query->joinWith('GradeMaster', $joinBehavior);

        return $this->getCitycategories($query, $con);
    }

    /**
     * Clears out the collClassifications collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addClassifications()
     */
    public function clearClassifications()
    {
        $this->collClassifications = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collClassifications collection loaded partially.
     *
     * @return void
     */
    public function resetPartialClassifications($v = true): void
    {
        $this->collClassificationsPartial = $v;
    }

    /**
     * Initializes the collClassifications collection.
     *
     * By default this just sets the collClassifications collection to an empty array (like clearcollClassifications());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initClassifications(bool $overrideExisting = true): void
    {
        if (null !== $this->collClassifications && !$overrideExisting) {
            return;
        }

        $collectionClassName = ClassificationTableMap::getTableMap()->getCollectionClassName();

        $this->collClassifications = new $collectionClassName;
        $this->collClassifications->setModel('\entities\Classification');
    }

    /**
     * Gets an array of ChildClassification objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildClassification[] List of ChildClassification objects
     * @phpstan-return ObjectCollection&\Traversable<ChildClassification> List of ChildClassification objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getClassifications(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collClassificationsPartial && !$this->isNew();
        if (null === $this->collClassifications || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collClassifications) {
                    $this->initClassifications();
                } else {
                    $collectionClassName = ClassificationTableMap::getTableMap()->getCollectionClassName();

                    $collClassifications = new $collectionClassName;
                    $collClassifications->setModel('\entities\Classification');

                    return $collClassifications;
                }
            } else {
                $collClassifications = ChildClassificationQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collClassificationsPartial && count($collClassifications)) {
                        $this->initClassifications(false);

                        foreach ($collClassifications as $obj) {
                            if (false == $this->collClassifications->contains($obj)) {
                                $this->collClassifications->append($obj);
                            }
                        }

                        $this->collClassificationsPartial = true;
                    }

                    return $collClassifications;
                }

                if ($partial && $this->collClassifications) {
                    foreach ($this->collClassifications as $obj) {
                        if ($obj->isNew()) {
                            $collClassifications[] = $obj;
                        }
                    }
                }

                $this->collClassifications = $collClassifications;
                $this->collClassificationsPartial = false;
            }
        }

        return $this->collClassifications;
    }

    /**
     * Sets a collection of ChildClassification objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $classifications A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setClassifications(Collection $classifications, ?ConnectionInterface $con = null)
    {
        /** @var ChildClassification[] $classificationsToDelete */
        $classificationsToDelete = $this->getClassifications(new Criteria(), $con)->diff($classifications);


        $this->classificationsScheduledForDeletion = $classificationsToDelete;

        foreach ($classificationsToDelete as $classificationRemoved) {
            $classificationRemoved->setCompany(null);
        }

        $this->collClassifications = null;
        foreach ($classifications as $classification) {
            $this->addClassification($classification);
        }

        $this->collClassifications = $classifications;
        $this->collClassificationsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Classification objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Classification objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countClassifications(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collClassificationsPartial && !$this->isNew();
        if (null === $this->collClassifications || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collClassifications) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getClassifications());
            }

            $query = ChildClassificationQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collClassifications);
    }

    /**
     * Method called to associate a ChildClassification object to this object
     * through the ChildClassification foreign key attribute.
     *
     * @param ChildClassification $l ChildClassification
     * @return $this The current object (for fluent API support)
     */
    public function addClassification(ChildClassification $l)
    {
        if ($this->collClassifications === null) {
            $this->initClassifications();
            $this->collClassificationsPartial = true;
        }

        if (!$this->collClassifications->contains($l)) {
            $this->doAddClassification($l);

            if ($this->classificationsScheduledForDeletion and $this->classificationsScheduledForDeletion->contains($l)) {
                $this->classificationsScheduledForDeletion->remove($this->classificationsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildClassification $classification The ChildClassification object to add.
     */
    protected function doAddClassification(ChildClassification $classification): void
    {
        $this->collClassifications[]= $classification;
        $classification->setCompany($this);
    }

    /**
     * @param ChildClassification $classification The ChildClassification object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeClassification(ChildClassification $classification)
    {
        if ($this->getClassifications()->contains($classification)) {
            $pos = $this->collClassifications->search($classification);
            $this->collClassifications->remove($pos);
            if (null === $this->classificationsScheduledForDeletion) {
                $this->classificationsScheduledForDeletion = clone $this->collClassifications;
                $this->classificationsScheduledForDeletion->clear();
            }
            $this->classificationsScheduledForDeletion[]= clone $classification;
            $classification->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Classifications from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildClassification[] List of ChildClassification objects
     * @phpstan-return ObjectCollection&\Traversable<ChildClassification}> List of ChildClassification objects
     */
    public function getClassificationsJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildClassificationQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getClassifications($query, $con);
    }

    /**
     * Clears out the collCompetitionMappings collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addCompetitionMappings()
     */
    public function clearCompetitionMappings()
    {
        $this->collCompetitionMappings = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collCompetitionMappings collection loaded partially.
     *
     * @return void
     */
    public function resetPartialCompetitionMappings($v = true): void
    {
        $this->collCompetitionMappingsPartial = $v;
    }

    /**
     * Initializes the collCompetitionMappings collection.
     *
     * By default this just sets the collCompetitionMappings collection to an empty array (like clearcollCompetitionMappings());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initCompetitionMappings(bool $overrideExisting = true): void
    {
        if (null !== $this->collCompetitionMappings && !$overrideExisting) {
            return;
        }

        $collectionClassName = CompetitionMappingTableMap::getTableMap()->getCollectionClassName();

        $this->collCompetitionMappings = new $collectionClassName;
        $this->collCompetitionMappings->setModel('\entities\CompetitionMapping');
    }

    /**
     * Gets an array of ChildCompetitionMapping objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildCompetitionMapping[] List of ChildCompetitionMapping objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCompetitionMapping> List of ChildCompetitionMapping objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getCompetitionMappings(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collCompetitionMappingsPartial && !$this->isNew();
        if (null === $this->collCompetitionMappings || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collCompetitionMappings) {
                    $this->initCompetitionMappings();
                } else {
                    $collectionClassName = CompetitionMappingTableMap::getTableMap()->getCollectionClassName();

                    $collCompetitionMappings = new $collectionClassName;
                    $collCompetitionMappings->setModel('\entities\CompetitionMapping');

                    return $collCompetitionMappings;
                }
            } else {
                $collCompetitionMappings = ChildCompetitionMappingQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collCompetitionMappingsPartial && count($collCompetitionMappings)) {
                        $this->initCompetitionMappings(false);

                        foreach ($collCompetitionMappings as $obj) {
                            if (false == $this->collCompetitionMappings->contains($obj)) {
                                $this->collCompetitionMappings->append($obj);
                            }
                        }

                        $this->collCompetitionMappingsPartial = true;
                    }

                    return $collCompetitionMappings;
                }

                if ($partial && $this->collCompetitionMappings) {
                    foreach ($this->collCompetitionMappings as $obj) {
                        if ($obj->isNew()) {
                            $collCompetitionMappings[] = $obj;
                        }
                    }
                }

                $this->collCompetitionMappings = $collCompetitionMappings;
                $this->collCompetitionMappingsPartial = false;
            }
        }

        return $this->collCompetitionMappings;
    }

    /**
     * Sets a collection of ChildCompetitionMapping objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $competitionMappings A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setCompetitionMappings(Collection $competitionMappings, ?ConnectionInterface $con = null)
    {
        /** @var ChildCompetitionMapping[] $competitionMappingsToDelete */
        $competitionMappingsToDelete = $this->getCompetitionMappings(new Criteria(), $con)->diff($competitionMappings);


        $this->competitionMappingsScheduledForDeletion = $competitionMappingsToDelete;

        foreach ($competitionMappingsToDelete as $competitionMappingRemoved) {
            $competitionMappingRemoved->setCompany(null);
        }

        $this->collCompetitionMappings = null;
        foreach ($competitionMappings as $competitionMapping) {
            $this->addCompetitionMapping($competitionMapping);
        }

        $this->collCompetitionMappings = $competitionMappings;
        $this->collCompetitionMappingsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related CompetitionMapping objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related CompetitionMapping objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countCompetitionMappings(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collCompetitionMappingsPartial && !$this->isNew();
        if (null === $this->collCompetitionMappings || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collCompetitionMappings) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getCompetitionMappings());
            }

            $query = ChildCompetitionMappingQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collCompetitionMappings);
    }

    /**
     * Method called to associate a ChildCompetitionMapping object to this object
     * through the ChildCompetitionMapping foreign key attribute.
     *
     * @param ChildCompetitionMapping $l ChildCompetitionMapping
     * @return $this The current object (for fluent API support)
     */
    public function addCompetitionMapping(ChildCompetitionMapping $l)
    {
        if ($this->collCompetitionMappings === null) {
            $this->initCompetitionMappings();
            $this->collCompetitionMappingsPartial = true;
        }

        if (!$this->collCompetitionMappings->contains($l)) {
            $this->doAddCompetitionMapping($l);

            if ($this->competitionMappingsScheduledForDeletion and $this->competitionMappingsScheduledForDeletion->contains($l)) {
                $this->competitionMappingsScheduledForDeletion->remove($this->competitionMappingsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildCompetitionMapping $competitionMapping The ChildCompetitionMapping object to add.
     */
    protected function doAddCompetitionMapping(ChildCompetitionMapping $competitionMapping): void
    {
        $this->collCompetitionMappings[]= $competitionMapping;
        $competitionMapping->setCompany($this);
    }

    /**
     * @param ChildCompetitionMapping $competitionMapping The ChildCompetitionMapping object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeCompetitionMapping(ChildCompetitionMapping $competitionMapping)
    {
        if ($this->getCompetitionMappings()->contains($competitionMapping)) {
            $pos = $this->collCompetitionMappings->search($competitionMapping);
            $this->collCompetitionMappings->remove($pos);
            if (null === $this->competitionMappingsScheduledForDeletion) {
                $this->competitionMappingsScheduledForDeletion = clone $this->collCompetitionMappings;
                $this->competitionMappingsScheduledForDeletion->clear();
            }
            $this->competitionMappingsScheduledForDeletion[]= clone $competitionMapping;
            $competitionMapping->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related CompetitionMappings from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildCompetitionMapping[] List of ChildCompetitionMapping objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCompetitionMapping}> List of ChildCompetitionMapping objects
     */
    public function getCompetitionMappingsJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildCompetitionMappingQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getCompetitionMappings($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related CompetitionMappings from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildCompetitionMapping[] List of ChildCompetitionMapping objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCompetitionMapping}> List of ChildCompetitionMapping objects
     */
    public function getCompetitionMappingsJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildCompetitionMappingQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getCompetitionMappings($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related CompetitionMappings from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildCompetitionMapping[] List of ChildCompetitionMapping objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCompetitionMapping}> List of ChildCompetitionMapping objects
     */
    public function getCompetitionMappingsJoinCompetitor(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildCompetitionMappingQuery::create(null, $criteria);
        $query->joinWith('Competitor', $joinBehavior);

        return $this->getCompetitionMappings($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related CompetitionMappings from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildCompetitionMapping[] List of ChildCompetitionMapping objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCompetitionMapping}> List of ChildCompetitionMapping objects
     */
    public function getCompetitionMappingsJoinUnitmaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildCompetitionMappingQuery::create(null, $criteria);
        $query->joinWith('Unitmaster', $joinBehavior);

        return $this->getCompetitionMappings($query, $con);
    }

    /**
     * Clears out the collCompetitors collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addCompetitors()
     */
    public function clearCompetitors()
    {
        $this->collCompetitors = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collCompetitors collection loaded partially.
     *
     * @return void
     */
    public function resetPartialCompetitors($v = true): void
    {
        $this->collCompetitorsPartial = $v;
    }

    /**
     * Initializes the collCompetitors collection.
     *
     * By default this just sets the collCompetitors collection to an empty array (like clearcollCompetitors());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initCompetitors(bool $overrideExisting = true): void
    {
        if (null !== $this->collCompetitors && !$overrideExisting) {
            return;
        }

        $collectionClassName = CompetitorTableMap::getTableMap()->getCollectionClassName();

        $this->collCompetitors = new $collectionClassName;
        $this->collCompetitors->setModel('\entities\Competitor');
    }

    /**
     * Gets an array of ChildCompetitor objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildCompetitor[] List of ChildCompetitor objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCompetitor> List of ChildCompetitor objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getCompetitors(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collCompetitorsPartial && !$this->isNew();
        if (null === $this->collCompetitors || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collCompetitors) {
                    $this->initCompetitors();
                } else {
                    $collectionClassName = CompetitorTableMap::getTableMap()->getCollectionClassName();

                    $collCompetitors = new $collectionClassName;
                    $collCompetitors->setModel('\entities\Competitor');

                    return $collCompetitors;
                }
            } else {
                $collCompetitors = ChildCompetitorQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collCompetitorsPartial && count($collCompetitors)) {
                        $this->initCompetitors(false);

                        foreach ($collCompetitors as $obj) {
                            if (false == $this->collCompetitors->contains($obj)) {
                                $this->collCompetitors->append($obj);
                            }
                        }

                        $this->collCompetitorsPartial = true;
                    }

                    return $collCompetitors;
                }

                if ($partial && $this->collCompetitors) {
                    foreach ($this->collCompetitors as $obj) {
                        if ($obj->isNew()) {
                            $collCompetitors[] = $obj;
                        }
                    }
                }

                $this->collCompetitors = $collCompetitors;
                $this->collCompetitorsPartial = false;
            }
        }

        return $this->collCompetitors;
    }

    /**
     * Sets a collection of ChildCompetitor objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $competitors A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setCompetitors(Collection $competitors, ?ConnectionInterface $con = null)
    {
        /** @var ChildCompetitor[] $competitorsToDelete */
        $competitorsToDelete = $this->getCompetitors(new Criteria(), $con)->diff($competitors);


        $this->competitorsScheduledForDeletion = $competitorsToDelete;

        foreach ($competitorsToDelete as $competitorRemoved) {
            $competitorRemoved->setCompany(null);
        }

        $this->collCompetitors = null;
        foreach ($competitors as $competitor) {
            $this->addCompetitor($competitor);
        }

        $this->collCompetitors = $competitors;
        $this->collCompetitorsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Competitor objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Competitor objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countCompetitors(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collCompetitorsPartial && !$this->isNew();
        if (null === $this->collCompetitors || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collCompetitors) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getCompetitors());
            }

            $query = ChildCompetitorQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collCompetitors);
    }

    /**
     * Method called to associate a ChildCompetitor object to this object
     * through the ChildCompetitor foreign key attribute.
     *
     * @param ChildCompetitor $l ChildCompetitor
     * @return $this The current object (for fluent API support)
     */
    public function addCompetitor(ChildCompetitor $l)
    {
        if ($this->collCompetitors === null) {
            $this->initCompetitors();
            $this->collCompetitorsPartial = true;
        }

        if (!$this->collCompetitors->contains($l)) {
            $this->doAddCompetitor($l);

            if ($this->competitorsScheduledForDeletion and $this->competitorsScheduledForDeletion->contains($l)) {
                $this->competitorsScheduledForDeletion->remove($this->competitorsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildCompetitor $competitor The ChildCompetitor object to add.
     */
    protected function doAddCompetitor(ChildCompetitor $competitor): void
    {
        $this->collCompetitors[]= $competitor;
        $competitor->setCompany($this);
    }

    /**
     * @param ChildCompetitor $competitor The ChildCompetitor object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeCompetitor(ChildCompetitor $competitor)
    {
        if ($this->getCompetitors()->contains($competitor)) {
            $pos = $this->collCompetitors->search($competitor);
            $this->collCompetitors->remove($pos);
            if (null === $this->competitorsScheduledForDeletion) {
                $this->competitorsScheduledForDeletion = clone $this->collCompetitors;
                $this->competitorsScheduledForDeletion->clear();
            }
            $this->competitorsScheduledForDeletion[]= clone $competitor;
            $competitor->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collConfigurations collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addConfigurations()
     */
    public function clearConfigurations()
    {
        $this->collConfigurations = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collConfigurations collection loaded partially.
     *
     * @return void
     */
    public function resetPartialConfigurations($v = true): void
    {
        $this->collConfigurationsPartial = $v;
    }

    /**
     * Initializes the collConfigurations collection.
     *
     * By default this just sets the collConfigurations collection to an empty array (like clearcollConfigurations());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initConfigurations(bool $overrideExisting = true): void
    {
        if (null !== $this->collConfigurations && !$overrideExisting) {
            return;
        }

        $collectionClassName = ConfigurationTableMap::getTableMap()->getCollectionClassName();

        $this->collConfigurations = new $collectionClassName;
        $this->collConfigurations->setModel('\entities\Configuration');
    }

    /**
     * Gets an array of ChildConfiguration objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildConfiguration[] List of ChildConfiguration objects
     * @phpstan-return ObjectCollection&\Traversable<ChildConfiguration> List of ChildConfiguration objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getConfigurations(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collConfigurationsPartial && !$this->isNew();
        if (null === $this->collConfigurations || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collConfigurations) {
                    $this->initConfigurations();
                } else {
                    $collectionClassName = ConfigurationTableMap::getTableMap()->getCollectionClassName();

                    $collConfigurations = new $collectionClassName;
                    $collConfigurations->setModel('\entities\Configuration');

                    return $collConfigurations;
                }
            } else {
                $collConfigurations = ChildConfigurationQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collConfigurationsPartial && count($collConfigurations)) {
                        $this->initConfigurations(false);

                        foreach ($collConfigurations as $obj) {
                            if (false == $this->collConfigurations->contains($obj)) {
                                $this->collConfigurations->append($obj);
                            }
                        }

                        $this->collConfigurationsPartial = true;
                    }

                    return $collConfigurations;
                }

                if ($partial && $this->collConfigurations) {
                    foreach ($this->collConfigurations as $obj) {
                        if ($obj->isNew()) {
                            $collConfigurations[] = $obj;
                        }
                    }
                }

                $this->collConfigurations = $collConfigurations;
                $this->collConfigurationsPartial = false;
            }
        }

        return $this->collConfigurations;
    }

    /**
     * Sets a collection of ChildConfiguration objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $configurations A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setConfigurations(Collection $configurations, ?ConnectionInterface $con = null)
    {
        /** @var ChildConfiguration[] $configurationsToDelete */
        $configurationsToDelete = $this->getConfigurations(new Criteria(), $con)->diff($configurations);


        $this->configurationsScheduledForDeletion = $configurationsToDelete;

        foreach ($configurationsToDelete as $configurationRemoved) {
            $configurationRemoved->setCompany(null);
        }

        $this->collConfigurations = null;
        foreach ($configurations as $configuration) {
            $this->addConfiguration($configuration);
        }

        $this->collConfigurations = $configurations;
        $this->collConfigurationsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Configuration objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Configuration objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countConfigurations(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collConfigurationsPartial && !$this->isNew();
        if (null === $this->collConfigurations || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collConfigurations) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getConfigurations());
            }

            $query = ChildConfigurationQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collConfigurations);
    }

    /**
     * Method called to associate a ChildConfiguration object to this object
     * through the ChildConfiguration foreign key attribute.
     *
     * @param ChildConfiguration $l ChildConfiguration
     * @return $this The current object (for fluent API support)
     */
    public function addConfiguration(ChildConfiguration $l)
    {
        if ($this->collConfigurations === null) {
            $this->initConfigurations();
            $this->collConfigurationsPartial = true;
        }

        if (!$this->collConfigurations->contains($l)) {
            $this->doAddConfiguration($l);

            if ($this->configurationsScheduledForDeletion and $this->configurationsScheduledForDeletion->contains($l)) {
                $this->configurationsScheduledForDeletion->remove($this->configurationsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildConfiguration $configuration The ChildConfiguration object to add.
     */
    protected function doAddConfiguration(ChildConfiguration $configuration): void
    {
        $this->collConfigurations[]= $configuration;
        $configuration->setCompany($this);
    }

    /**
     * @param ChildConfiguration $configuration The ChildConfiguration object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeConfiguration(ChildConfiguration $configuration)
    {
        if ($this->getConfigurations()->contains($configuration)) {
            $pos = $this->collConfigurations->search($configuration);
            $this->collConfigurations->remove($pos);
            if (null === $this->configurationsScheduledForDeletion) {
                $this->configurationsScheduledForDeletion = clone $this->collConfigurations;
                $this->configurationsScheduledForDeletion->clear();
            }
            $this->configurationsScheduledForDeletion[]= clone $configuration;
            $configuration->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collCronCommandLogss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addCronCommandLogss()
     */
    public function clearCronCommandLogss()
    {
        $this->collCronCommandLogss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collCronCommandLogss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialCronCommandLogss($v = true): void
    {
        $this->collCronCommandLogssPartial = $v;
    }

    /**
     * Initializes the collCronCommandLogss collection.
     *
     * By default this just sets the collCronCommandLogss collection to an empty array (like clearcollCronCommandLogss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initCronCommandLogss(bool $overrideExisting = true): void
    {
        if (null !== $this->collCronCommandLogss && !$overrideExisting) {
            return;
        }

        $collectionClassName = CronCommandLogsTableMap::getTableMap()->getCollectionClassName();

        $this->collCronCommandLogss = new $collectionClassName;
        $this->collCronCommandLogss->setModel('\entities\CronCommandLogs');
    }

    /**
     * Gets an array of ChildCronCommandLogs objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildCronCommandLogs[] List of ChildCronCommandLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCronCommandLogs> List of ChildCronCommandLogs objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getCronCommandLogss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collCronCommandLogssPartial && !$this->isNew();
        if (null === $this->collCronCommandLogss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collCronCommandLogss) {
                    $this->initCronCommandLogss();
                } else {
                    $collectionClassName = CronCommandLogsTableMap::getTableMap()->getCollectionClassName();

                    $collCronCommandLogss = new $collectionClassName;
                    $collCronCommandLogss->setModel('\entities\CronCommandLogs');

                    return $collCronCommandLogss;
                }
            } else {
                $collCronCommandLogss = ChildCronCommandLogsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collCronCommandLogssPartial && count($collCronCommandLogss)) {
                        $this->initCronCommandLogss(false);

                        foreach ($collCronCommandLogss as $obj) {
                            if (false == $this->collCronCommandLogss->contains($obj)) {
                                $this->collCronCommandLogss->append($obj);
                            }
                        }

                        $this->collCronCommandLogssPartial = true;
                    }

                    return $collCronCommandLogss;
                }

                if ($partial && $this->collCronCommandLogss) {
                    foreach ($this->collCronCommandLogss as $obj) {
                        if ($obj->isNew()) {
                            $collCronCommandLogss[] = $obj;
                        }
                    }
                }

                $this->collCronCommandLogss = $collCronCommandLogss;
                $this->collCronCommandLogssPartial = false;
            }
        }

        return $this->collCronCommandLogss;
    }

    /**
     * Sets a collection of ChildCronCommandLogs objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $cronCommandLogss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setCronCommandLogss(Collection $cronCommandLogss, ?ConnectionInterface $con = null)
    {
        /** @var ChildCronCommandLogs[] $cronCommandLogssToDelete */
        $cronCommandLogssToDelete = $this->getCronCommandLogss(new Criteria(), $con)->diff($cronCommandLogss);


        $this->cronCommandLogssScheduledForDeletion = $cronCommandLogssToDelete;

        foreach ($cronCommandLogssToDelete as $cronCommandLogsRemoved) {
            $cronCommandLogsRemoved->setCompany(null);
        }

        $this->collCronCommandLogss = null;
        foreach ($cronCommandLogss as $cronCommandLogs) {
            $this->addCronCommandLogs($cronCommandLogs);
        }

        $this->collCronCommandLogss = $cronCommandLogss;
        $this->collCronCommandLogssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related CronCommandLogs objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related CronCommandLogs objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countCronCommandLogss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collCronCommandLogssPartial && !$this->isNew();
        if (null === $this->collCronCommandLogss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collCronCommandLogss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getCronCommandLogss());
            }

            $query = ChildCronCommandLogsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collCronCommandLogss);
    }

    /**
     * Method called to associate a ChildCronCommandLogs object to this object
     * through the ChildCronCommandLogs foreign key attribute.
     *
     * @param ChildCronCommandLogs $l ChildCronCommandLogs
     * @return $this The current object (for fluent API support)
     */
    public function addCronCommandLogs(ChildCronCommandLogs $l)
    {
        if ($this->collCronCommandLogss === null) {
            $this->initCronCommandLogss();
            $this->collCronCommandLogssPartial = true;
        }

        if (!$this->collCronCommandLogss->contains($l)) {
            $this->doAddCronCommandLogs($l);

            if ($this->cronCommandLogssScheduledForDeletion and $this->cronCommandLogssScheduledForDeletion->contains($l)) {
                $this->cronCommandLogssScheduledForDeletion->remove($this->cronCommandLogssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildCronCommandLogs $cronCommandLogs The ChildCronCommandLogs object to add.
     */
    protected function doAddCronCommandLogs(ChildCronCommandLogs $cronCommandLogs): void
    {
        $this->collCronCommandLogss[]= $cronCommandLogs;
        $cronCommandLogs->setCompany($this);
    }

    /**
     * @param ChildCronCommandLogs $cronCommandLogs The ChildCronCommandLogs object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeCronCommandLogs(ChildCronCommandLogs $cronCommandLogs)
    {
        if ($this->getCronCommandLogss()->contains($cronCommandLogs)) {
            $pos = $this->collCronCommandLogss->search($cronCommandLogs);
            $this->collCronCommandLogss->remove($pos);
            if (null === $this->cronCommandLogssScheduledForDeletion) {
                $this->cronCommandLogssScheduledForDeletion = clone $this->collCronCommandLogss;
                $this->cronCommandLogssScheduledForDeletion->clear();
            }
            $this->cronCommandLogssScheduledForDeletion[]= $cronCommandLogs;
            $cronCommandLogs->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related CronCommandLogss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildCronCommandLogs[] List of ChildCronCommandLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCronCommandLogs}> List of ChildCronCommandLogs objects
     */
    public function getCronCommandLogssJoinCronCommands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildCronCommandLogsQuery::create(null, $criteria);
        $query->joinWith('CronCommands', $joinBehavior);

        return $this->getCronCommandLogss($query, $con);
    }

    /**
     * Clears out the collCronCommandss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addCronCommandss()
     */
    public function clearCronCommandss()
    {
        $this->collCronCommandss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collCronCommandss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialCronCommandss($v = true): void
    {
        $this->collCronCommandssPartial = $v;
    }

    /**
     * Initializes the collCronCommandss collection.
     *
     * By default this just sets the collCronCommandss collection to an empty array (like clearcollCronCommandss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initCronCommandss(bool $overrideExisting = true): void
    {
        if (null !== $this->collCronCommandss && !$overrideExisting) {
            return;
        }

        $collectionClassName = CronCommandsTableMap::getTableMap()->getCollectionClassName();

        $this->collCronCommandss = new $collectionClassName;
        $this->collCronCommandss->setModel('\entities\CronCommands');
    }

    /**
     * Gets an array of ChildCronCommands objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildCronCommands[] List of ChildCronCommands objects
     * @phpstan-return ObjectCollection&\Traversable<ChildCronCommands> List of ChildCronCommands objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getCronCommandss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collCronCommandssPartial && !$this->isNew();
        if (null === $this->collCronCommandss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collCronCommandss) {
                    $this->initCronCommandss();
                } else {
                    $collectionClassName = CronCommandsTableMap::getTableMap()->getCollectionClassName();

                    $collCronCommandss = new $collectionClassName;
                    $collCronCommandss->setModel('\entities\CronCommands');

                    return $collCronCommandss;
                }
            } else {
                $collCronCommandss = ChildCronCommandsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collCronCommandssPartial && count($collCronCommandss)) {
                        $this->initCronCommandss(false);

                        foreach ($collCronCommandss as $obj) {
                            if (false == $this->collCronCommandss->contains($obj)) {
                                $this->collCronCommandss->append($obj);
                            }
                        }

                        $this->collCronCommandssPartial = true;
                    }

                    return $collCronCommandss;
                }

                if ($partial && $this->collCronCommandss) {
                    foreach ($this->collCronCommandss as $obj) {
                        if ($obj->isNew()) {
                            $collCronCommandss[] = $obj;
                        }
                    }
                }

                $this->collCronCommandss = $collCronCommandss;
                $this->collCronCommandssPartial = false;
            }
        }

        return $this->collCronCommandss;
    }

    /**
     * Sets a collection of ChildCronCommands objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $cronCommandss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setCronCommandss(Collection $cronCommandss, ?ConnectionInterface $con = null)
    {
        /** @var ChildCronCommands[] $cronCommandssToDelete */
        $cronCommandssToDelete = $this->getCronCommandss(new Criteria(), $con)->diff($cronCommandss);


        $this->cronCommandssScheduledForDeletion = $cronCommandssToDelete;

        foreach ($cronCommandssToDelete as $cronCommandsRemoved) {
            $cronCommandsRemoved->setCompany(null);
        }

        $this->collCronCommandss = null;
        foreach ($cronCommandss as $cronCommands) {
            $this->addCronCommands($cronCommands);
        }

        $this->collCronCommandss = $cronCommandss;
        $this->collCronCommandssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related CronCommands objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related CronCommands objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countCronCommandss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collCronCommandssPartial && !$this->isNew();
        if (null === $this->collCronCommandss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collCronCommandss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getCronCommandss());
            }

            $query = ChildCronCommandsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collCronCommandss);
    }

    /**
     * Method called to associate a ChildCronCommands object to this object
     * through the ChildCronCommands foreign key attribute.
     *
     * @param ChildCronCommands $l ChildCronCommands
     * @return $this The current object (for fluent API support)
     */
    public function addCronCommands(ChildCronCommands $l)
    {
        if ($this->collCronCommandss === null) {
            $this->initCronCommandss();
            $this->collCronCommandssPartial = true;
        }

        if (!$this->collCronCommandss->contains($l)) {
            $this->doAddCronCommands($l);

            if ($this->cronCommandssScheduledForDeletion and $this->cronCommandssScheduledForDeletion->contains($l)) {
                $this->cronCommandssScheduledForDeletion->remove($this->cronCommandssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildCronCommands $cronCommands The ChildCronCommands object to add.
     */
    protected function doAddCronCommands(ChildCronCommands $cronCommands): void
    {
        $this->collCronCommandss[]= $cronCommands;
        $cronCommands->setCompany($this);
    }

    /**
     * @param ChildCronCommands $cronCommands The ChildCronCommands object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeCronCommands(ChildCronCommands $cronCommands)
    {
        if ($this->getCronCommandss()->contains($cronCommands)) {
            $pos = $this->collCronCommandss->search($cronCommands);
            $this->collCronCommandss->remove($pos);
            if (null === $this->cronCommandssScheduledForDeletion) {
                $this->cronCommandssScheduledForDeletion = clone $this->collCronCommandss;
                $this->cronCommandssScheduledForDeletion->clear();
            }
            $this->cronCommandssScheduledForDeletion[]= $cronCommands;
            $cronCommands->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collDailycallss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addDailycallss()
     */
    public function clearDailycallss()
    {
        $this->collDailycallss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collDailycallss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialDailycallss($v = true): void
    {
        $this->collDailycallssPartial = $v;
    }

    /**
     * Initializes the collDailycallss collection.
     *
     * By default this just sets the collDailycallss collection to an empty array (like clearcollDailycallss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initDailycallss(bool $overrideExisting = true): void
    {
        if (null !== $this->collDailycallss && !$overrideExisting) {
            return;
        }

        $collectionClassName = DailycallsTableMap::getTableMap()->getCollectionClassName();

        $this->collDailycallss = new $collectionClassName;
        $this->collDailycallss->setModel('\entities\Dailycalls');
    }

    /**
     * Gets an array of ChildDailycalls objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildDailycalls[] List of ChildDailycalls objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycalls> List of ChildDailycalls objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getDailycallss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collDailycallssPartial && !$this->isNew();
        if (null === $this->collDailycallss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collDailycallss) {
                    $this->initDailycallss();
                } else {
                    $collectionClassName = DailycallsTableMap::getTableMap()->getCollectionClassName();

                    $collDailycallss = new $collectionClassName;
                    $collDailycallss->setModel('\entities\Dailycalls');

                    return $collDailycallss;
                }
            } else {
                $collDailycallss = ChildDailycallsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collDailycallssPartial && count($collDailycallss)) {
                        $this->initDailycallss(false);

                        foreach ($collDailycallss as $obj) {
                            if (false == $this->collDailycallss->contains($obj)) {
                                $this->collDailycallss->append($obj);
                            }
                        }

                        $this->collDailycallssPartial = true;
                    }

                    return $collDailycallss;
                }

                if ($partial && $this->collDailycallss) {
                    foreach ($this->collDailycallss as $obj) {
                        if ($obj->isNew()) {
                            $collDailycallss[] = $obj;
                        }
                    }
                }

                $this->collDailycallss = $collDailycallss;
                $this->collDailycallssPartial = false;
            }
        }

        return $this->collDailycallss;
    }

    /**
     * Sets a collection of ChildDailycalls objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $dailycallss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setDailycallss(Collection $dailycallss, ?ConnectionInterface $con = null)
    {
        /** @var ChildDailycalls[] $dailycallssToDelete */
        $dailycallssToDelete = $this->getDailycallss(new Criteria(), $con)->diff($dailycallss);


        $this->dailycallssScheduledForDeletion = $dailycallssToDelete;

        foreach ($dailycallssToDelete as $dailycallsRemoved) {
            $dailycallsRemoved->setCompany(null);
        }

        $this->collDailycallss = null;
        foreach ($dailycallss as $dailycalls) {
            $this->addDailycalls($dailycalls);
        }

        $this->collDailycallss = $dailycallss;
        $this->collDailycallssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Dailycalls objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Dailycalls objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countDailycallss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collDailycallssPartial && !$this->isNew();
        if (null === $this->collDailycallss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collDailycallss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getDailycallss());
            }

            $query = ChildDailycallsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collDailycallss);
    }

    /**
     * Method called to associate a ChildDailycalls object to this object
     * through the ChildDailycalls foreign key attribute.
     *
     * @param ChildDailycalls $l ChildDailycalls
     * @return $this The current object (for fluent API support)
     */
    public function addDailycalls(ChildDailycalls $l)
    {
        if ($this->collDailycallss === null) {
            $this->initDailycallss();
            $this->collDailycallssPartial = true;
        }

        if (!$this->collDailycallss->contains($l)) {
            $this->doAddDailycalls($l);

            if ($this->dailycallssScheduledForDeletion and $this->dailycallssScheduledForDeletion->contains($l)) {
                $this->dailycallssScheduledForDeletion->remove($this->dailycallssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildDailycalls $dailycalls The ChildDailycalls object to add.
     */
    protected function doAddDailycalls(ChildDailycalls $dailycalls): void
    {
        $this->collDailycallss[]= $dailycalls;
        $dailycalls->setCompany($this);
    }

    /**
     * @param ChildDailycalls $dailycalls The ChildDailycalls object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeDailycalls(ChildDailycalls $dailycalls)
    {
        if ($this->getDailycallss()->contains($dailycalls)) {
            $pos = $this->collDailycallss->search($dailycalls);
            $this->collDailycallss->remove($pos);
            if (null === $this->dailycallssScheduledForDeletion) {
                $this->dailycallssScheduledForDeletion = clone $this->collDailycallss;
                $this->dailycallssScheduledForDeletion->clear();
            }
            $this->dailycallssScheduledForDeletion[]= $dailycalls;
            $dailycalls->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Dailycallss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDailycalls[] List of ChildDailycalls objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycalls}> List of ChildDailycalls objects
     */
    public function getDailycallssJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDailycallsQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getDailycallss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Dailycallss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDailycalls[] List of ChildDailycalls objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycalls}> List of ChildDailycalls objects
     */
    public function getDailycallssJoinAgendatypes(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDailycallsQuery::create(null, $criteria);
        $query->joinWith('Agendatypes', $joinBehavior);

        return $this->getDailycallss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Dailycallss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDailycalls[] List of ChildDailycalls objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycalls}> List of ChildDailycalls objects
     */
    public function getDailycallssJoinPositions(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDailycallsQuery::create(null, $criteria);
        $query->joinWith('Positions', $joinBehavior);

        return $this->getDailycallss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Dailycallss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDailycalls[] List of ChildDailycalls objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycalls}> List of ChildDailycalls objects
     */
    public function getDailycallssJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDailycallsQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getDailycallss($query, $con);
    }

    /**
     * Clears out the collDailycallsSgpiouts collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addDailycallsSgpiouts()
     */
    public function clearDailycallsSgpiouts()
    {
        $this->collDailycallsSgpiouts = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collDailycallsSgpiouts collection loaded partially.
     *
     * @return void
     */
    public function resetPartialDailycallsSgpiouts($v = true): void
    {
        $this->collDailycallsSgpioutsPartial = $v;
    }

    /**
     * Initializes the collDailycallsSgpiouts collection.
     *
     * By default this just sets the collDailycallsSgpiouts collection to an empty array (like clearcollDailycallsSgpiouts());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initDailycallsSgpiouts(bool $overrideExisting = true): void
    {
        if (null !== $this->collDailycallsSgpiouts && !$overrideExisting) {
            return;
        }

        $collectionClassName = DailycallsSgpioutTableMap::getTableMap()->getCollectionClassName();

        $this->collDailycallsSgpiouts = new $collectionClassName;
        $this->collDailycallsSgpiouts->setModel('\entities\DailycallsSgpiout');
    }

    /**
     * Gets an array of ChildDailycallsSgpiout objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildDailycallsSgpiout[] List of ChildDailycallsSgpiout objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycallsSgpiout> List of ChildDailycallsSgpiout objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getDailycallsSgpiouts(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collDailycallsSgpioutsPartial && !$this->isNew();
        if (null === $this->collDailycallsSgpiouts || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collDailycallsSgpiouts) {
                    $this->initDailycallsSgpiouts();
                } else {
                    $collectionClassName = DailycallsSgpioutTableMap::getTableMap()->getCollectionClassName();

                    $collDailycallsSgpiouts = new $collectionClassName;
                    $collDailycallsSgpiouts->setModel('\entities\DailycallsSgpiout');

                    return $collDailycallsSgpiouts;
                }
            } else {
                $collDailycallsSgpiouts = ChildDailycallsSgpioutQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collDailycallsSgpioutsPartial && count($collDailycallsSgpiouts)) {
                        $this->initDailycallsSgpiouts(false);

                        foreach ($collDailycallsSgpiouts as $obj) {
                            if (false == $this->collDailycallsSgpiouts->contains($obj)) {
                                $this->collDailycallsSgpiouts->append($obj);
                            }
                        }

                        $this->collDailycallsSgpioutsPartial = true;
                    }

                    return $collDailycallsSgpiouts;
                }

                if ($partial && $this->collDailycallsSgpiouts) {
                    foreach ($this->collDailycallsSgpiouts as $obj) {
                        if ($obj->isNew()) {
                            $collDailycallsSgpiouts[] = $obj;
                        }
                    }
                }

                $this->collDailycallsSgpiouts = $collDailycallsSgpiouts;
                $this->collDailycallsSgpioutsPartial = false;
            }
        }

        return $this->collDailycallsSgpiouts;
    }

    /**
     * Sets a collection of ChildDailycallsSgpiout objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $dailycallsSgpiouts A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setDailycallsSgpiouts(Collection $dailycallsSgpiouts, ?ConnectionInterface $con = null)
    {
        /** @var ChildDailycallsSgpiout[] $dailycallsSgpioutsToDelete */
        $dailycallsSgpioutsToDelete = $this->getDailycallsSgpiouts(new Criteria(), $con)->diff($dailycallsSgpiouts);


        $this->dailycallsSgpioutsScheduledForDeletion = $dailycallsSgpioutsToDelete;

        foreach ($dailycallsSgpioutsToDelete as $dailycallsSgpioutRemoved) {
            $dailycallsSgpioutRemoved->setCompany(null);
        }

        $this->collDailycallsSgpiouts = null;
        foreach ($dailycallsSgpiouts as $dailycallsSgpiout) {
            $this->addDailycallsSgpiout($dailycallsSgpiout);
        }

        $this->collDailycallsSgpiouts = $dailycallsSgpiouts;
        $this->collDailycallsSgpioutsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related DailycallsSgpiout objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related DailycallsSgpiout objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countDailycallsSgpiouts(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collDailycallsSgpioutsPartial && !$this->isNew();
        if (null === $this->collDailycallsSgpiouts || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collDailycallsSgpiouts) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getDailycallsSgpiouts());
            }

            $query = ChildDailycallsSgpioutQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collDailycallsSgpiouts);
    }

    /**
     * Method called to associate a ChildDailycallsSgpiout object to this object
     * through the ChildDailycallsSgpiout foreign key attribute.
     *
     * @param ChildDailycallsSgpiout $l ChildDailycallsSgpiout
     * @return $this The current object (for fluent API support)
     */
    public function addDailycallsSgpiout(ChildDailycallsSgpiout $l)
    {
        if ($this->collDailycallsSgpiouts === null) {
            $this->initDailycallsSgpiouts();
            $this->collDailycallsSgpioutsPartial = true;
        }

        if (!$this->collDailycallsSgpiouts->contains($l)) {
            $this->doAddDailycallsSgpiout($l);

            if ($this->dailycallsSgpioutsScheduledForDeletion and $this->dailycallsSgpioutsScheduledForDeletion->contains($l)) {
                $this->dailycallsSgpioutsScheduledForDeletion->remove($this->dailycallsSgpioutsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildDailycallsSgpiout $dailycallsSgpiout The ChildDailycallsSgpiout object to add.
     */
    protected function doAddDailycallsSgpiout(ChildDailycallsSgpiout $dailycallsSgpiout): void
    {
        $this->collDailycallsSgpiouts[]= $dailycallsSgpiout;
        $dailycallsSgpiout->setCompany($this);
    }

    /**
     * @param ChildDailycallsSgpiout $dailycallsSgpiout The ChildDailycallsSgpiout object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeDailycallsSgpiout(ChildDailycallsSgpiout $dailycallsSgpiout)
    {
        if ($this->getDailycallsSgpiouts()->contains($dailycallsSgpiout)) {
            $pos = $this->collDailycallsSgpiouts->search($dailycallsSgpiout);
            $this->collDailycallsSgpiouts->remove($pos);
            if (null === $this->dailycallsSgpioutsScheduledForDeletion) {
                $this->dailycallsSgpioutsScheduledForDeletion = clone $this->collDailycallsSgpiouts;
                $this->dailycallsSgpioutsScheduledForDeletion->clear();
            }
            $this->dailycallsSgpioutsScheduledForDeletion[]= $dailycallsSgpiout;
            $dailycallsSgpiout->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related DailycallsSgpiouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDailycallsSgpiout[] List of ChildDailycallsSgpiout objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycallsSgpiout}> List of ChildDailycallsSgpiout objects
     */
    public function getDailycallsSgpioutsJoinSgpiMaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDailycallsSgpioutQuery::create(null, $criteria);
        $query->joinWith('SgpiMaster', $joinBehavior);

        return $this->getDailycallsSgpiouts($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related DailycallsSgpiouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDailycallsSgpiout[] List of ChildDailycallsSgpiout objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycallsSgpiout}> List of ChildDailycallsSgpiout objects
     */
    public function getDailycallsSgpioutsJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDailycallsSgpioutQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getDailycallsSgpiouts($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related DailycallsSgpiouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDailycallsSgpiout[] List of ChildDailycallsSgpiout objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycallsSgpiout}> List of ChildDailycallsSgpiout objects
     */
    public function getDailycallsSgpioutsJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDailycallsSgpioutQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getDailycallsSgpiouts($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related DailycallsSgpiouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDailycallsSgpiout[] List of ChildDailycallsSgpiout objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDailycallsSgpiout}> List of ChildDailycallsSgpiout objects
     */
    public function getDailycallsSgpioutsJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDailycallsSgpioutQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getDailycallsSgpiouts($query, $con);
    }

    /**
     * Clears out the collDataExceptionLogss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addDataExceptionLogss()
     */
    public function clearDataExceptionLogss()
    {
        $this->collDataExceptionLogss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collDataExceptionLogss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialDataExceptionLogss($v = true): void
    {
        $this->collDataExceptionLogssPartial = $v;
    }

    /**
     * Initializes the collDataExceptionLogss collection.
     *
     * By default this just sets the collDataExceptionLogss collection to an empty array (like clearcollDataExceptionLogss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initDataExceptionLogss(bool $overrideExisting = true): void
    {
        if (null !== $this->collDataExceptionLogss && !$overrideExisting) {
            return;
        }

        $collectionClassName = DataExceptionLogsTableMap::getTableMap()->getCollectionClassName();

        $this->collDataExceptionLogss = new $collectionClassName;
        $this->collDataExceptionLogss->setModel('\entities\DataExceptionLogs');
    }

    /**
     * Gets an array of ChildDataExceptionLogs objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildDataExceptionLogs[] List of ChildDataExceptionLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDataExceptionLogs> List of ChildDataExceptionLogs objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getDataExceptionLogss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collDataExceptionLogssPartial && !$this->isNew();
        if (null === $this->collDataExceptionLogss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collDataExceptionLogss) {
                    $this->initDataExceptionLogss();
                } else {
                    $collectionClassName = DataExceptionLogsTableMap::getTableMap()->getCollectionClassName();

                    $collDataExceptionLogss = new $collectionClassName;
                    $collDataExceptionLogss->setModel('\entities\DataExceptionLogs');

                    return $collDataExceptionLogss;
                }
            } else {
                $collDataExceptionLogss = ChildDataExceptionLogsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collDataExceptionLogssPartial && count($collDataExceptionLogss)) {
                        $this->initDataExceptionLogss(false);

                        foreach ($collDataExceptionLogss as $obj) {
                            if (false == $this->collDataExceptionLogss->contains($obj)) {
                                $this->collDataExceptionLogss->append($obj);
                            }
                        }

                        $this->collDataExceptionLogssPartial = true;
                    }

                    return $collDataExceptionLogss;
                }

                if ($partial && $this->collDataExceptionLogss) {
                    foreach ($this->collDataExceptionLogss as $obj) {
                        if ($obj->isNew()) {
                            $collDataExceptionLogss[] = $obj;
                        }
                    }
                }

                $this->collDataExceptionLogss = $collDataExceptionLogss;
                $this->collDataExceptionLogssPartial = false;
            }
        }

        return $this->collDataExceptionLogss;
    }

    /**
     * Sets a collection of ChildDataExceptionLogs objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $dataExceptionLogss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setDataExceptionLogss(Collection $dataExceptionLogss, ?ConnectionInterface $con = null)
    {
        /** @var ChildDataExceptionLogs[] $dataExceptionLogssToDelete */
        $dataExceptionLogssToDelete = $this->getDataExceptionLogss(new Criteria(), $con)->diff($dataExceptionLogss);


        $this->dataExceptionLogssScheduledForDeletion = $dataExceptionLogssToDelete;

        foreach ($dataExceptionLogssToDelete as $dataExceptionLogsRemoved) {
            $dataExceptionLogsRemoved->setCompany(null);
        }

        $this->collDataExceptionLogss = null;
        foreach ($dataExceptionLogss as $dataExceptionLogs) {
            $this->addDataExceptionLogs($dataExceptionLogs);
        }

        $this->collDataExceptionLogss = $dataExceptionLogss;
        $this->collDataExceptionLogssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related DataExceptionLogs objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related DataExceptionLogs objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countDataExceptionLogss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collDataExceptionLogssPartial && !$this->isNew();
        if (null === $this->collDataExceptionLogss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collDataExceptionLogss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getDataExceptionLogss());
            }

            $query = ChildDataExceptionLogsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collDataExceptionLogss);
    }

    /**
     * Method called to associate a ChildDataExceptionLogs object to this object
     * through the ChildDataExceptionLogs foreign key attribute.
     *
     * @param ChildDataExceptionLogs $l ChildDataExceptionLogs
     * @return $this The current object (for fluent API support)
     */
    public function addDataExceptionLogs(ChildDataExceptionLogs $l)
    {
        if ($this->collDataExceptionLogss === null) {
            $this->initDataExceptionLogss();
            $this->collDataExceptionLogssPartial = true;
        }

        if (!$this->collDataExceptionLogss->contains($l)) {
            $this->doAddDataExceptionLogs($l);

            if ($this->dataExceptionLogssScheduledForDeletion and $this->dataExceptionLogssScheduledForDeletion->contains($l)) {
                $this->dataExceptionLogssScheduledForDeletion->remove($this->dataExceptionLogssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildDataExceptionLogs $dataExceptionLogs The ChildDataExceptionLogs object to add.
     */
    protected function doAddDataExceptionLogs(ChildDataExceptionLogs $dataExceptionLogs): void
    {
        $this->collDataExceptionLogss[]= $dataExceptionLogs;
        $dataExceptionLogs->setCompany($this);
    }

    /**
     * @param ChildDataExceptionLogs $dataExceptionLogs The ChildDataExceptionLogs object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeDataExceptionLogs(ChildDataExceptionLogs $dataExceptionLogs)
    {
        if ($this->getDataExceptionLogss()->contains($dataExceptionLogs)) {
            $pos = $this->collDataExceptionLogss->search($dataExceptionLogs);
            $this->collDataExceptionLogss->remove($pos);
            if (null === $this->dataExceptionLogssScheduledForDeletion) {
                $this->dataExceptionLogssScheduledForDeletion = clone $this->collDataExceptionLogss;
                $this->dataExceptionLogssScheduledForDeletion->clear();
            }
            $this->dataExceptionLogssScheduledForDeletion[]= $dataExceptionLogs;
            $dataExceptionLogs->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related DataExceptionLogss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildDataExceptionLogs[] List of ChildDataExceptionLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDataExceptionLogs}> List of ChildDataExceptionLogs objects
     */
    public function getDataExceptionLogssJoinDataExceptions(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildDataExceptionLogsQuery::create(null, $criteria);
        $query->joinWith('DataExceptions', $joinBehavior);

        return $this->getDataExceptionLogss($query, $con);
    }

    /**
     * Clears out the collDataExceptionss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addDataExceptionss()
     */
    public function clearDataExceptionss()
    {
        $this->collDataExceptionss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collDataExceptionss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialDataExceptionss($v = true): void
    {
        $this->collDataExceptionssPartial = $v;
    }

    /**
     * Initializes the collDataExceptionss collection.
     *
     * By default this just sets the collDataExceptionss collection to an empty array (like clearcollDataExceptionss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initDataExceptionss(bool $overrideExisting = true): void
    {
        if (null !== $this->collDataExceptionss && !$overrideExisting) {
            return;
        }

        $collectionClassName = DataExceptionsTableMap::getTableMap()->getCollectionClassName();

        $this->collDataExceptionss = new $collectionClassName;
        $this->collDataExceptionss->setModel('\entities\DataExceptions');
    }

    /**
     * Gets an array of ChildDataExceptions objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildDataExceptions[] List of ChildDataExceptions objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDataExceptions> List of ChildDataExceptions objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getDataExceptionss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collDataExceptionssPartial && !$this->isNew();
        if (null === $this->collDataExceptionss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collDataExceptionss) {
                    $this->initDataExceptionss();
                } else {
                    $collectionClassName = DataExceptionsTableMap::getTableMap()->getCollectionClassName();

                    $collDataExceptionss = new $collectionClassName;
                    $collDataExceptionss->setModel('\entities\DataExceptions');

                    return $collDataExceptionss;
                }
            } else {
                $collDataExceptionss = ChildDataExceptionsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collDataExceptionssPartial && count($collDataExceptionss)) {
                        $this->initDataExceptionss(false);

                        foreach ($collDataExceptionss as $obj) {
                            if (false == $this->collDataExceptionss->contains($obj)) {
                                $this->collDataExceptionss->append($obj);
                            }
                        }

                        $this->collDataExceptionssPartial = true;
                    }

                    return $collDataExceptionss;
                }

                if ($partial && $this->collDataExceptionss) {
                    foreach ($this->collDataExceptionss as $obj) {
                        if ($obj->isNew()) {
                            $collDataExceptionss[] = $obj;
                        }
                    }
                }

                $this->collDataExceptionss = $collDataExceptionss;
                $this->collDataExceptionssPartial = false;
            }
        }

        return $this->collDataExceptionss;
    }

    /**
     * Sets a collection of ChildDataExceptions objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $dataExceptionss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setDataExceptionss(Collection $dataExceptionss, ?ConnectionInterface $con = null)
    {
        /** @var ChildDataExceptions[] $dataExceptionssToDelete */
        $dataExceptionssToDelete = $this->getDataExceptionss(new Criteria(), $con)->diff($dataExceptionss);


        $this->dataExceptionssScheduledForDeletion = $dataExceptionssToDelete;

        foreach ($dataExceptionssToDelete as $dataExceptionsRemoved) {
            $dataExceptionsRemoved->setCompany(null);
        }

        $this->collDataExceptionss = null;
        foreach ($dataExceptionss as $dataExceptions) {
            $this->addDataExceptions($dataExceptions);
        }

        $this->collDataExceptionss = $dataExceptionss;
        $this->collDataExceptionssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related DataExceptions objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related DataExceptions objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countDataExceptionss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collDataExceptionssPartial && !$this->isNew();
        if (null === $this->collDataExceptionss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collDataExceptionss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getDataExceptionss());
            }

            $query = ChildDataExceptionsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collDataExceptionss);
    }

    /**
     * Method called to associate a ChildDataExceptions object to this object
     * through the ChildDataExceptions foreign key attribute.
     *
     * @param ChildDataExceptions $l ChildDataExceptions
     * @return $this The current object (for fluent API support)
     */
    public function addDataExceptions(ChildDataExceptions $l)
    {
        if ($this->collDataExceptionss === null) {
            $this->initDataExceptionss();
            $this->collDataExceptionssPartial = true;
        }

        if (!$this->collDataExceptionss->contains($l)) {
            $this->doAddDataExceptions($l);

            if ($this->dataExceptionssScheduledForDeletion and $this->dataExceptionssScheduledForDeletion->contains($l)) {
                $this->dataExceptionssScheduledForDeletion->remove($this->dataExceptionssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildDataExceptions $dataExceptions The ChildDataExceptions object to add.
     */
    protected function doAddDataExceptions(ChildDataExceptions $dataExceptions): void
    {
        $this->collDataExceptionss[]= $dataExceptions;
        $dataExceptions->setCompany($this);
    }

    /**
     * @param ChildDataExceptions $dataExceptions The ChildDataExceptions object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeDataExceptions(ChildDataExceptions $dataExceptions)
    {
        if ($this->getDataExceptionss()->contains($dataExceptions)) {
            $pos = $this->collDataExceptionss->search($dataExceptions);
            $this->collDataExceptionss->remove($pos);
            if (null === $this->dataExceptionssScheduledForDeletion) {
                $this->dataExceptionssScheduledForDeletion = clone $this->collDataExceptionss;
                $this->dataExceptionssScheduledForDeletion->clear();
            }
            $this->dataExceptionssScheduledForDeletion[]= $dataExceptions;
            $dataExceptions->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collDesignationss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addDesignationss()
     */
    public function clearDesignationss()
    {
        $this->collDesignationss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collDesignationss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialDesignationss($v = true): void
    {
        $this->collDesignationssPartial = $v;
    }

    /**
     * Initializes the collDesignationss collection.
     *
     * By default this just sets the collDesignationss collection to an empty array (like clearcollDesignationss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initDesignationss(bool $overrideExisting = true): void
    {
        if (null !== $this->collDesignationss && !$overrideExisting) {
            return;
        }

        $collectionClassName = DesignationsTableMap::getTableMap()->getCollectionClassName();

        $this->collDesignationss = new $collectionClassName;
        $this->collDesignationss->setModel('\entities\Designations');
    }

    /**
     * Gets an array of ChildDesignations objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildDesignations[] List of ChildDesignations objects
     * @phpstan-return ObjectCollection&\Traversable<ChildDesignations> List of ChildDesignations objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getDesignationss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collDesignationssPartial && !$this->isNew();
        if (null === $this->collDesignationss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collDesignationss) {
                    $this->initDesignationss();
                } else {
                    $collectionClassName = DesignationsTableMap::getTableMap()->getCollectionClassName();

                    $collDesignationss = new $collectionClassName;
                    $collDesignationss->setModel('\entities\Designations');

                    return $collDesignationss;
                }
            } else {
                $collDesignationss = ChildDesignationsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collDesignationssPartial && count($collDesignationss)) {
                        $this->initDesignationss(false);

                        foreach ($collDesignationss as $obj) {
                            if (false == $this->collDesignationss->contains($obj)) {
                                $this->collDesignationss->append($obj);
                            }
                        }

                        $this->collDesignationssPartial = true;
                    }

                    return $collDesignationss;
                }

                if ($partial && $this->collDesignationss) {
                    foreach ($this->collDesignationss as $obj) {
                        if ($obj->isNew()) {
                            $collDesignationss[] = $obj;
                        }
                    }
                }

                $this->collDesignationss = $collDesignationss;
                $this->collDesignationssPartial = false;
            }
        }

        return $this->collDesignationss;
    }

    /**
     * Sets a collection of ChildDesignations objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $designationss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setDesignationss(Collection $designationss, ?ConnectionInterface $con = null)
    {
        /** @var ChildDesignations[] $designationssToDelete */
        $designationssToDelete = $this->getDesignationss(new Criteria(), $con)->diff($designationss);


        $this->designationssScheduledForDeletion = $designationssToDelete;

        foreach ($designationssToDelete as $designationsRemoved) {
            $designationsRemoved->setCompany(null);
        }

        $this->collDesignationss = null;
        foreach ($designationss as $designations) {
            $this->addDesignations($designations);
        }

        $this->collDesignationss = $designationss;
        $this->collDesignationssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Designations objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Designations objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countDesignationss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collDesignationssPartial && !$this->isNew();
        if (null === $this->collDesignationss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collDesignationss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getDesignationss());
            }

            $query = ChildDesignationsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collDesignationss);
    }

    /**
     * Method called to associate a ChildDesignations object to this object
     * through the ChildDesignations foreign key attribute.
     *
     * @param ChildDesignations $l ChildDesignations
     * @return $this The current object (for fluent API support)
     */
    public function addDesignations(ChildDesignations $l)
    {
        if ($this->collDesignationss === null) {
            $this->initDesignationss();
            $this->collDesignationssPartial = true;
        }

        if (!$this->collDesignationss->contains($l)) {
            $this->doAddDesignations($l);

            if ($this->designationssScheduledForDeletion and $this->designationssScheduledForDeletion->contains($l)) {
                $this->designationssScheduledForDeletion->remove($this->designationssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildDesignations $designations The ChildDesignations object to add.
     */
    protected function doAddDesignations(ChildDesignations $designations): void
    {
        $this->collDesignationss[]= $designations;
        $designations->setCompany($this);
    }

    /**
     * @param ChildDesignations $designations The ChildDesignations object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeDesignations(ChildDesignations $designations)
    {
        if ($this->getDesignationss()->contains($designations)) {
            $pos = $this->collDesignationss->search($designations);
            $this->collDesignationss->remove($pos);
            if (null === $this->designationssScheduledForDeletion) {
                $this->designationssScheduledForDeletion = clone $this->collDesignationss;
                $this->designationssScheduledForDeletion->clear();
            }
            $this->designationssScheduledForDeletion[]= $designations;
            $designations->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collEdFeedbackss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEdFeedbackss()
     */
    public function clearEdFeedbackss()
    {
        $this->collEdFeedbackss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEdFeedbackss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEdFeedbackss($v = true): void
    {
        $this->collEdFeedbackssPartial = $v;
    }

    /**
     * Initializes the collEdFeedbackss collection.
     *
     * By default this just sets the collEdFeedbackss collection to an empty array (like clearcollEdFeedbackss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEdFeedbackss(bool $overrideExisting = true): void
    {
        if (null !== $this->collEdFeedbackss && !$overrideExisting) {
            return;
        }

        $collectionClassName = EdFeedbacksTableMap::getTableMap()->getCollectionClassName();

        $this->collEdFeedbackss = new $collectionClassName;
        $this->collEdFeedbackss->setModel('\entities\EdFeedbacks');
    }

    /**
     * Gets an array of ChildEdFeedbacks objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEdFeedbacks[] List of ChildEdFeedbacks objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdFeedbacks> List of ChildEdFeedbacks objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEdFeedbackss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEdFeedbackssPartial && !$this->isNew();
        if (null === $this->collEdFeedbackss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEdFeedbackss) {
                    $this->initEdFeedbackss();
                } else {
                    $collectionClassName = EdFeedbacksTableMap::getTableMap()->getCollectionClassName();

                    $collEdFeedbackss = new $collectionClassName;
                    $collEdFeedbackss->setModel('\entities\EdFeedbacks');

                    return $collEdFeedbackss;
                }
            } else {
                $collEdFeedbackss = ChildEdFeedbacksQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEdFeedbackssPartial && count($collEdFeedbackss)) {
                        $this->initEdFeedbackss(false);

                        foreach ($collEdFeedbackss as $obj) {
                            if (false == $this->collEdFeedbackss->contains($obj)) {
                                $this->collEdFeedbackss->append($obj);
                            }
                        }

                        $this->collEdFeedbackssPartial = true;
                    }

                    return $collEdFeedbackss;
                }

                if ($partial && $this->collEdFeedbackss) {
                    foreach ($this->collEdFeedbackss as $obj) {
                        if ($obj->isNew()) {
                            $collEdFeedbackss[] = $obj;
                        }
                    }
                }

                $this->collEdFeedbackss = $collEdFeedbackss;
                $this->collEdFeedbackssPartial = false;
            }
        }

        return $this->collEdFeedbackss;
    }

    /**
     * Sets a collection of ChildEdFeedbacks objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $edFeedbackss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEdFeedbackss(Collection $edFeedbackss, ?ConnectionInterface $con = null)
    {
        /** @var ChildEdFeedbacks[] $edFeedbackssToDelete */
        $edFeedbackssToDelete = $this->getEdFeedbackss(new Criteria(), $con)->diff($edFeedbackss);


        $this->edFeedbackssScheduledForDeletion = $edFeedbackssToDelete;

        foreach ($edFeedbackssToDelete as $edFeedbacksRemoved) {
            $edFeedbacksRemoved->setCompany(null);
        }

        $this->collEdFeedbackss = null;
        foreach ($edFeedbackss as $edFeedbacks) {
            $this->addEdFeedbacks($edFeedbacks);
        }

        $this->collEdFeedbackss = $edFeedbackss;
        $this->collEdFeedbackssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related EdFeedbacks objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related EdFeedbacks objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEdFeedbackss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEdFeedbackssPartial && !$this->isNew();
        if (null === $this->collEdFeedbackss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEdFeedbackss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEdFeedbackss());
            }

            $query = ChildEdFeedbacksQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEdFeedbackss);
    }

    /**
     * Method called to associate a ChildEdFeedbacks object to this object
     * through the ChildEdFeedbacks foreign key attribute.
     *
     * @param ChildEdFeedbacks $l ChildEdFeedbacks
     * @return $this The current object (for fluent API support)
     */
    public function addEdFeedbacks(ChildEdFeedbacks $l)
    {
        if ($this->collEdFeedbackss === null) {
            $this->initEdFeedbackss();
            $this->collEdFeedbackssPartial = true;
        }

        if (!$this->collEdFeedbackss->contains($l)) {
            $this->doAddEdFeedbacks($l);

            if ($this->edFeedbackssScheduledForDeletion and $this->edFeedbackssScheduledForDeletion->contains($l)) {
                $this->edFeedbackssScheduledForDeletion->remove($this->edFeedbackssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEdFeedbacks $edFeedbacks The ChildEdFeedbacks object to add.
     */
    protected function doAddEdFeedbacks(ChildEdFeedbacks $edFeedbacks): void
    {
        $this->collEdFeedbackss[]= $edFeedbacks;
        $edFeedbacks->setCompany($this);
    }

    /**
     * @param ChildEdFeedbacks $edFeedbacks The ChildEdFeedbacks object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEdFeedbacks(ChildEdFeedbacks $edFeedbacks)
    {
        if ($this->getEdFeedbackss()->contains($edFeedbacks)) {
            $pos = $this->collEdFeedbackss->search($edFeedbacks);
            $this->collEdFeedbackss->remove($pos);
            if (null === $this->edFeedbackssScheduledForDeletion) {
                $this->edFeedbackssScheduledForDeletion = clone $this->collEdFeedbackss;
                $this->edFeedbackssScheduledForDeletion->clear();
            }
            $this->edFeedbackssScheduledForDeletion[]= $edFeedbacks;
            $edFeedbacks->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdFeedbackss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdFeedbacks[] List of ChildEdFeedbacks objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdFeedbacks}> List of ChildEdFeedbacks objects
     */
    public function getEdFeedbackssJoinEdPresentations(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdFeedbacksQuery::create(null, $criteria);
        $query->joinWith('EdPresentations', $joinBehavior);

        return $this->getEdFeedbackss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdFeedbackss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdFeedbacks[] List of ChildEdFeedbacks objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdFeedbacks}> List of ChildEdFeedbacks objects
     */
    public function getEdFeedbackssJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdFeedbacksQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getEdFeedbackss($query, $con);
    }

    /**
     * Clears out the collEdPlaylists collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEdPlaylists()
     */
    public function clearEdPlaylists()
    {
        $this->collEdPlaylists = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEdPlaylists collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEdPlaylists($v = true): void
    {
        $this->collEdPlaylistsPartial = $v;
    }

    /**
     * Initializes the collEdPlaylists collection.
     *
     * By default this just sets the collEdPlaylists collection to an empty array (like clearcollEdPlaylists());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEdPlaylists(bool $overrideExisting = true): void
    {
        if (null !== $this->collEdPlaylists && !$overrideExisting) {
            return;
        }

        $collectionClassName = EdPlaylistTableMap::getTableMap()->getCollectionClassName();

        $this->collEdPlaylists = new $collectionClassName;
        $this->collEdPlaylists->setModel('\entities\EdPlaylist');
    }

    /**
     * Gets an array of ChildEdPlaylist objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEdPlaylist[] List of ChildEdPlaylist objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdPlaylist> List of ChildEdPlaylist objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEdPlaylists(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEdPlaylistsPartial && !$this->isNew();
        if (null === $this->collEdPlaylists || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEdPlaylists) {
                    $this->initEdPlaylists();
                } else {
                    $collectionClassName = EdPlaylistTableMap::getTableMap()->getCollectionClassName();

                    $collEdPlaylists = new $collectionClassName;
                    $collEdPlaylists->setModel('\entities\EdPlaylist');

                    return $collEdPlaylists;
                }
            } else {
                $collEdPlaylists = ChildEdPlaylistQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEdPlaylistsPartial && count($collEdPlaylists)) {
                        $this->initEdPlaylists(false);

                        foreach ($collEdPlaylists as $obj) {
                            if (false == $this->collEdPlaylists->contains($obj)) {
                                $this->collEdPlaylists->append($obj);
                            }
                        }

                        $this->collEdPlaylistsPartial = true;
                    }

                    return $collEdPlaylists;
                }

                if ($partial && $this->collEdPlaylists) {
                    foreach ($this->collEdPlaylists as $obj) {
                        if ($obj->isNew()) {
                            $collEdPlaylists[] = $obj;
                        }
                    }
                }

                $this->collEdPlaylists = $collEdPlaylists;
                $this->collEdPlaylistsPartial = false;
            }
        }

        return $this->collEdPlaylists;
    }

    /**
     * Sets a collection of ChildEdPlaylist objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $edPlaylists A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEdPlaylists(Collection $edPlaylists, ?ConnectionInterface $con = null)
    {
        /** @var ChildEdPlaylist[] $edPlaylistsToDelete */
        $edPlaylistsToDelete = $this->getEdPlaylists(new Criteria(), $con)->diff($edPlaylists);


        $this->edPlaylistsScheduledForDeletion = $edPlaylistsToDelete;

        foreach ($edPlaylistsToDelete as $edPlaylistRemoved) {
            $edPlaylistRemoved->setCompany(null);
        }

        $this->collEdPlaylists = null;
        foreach ($edPlaylists as $edPlaylist) {
            $this->addEdPlaylist($edPlaylist);
        }

        $this->collEdPlaylists = $edPlaylists;
        $this->collEdPlaylistsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related EdPlaylist objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related EdPlaylist objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEdPlaylists(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEdPlaylistsPartial && !$this->isNew();
        if (null === $this->collEdPlaylists || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEdPlaylists) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEdPlaylists());
            }

            $query = ChildEdPlaylistQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEdPlaylists);
    }

    /**
     * Method called to associate a ChildEdPlaylist object to this object
     * through the ChildEdPlaylist foreign key attribute.
     *
     * @param ChildEdPlaylist $l ChildEdPlaylist
     * @return $this The current object (for fluent API support)
     */
    public function addEdPlaylist(ChildEdPlaylist $l)
    {
        if ($this->collEdPlaylists === null) {
            $this->initEdPlaylists();
            $this->collEdPlaylistsPartial = true;
        }

        if (!$this->collEdPlaylists->contains($l)) {
            $this->doAddEdPlaylist($l);

            if ($this->edPlaylistsScheduledForDeletion and $this->edPlaylistsScheduledForDeletion->contains($l)) {
                $this->edPlaylistsScheduledForDeletion->remove($this->edPlaylistsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEdPlaylist $edPlaylist The ChildEdPlaylist object to add.
     */
    protected function doAddEdPlaylist(ChildEdPlaylist $edPlaylist): void
    {
        $this->collEdPlaylists[]= $edPlaylist;
        $edPlaylist->setCompany($this);
    }

    /**
     * @param ChildEdPlaylist $edPlaylist The ChildEdPlaylist object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEdPlaylist(ChildEdPlaylist $edPlaylist)
    {
        if ($this->getEdPlaylists()->contains($edPlaylist)) {
            $pos = $this->collEdPlaylists->search($edPlaylist);
            $this->collEdPlaylists->remove($pos);
            if (null === $this->edPlaylistsScheduledForDeletion) {
                $this->edPlaylistsScheduledForDeletion = clone $this->collEdPlaylists;
                $this->edPlaylistsScheduledForDeletion->clear();
            }
            $this->edPlaylistsScheduledForDeletion[]= clone $edPlaylist;
            $edPlaylist->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdPlaylists from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdPlaylist[] List of ChildEdPlaylist objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdPlaylist}> List of ChildEdPlaylist objects
     */
    public function getEdPlaylistsJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdPlaylistQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getEdPlaylists($query, $con);
    }

    /**
     * Clears out the collEdPresentationss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEdPresentationss()
     */
    public function clearEdPresentationss()
    {
        $this->collEdPresentationss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEdPresentationss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEdPresentationss($v = true): void
    {
        $this->collEdPresentationssPartial = $v;
    }

    /**
     * Initializes the collEdPresentationss collection.
     *
     * By default this just sets the collEdPresentationss collection to an empty array (like clearcollEdPresentationss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEdPresentationss(bool $overrideExisting = true): void
    {
        if (null !== $this->collEdPresentationss && !$overrideExisting) {
            return;
        }

        $collectionClassName = EdPresentationsTableMap::getTableMap()->getCollectionClassName();

        $this->collEdPresentationss = new $collectionClassName;
        $this->collEdPresentationss->setModel('\entities\EdPresentations');
    }

    /**
     * Gets an array of ChildEdPresentations objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEdPresentations[] List of ChildEdPresentations objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdPresentations> List of ChildEdPresentations objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEdPresentationss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEdPresentationssPartial && !$this->isNew();
        if (null === $this->collEdPresentationss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEdPresentationss) {
                    $this->initEdPresentationss();
                } else {
                    $collectionClassName = EdPresentationsTableMap::getTableMap()->getCollectionClassName();

                    $collEdPresentationss = new $collectionClassName;
                    $collEdPresentationss->setModel('\entities\EdPresentations');

                    return $collEdPresentationss;
                }
            } else {
                $collEdPresentationss = ChildEdPresentationsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEdPresentationssPartial && count($collEdPresentationss)) {
                        $this->initEdPresentationss(false);

                        foreach ($collEdPresentationss as $obj) {
                            if (false == $this->collEdPresentationss->contains($obj)) {
                                $this->collEdPresentationss->append($obj);
                            }
                        }

                        $this->collEdPresentationssPartial = true;
                    }

                    return $collEdPresentationss;
                }

                if ($partial && $this->collEdPresentationss) {
                    foreach ($this->collEdPresentationss as $obj) {
                        if ($obj->isNew()) {
                            $collEdPresentationss[] = $obj;
                        }
                    }
                }

                $this->collEdPresentationss = $collEdPresentationss;
                $this->collEdPresentationssPartial = false;
            }
        }

        return $this->collEdPresentationss;
    }

    /**
     * Sets a collection of ChildEdPresentations objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $edPresentationss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEdPresentationss(Collection $edPresentationss, ?ConnectionInterface $con = null)
    {
        /** @var ChildEdPresentations[] $edPresentationssToDelete */
        $edPresentationssToDelete = $this->getEdPresentationss(new Criteria(), $con)->diff($edPresentationss);


        $this->edPresentationssScheduledForDeletion = $edPresentationssToDelete;

        foreach ($edPresentationssToDelete as $edPresentationsRemoved) {
            $edPresentationsRemoved->setCompany(null);
        }

        $this->collEdPresentationss = null;
        foreach ($edPresentationss as $edPresentations) {
            $this->addEdPresentations($edPresentations);
        }

        $this->collEdPresentationss = $edPresentationss;
        $this->collEdPresentationssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related EdPresentations objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related EdPresentations objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEdPresentationss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEdPresentationssPartial && !$this->isNew();
        if (null === $this->collEdPresentationss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEdPresentationss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEdPresentationss());
            }

            $query = ChildEdPresentationsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEdPresentationss);
    }

    /**
     * Method called to associate a ChildEdPresentations object to this object
     * through the ChildEdPresentations foreign key attribute.
     *
     * @param ChildEdPresentations $l ChildEdPresentations
     * @return $this The current object (for fluent API support)
     */
    public function addEdPresentations(ChildEdPresentations $l)
    {
        if ($this->collEdPresentationss === null) {
            $this->initEdPresentationss();
            $this->collEdPresentationssPartial = true;
        }

        if (!$this->collEdPresentationss->contains($l)) {
            $this->doAddEdPresentations($l);

            if ($this->edPresentationssScheduledForDeletion and $this->edPresentationssScheduledForDeletion->contains($l)) {
                $this->edPresentationssScheduledForDeletion->remove($this->edPresentationssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEdPresentations $edPresentations The ChildEdPresentations object to add.
     */
    protected function doAddEdPresentations(ChildEdPresentations $edPresentations): void
    {
        $this->collEdPresentationss[]= $edPresentations;
        $edPresentations->setCompany($this);
    }

    /**
     * @param ChildEdPresentations $edPresentations The ChildEdPresentations object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEdPresentations(ChildEdPresentations $edPresentations)
    {
        if ($this->getEdPresentationss()->contains($edPresentations)) {
            $pos = $this->collEdPresentationss->search($edPresentations);
            $this->collEdPresentationss->remove($pos);
            if (null === $this->edPresentationssScheduledForDeletion) {
                $this->edPresentationssScheduledForDeletion = clone $this->collEdPresentationss;
                $this->edPresentationssScheduledForDeletion->clear();
            }
            $this->edPresentationssScheduledForDeletion[]= clone $edPresentations;
            $edPresentations->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdPresentationss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdPresentations[] List of ChildEdPresentations objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdPresentations}> List of ChildEdPresentations objects
     */
    public function getEdPresentationssJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdPresentationsQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getEdPresentationss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdPresentationss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdPresentations[] List of ChildEdPresentations objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdPresentations}> List of ChildEdPresentations objects
     */
    public function getEdPresentationssJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdPresentationsQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getEdPresentationss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdPresentationss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdPresentations[] List of ChildEdPresentations objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdPresentations}> List of ChildEdPresentations objects
     */
    public function getEdPresentationssJoinLanguage(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdPresentationsQuery::create(null, $criteria);
        $query->joinWith('Language', $joinBehavior);

        return $this->getEdPresentationss($query, $con);
    }

    /**
     * Clears out the collEdSessions collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEdSessions()
     */
    public function clearEdSessions()
    {
        $this->collEdSessions = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEdSessions collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEdSessions($v = true): void
    {
        $this->collEdSessionsPartial = $v;
    }

    /**
     * Initializes the collEdSessions collection.
     *
     * By default this just sets the collEdSessions collection to an empty array (like clearcollEdSessions());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEdSessions(bool $overrideExisting = true): void
    {
        if (null !== $this->collEdSessions && !$overrideExisting) {
            return;
        }

        $collectionClassName = EdSessionTableMap::getTableMap()->getCollectionClassName();

        $this->collEdSessions = new $collectionClassName;
        $this->collEdSessions->setModel('\entities\EdSession');
    }

    /**
     * Gets an array of ChildEdSession objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEdSession[] List of ChildEdSession objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdSession> List of ChildEdSession objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEdSessions(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEdSessionsPartial && !$this->isNew();
        if (null === $this->collEdSessions || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEdSessions) {
                    $this->initEdSessions();
                } else {
                    $collectionClassName = EdSessionTableMap::getTableMap()->getCollectionClassName();

                    $collEdSessions = new $collectionClassName;
                    $collEdSessions->setModel('\entities\EdSession');

                    return $collEdSessions;
                }
            } else {
                $collEdSessions = ChildEdSessionQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEdSessionsPartial && count($collEdSessions)) {
                        $this->initEdSessions(false);

                        foreach ($collEdSessions as $obj) {
                            if (false == $this->collEdSessions->contains($obj)) {
                                $this->collEdSessions->append($obj);
                            }
                        }

                        $this->collEdSessionsPartial = true;
                    }

                    return $collEdSessions;
                }

                if ($partial && $this->collEdSessions) {
                    foreach ($this->collEdSessions as $obj) {
                        if ($obj->isNew()) {
                            $collEdSessions[] = $obj;
                        }
                    }
                }

                $this->collEdSessions = $collEdSessions;
                $this->collEdSessionsPartial = false;
            }
        }

        return $this->collEdSessions;
    }

    /**
     * Sets a collection of ChildEdSession objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $edSessions A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEdSessions(Collection $edSessions, ?ConnectionInterface $con = null)
    {
        /** @var ChildEdSession[] $edSessionsToDelete */
        $edSessionsToDelete = $this->getEdSessions(new Criteria(), $con)->diff($edSessions);


        $this->edSessionsScheduledForDeletion = $edSessionsToDelete;

        foreach ($edSessionsToDelete as $edSessionRemoved) {
            $edSessionRemoved->setCompany(null);
        }

        $this->collEdSessions = null;
        foreach ($edSessions as $edSession) {
            $this->addEdSession($edSession);
        }

        $this->collEdSessions = $edSessions;
        $this->collEdSessionsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related EdSession objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related EdSession objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEdSessions(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEdSessionsPartial && !$this->isNew();
        if (null === $this->collEdSessions || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEdSessions) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEdSessions());
            }

            $query = ChildEdSessionQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEdSessions);
    }

    /**
     * Method called to associate a ChildEdSession object to this object
     * through the ChildEdSession foreign key attribute.
     *
     * @param ChildEdSession $l ChildEdSession
     * @return $this The current object (for fluent API support)
     */
    public function addEdSession(ChildEdSession $l)
    {
        if ($this->collEdSessions === null) {
            $this->initEdSessions();
            $this->collEdSessionsPartial = true;
        }

        if (!$this->collEdSessions->contains($l)) {
            $this->doAddEdSession($l);

            if ($this->edSessionsScheduledForDeletion and $this->edSessionsScheduledForDeletion->contains($l)) {
                $this->edSessionsScheduledForDeletion->remove($this->edSessionsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEdSession $edSession The ChildEdSession object to add.
     */
    protected function doAddEdSession(ChildEdSession $edSession): void
    {
        $this->collEdSessions[]= $edSession;
        $edSession->setCompany($this);
    }

    /**
     * @param ChildEdSession $edSession The ChildEdSession object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEdSession(ChildEdSession $edSession)
    {
        if ($this->getEdSessions()->contains($edSession)) {
            $pos = $this->collEdSessions->search($edSession);
            $this->collEdSessions->remove($pos);
            if (null === $this->edSessionsScheduledForDeletion) {
                $this->edSessionsScheduledForDeletion = clone $this->collEdSessions;
                $this->edSessionsScheduledForDeletion->clear();
            }
            $this->edSessionsScheduledForDeletion[]= $edSession;
            $edSession->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdSessions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdSession[] List of ChildEdSession objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdSession}> List of ChildEdSession objects
     */
    public function getEdSessionsJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdSessionQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getEdSessions($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdSessions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdSession[] List of ChildEdSession objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdSession}> List of ChildEdSession objects
     */
    public function getEdSessionsJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdSessionQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getEdSessions($query, $con);
    }

    /**
     * Clears out the collEdStatss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEdStatss()
     */
    public function clearEdStatss()
    {
        $this->collEdStatss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEdStatss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEdStatss($v = true): void
    {
        $this->collEdStatssPartial = $v;
    }

    /**
     * Initializes the collEdStatss collection.
     *
     * By default this just sets the collEdStatss collection to an empty array (like clearcollEdStatss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEdStatss(bool $overrideExisting = true): void
    {
        if (null !== $this->collEdStatss && !$overrideExisting) {
            return;
        }

        $collectionClassName = EdStatsTableMap::getTableMap()->getCollectionClassName();

        $this->collEdStatss = new $collectionClassName;
        $this->collEdStatss->setModel('\entities\EdStats');
    }

    /**
     * Gets an array of ChildEdStats objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEdStats[] List of ChildEdStats objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdStats> List of ChildEdStats objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEdStatss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEdStatssPartial && !$this->isNew();
        if (null === $this->collEdStatss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEdStatss) {
                    $this->initEdStatss();
                } else {
                    $collectionClassName = EdStatsTableMap::getTableMap()->getCollectionClassName();

                    $collEdStatss = new $collectionClassName;
                    $collEdStatss->setModel('\entities\EdStats');

                    return $collEdStatss;
                }
            } else {
                $collEdStatss = ChildEdStatsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEdStatssPartial && count($collEdStatss)) {
                        $this->initEdStatss(false);

                        foreach ($collEdStatss as $obj) {
                            if (false == $this->collEdStatss->contains($obj)) {
                                $this->collEdStatss->append($obj);
                            }
                        }

                        $this->collEdStatssPartial = true;
                    }

                    return $collEdStatss;
                }

                if ($partial && $this->collEdStatss) {
                    foreach ($this->collEdStatss as $obj) {
                        if ($obj->isNew()) {
                            $collEdStatss[] = $obj;
                        }
                    }
                }

                $this->collEdStatss = $collEdStatss;
                $this->collEdStatssPartial = false;
            }
        }

        return $this->collEdStatss;
    }

    /**
     * Sets a collection of ChildEdStats objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $edStatss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEdStatss(Collection $edStatss, ?ConnectionInterface $con = null)
    {
        /** @var ChildEdStats[] $edStatssToDelete */
        $edStatssToDelete = $this->getEdStatss(new Criteria(), $con)->diff($edStatss);


        $this->edStatssScheduledForDeletion = $edStatssToDelete;

        foreach ($edStatssToDelete as $edStatsRemoved) {
            $edStatsRemoved->setCompany(null);
        }

        $this->collEdStatss = null;
        foreach ($edStatss as $edStats) {
            $this->addEdStats($edStats);
        }

        $this->collEdStatss = $edStatss;
        $this->collEdStatssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related EdStats objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related EdStats objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEdStatss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEdStatssPartial && !$this->isNew();
        if (null === $this->collEdStatss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEdStatss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEdStatss());
            }

            $query = ChildEdStatsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEdStatss);
    }

    /**
     * Method called to associate a ChildEdStats object to this object
     * through the ChildEdStats foreign key attribute.
     *
     * @param ChildEdStats $l ChildEdStats
     * @return $this The current object (for fluent API support)
     */
    public function addEdStats(ChildEdStats $l)
    {
        if ($this->collEdStatss === null) {
            $this->initEdStatss();
            $this->collEdStatssPartial = true;
        }

        if (!$this->collEdStatss->contains($l)) {
            $this->doAddEdStats($l);

            if ($this->edStatssScheduledForDeletion and $this->edStatssScheduledForDeletion->contains($l)) {
                $this->edStatssScheduledForDeletion->remove($this->edStatssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEdStats $edStats The ChildEdStats object to add.
     */
    protected function doAddEdStats(ChildEdStats $edStats): void
    {
        $this->collEdStatss[]= $edStats;
        $edStats->setCompany($this);
    }

    /**
     * @param ChildEdStats $edStats The ChildEdStats object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEdStats(ChildEdStats $edStats)
    {
        if ($this->getEdStatss()->contains($edStats)) {
            $pos = $this->collEdStatss->search($edStats);
            $this->collEdStatss->remove($pos);
            if (null === $this->edStatssScheduledForDeletion) {
                $this->edStatssScheduledForDeletion = clone $this->collEdStatss;
                $this->edStatssScheduledForDeletion->clear();
            }
            $this->edStatssScheduledForDeletion[]= clone $edStats;
            $edStats->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdStatss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdStats[] List of ChildEdStats objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdStats}> List of ChildEdStats objects
     */
    public function getEdStatssJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdStatsQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getEdStatss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdStatss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdStats[] List of ChildEdStats objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdStats}> List of ChildEdStats objects
     */
    public function getEdStatssJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdStatsQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getEdStatss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EdStatss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEdStats[] List of ChildEdStats objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEdStats}> List of ChildEdStats objects
     */
    public function getEdStatssJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEdStatsQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getEdStatss($query, $con);
    }

    /**
     * Clears out the collEmployees collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEmployees()
     */
    public function clearEmployees()
    {
        $this->collEmployees = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEmployees collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEmployees($v = true): void
    {
        $this->collEmployeesPartial = $v;
    }

    /**
     * Initializes the collEmployees collection.
     *
     * By default this just sets the collEmployees collection to an empty array (like clearcollEmployees());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEmployees(bool $overrideExisting = true): void
    {
        if (null !== $this->collEmployees && !$overrideExisting) {
            return;
        }

        $collectionClassName = EmployeeTableMap::getTableMap()->getCollectionClassName();

        $this->collEmployees = new $collectionClassName;
        $this->collEmployees->setModel('\entities\Employee');
    }

    /**
     * Gets an array of ChildEmployee objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEmployee[] List of ChildEmployee objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployee> List of ChildEmployee objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEmployees(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEmployeesPartial && !$this->isNew();
        if (null === $this->collEmployees || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEmployees) {
                    $this->initEmployees();
                } else {
                    $collectionClassName = EmployeeTableMap::getTableMap()->getCollectionClassName();

                    $collEmployees = new $collectionClassName;
                    $collEmployees->setModel('\entities\Employee');

                    return $collEmployees;
                }
            } else {
                $collEmployees = ChildEmployeeQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEmployeesPartial && count($collEmployees)) {
                        $this->initEmployees(false);

                        foreach ($collEmployees as $obj) {
                            if (false == $this->collEmployees->contains($obj)) {
                                $this->collEmployees->append($obj);
                            }
                        }

                        $this->collEmployeesPartial = true;
                    }

                    return $collEmployees;
                }

                if ($partial && $this->collEmployees) {
                    foreach ($this->collEmployees as $obj) {
                        if ($obj->isNew()) {
                            $collEmployees[] = $obj;
                        }
                    }
                }

                $this->collEmployees = $collEmployees;
                $this->collEmployeesPartial = false;
            }
        }

        return $this->collEmployees;
    }

    /**
     * Sets a collection of ChildEmployee objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $employees A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEmployees(Collection $employees, ?ConnectionInterface $con = null)
    {
        /** @var ChildEmployee[] $employeesToDelete */
        $employeesToDelete = $this->getEmployees(new Criteria(), $con)->diff($employees);


        $this->employeesScheduledForDeletion = $employeesToDelete;

        foreach ($employeesToDelete as $employeeRemoved) {
            $employeeRemoved->setCompany(null);
        }

        $this->collEmployees = null;
        foreach ($employees as $employee) {
            $this->addEmployee($employee);
        }

        $this->collEmployees = $employees;
        $this->collEmployeesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Employee objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Employee objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEmployees(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEmployeesPartial && !$this->isNew();
        if (null === $this->collEmployees || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEmployees) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEmployees());
            }

            $query = ChildEmployeeQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEmployees);
    }

    /**
     * Method called to associate a ChildEmployee object to this object
     * through the ChildEmployee foreign key attribute.
     *
     * @param ChildEmployee $l ChildEmployee
     * @return $this The current object (for fluent API support)
     */
    public function addEmployee(ChildEmployee $l)
    {
        if ($this->collEmployees === null) {
            $this->initEmployees();
            $this->collEmployeesPartial = true;
        }

        if (!$this->collEmployees->contains($l)) {
            $this->doAddEmployee($l);

            if ($this->employeesScheduledForDeletion and $this->employeesScheduledForDeletion->contains($l)) {
                $this->employeesScheduledForDeletion->remove($this->employeesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEmployee $employee The ChildEmployee object to add.
     */
    protected function doAddEmployee(ChildEmployee $employee): void
    {
        $this->collEmployees[]= $employee;
        $employee->setCompany($this);
    }

    /**
     * @param ChildEmployee $employee The ChildEmployee object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEmployee(ChildEmployee $employee)
    {
        if ($this->getEmployees()->contains($employee)) {
            $pos = $this->collEmployees->search($employee);
            $this->collEmployees->remove($pos);
            if (null === $this->employeesScheduledForDeletion) {
                $this->employeesScheduledForDeletion = clone $this->collEmployees;
                $this->employeesScheduledForDeletion->clear();
            }
            $this->employeesScheduledForDeletion[]= clone $employee;
            $employee->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Employees from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEmployee[] List of ChildEmployee objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployee}> List of ChildEmployee objects
     */
    public function getEmployeesJoinBranch(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEmployeeQuery::create(null, $criteria);
        $query->joinWith('Branch', $joinBehavior);

        return $this->getEmployees($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Employees from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEmployee[] List of ChildEmployee objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployee}> List of ChildEmployee objects
     */
    public function getEmployeesJoinDesignations(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEmployeeQuery::create(null, $criteria);
        $query->joinWith('Designations', $joinBehavior);

        return $this->getEmployees($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Employees from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEmployee[] List of ChildEmployee objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployee}> List of ChildEmployee objects
     */
    public function getEmployeesJoinGradeMaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEmployeeQuery::create(null, $criteria);
        $query->joinWith('GradeMaster', $joinBehavior);

        return $this->getEmployees($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Employees from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEmployee[] List of ChildEmployee objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployee}> List of ChildEmployee objects
     */
    public function getEmployeesJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEmployeeQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getEmployees($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Employees from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEmployee[] List of ChildEmployee objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployee}> List of ChildEmployee objects
     */
    public function getEmployeesJoinPositionsRelatedByPositionId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEmployeeQuery::create(null, $criteria);
        $query->joinWith('PositionsRelatedByPositionId', $joinBehavior);

        return $this->getEmployees($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Employees from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEmployee[] List of ChildEmployee objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployee}> List of ChildEmployee objects
     */
    public function getEmployeesJoinPositionsRelatedByReportingTo(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEmployeeQuery::create(null, $criteria);
        $query->joinWith('PositionsRelatedByReportingTo', $joinBehavior);

        return $this->getEmployees($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Employees from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEmployee[] List of ChildEmployee objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployee}> List of ChildEmployee objects
     */
    public function getEmployeesJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEmployeeQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getEmployees($query, $con);
    }

    /**
     * Clears out the collEmployeeIncentives collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEmployeeIncentives()
     */
    public function clearEmployeeIncentives()
    {
        $this->collEmployeeIncentives = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEmployeeIncentives collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEmployeeIncentives($v = true): void
    {
        $this->collEmployeeIncentivesPartial = $v;
    }

    /**
     * Initializes the collEmployeeIncentives collection.
     *
     * By default this just sets the collEmployeeIncentives collection to an empty array (like clearcollEmployeeIncentives());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEmployeeIncentives(bool $overrideExisting = true): void
    {
        if (null !== $this->collEmployeeIncentives && !$overrideExisting) {
            return;
        }

        $collectionClassName = EmployeeIncentiveTableMap::getTableMap()->getCollectionClassName();

        $this->collEmployeeIncentives = new $collectionClassName;
        $this->collEmployeeIncentives->setModel('\entities\EmployeeIncentive');
    }

    /**
     * Gets an array of ChildEmployeeIncentive objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEmployeeIncentive[] List of ChildEmployeeIncentive objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployeeIncentive> List of ChildEmployeeIncentive objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEmployeeIncentives(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEmployeeIncentivesPartial && !$this->isNew();
        if (null === $this->collEmployeeIncentives || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEmployeeIncentives) {
                    $this->initEmployeeIncentives();
                } else {
                    $collectionClassName = EmployeeIncentiveTableMap::getTableMap()->getCollectionClassName();

                    $collEmployeeIncentives = new $collectionClassName;
                    $collEmployeeIncentives->setModel('\entities\EmployeeIncentive');

                    return $collEmployeeIncentives;
                }
            } else {
                $collEmployeeIncentives = ChildEmployeeIncentiveQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEmployeeIncentivesPartial && count($collEmployeeIncentives)) {
                        $this->initEmployeeIncentives(false);

                        foreach ($collEmployeeIncentives as $obj) {
                            if (false == $this->collEmployeeIncentives->contains($obj)) {
                                $this->collEmployeeIncentives->append($obj);
                            }
                        }

                        $this->collEmployeeIncentivesPartial = true;
                    }

                    return $collEmployeeIncentives;
                }

                if ($partial && $this->collEmployeeIncentives) {
                    foreach ($this->collEmployeeIncentives as $obj) {
                        if ($obj->isNew()) {
                            $collEmployeeIncentives[] = $obj;
                        }
                    }
                }

                $this->collEmployeeIncentives = $collEmployeeIncentives;
                $this->collEmployeeIncentivesPartial = false;
            }
        }

        return $this->collEmployeeIncentives;
    }

    /**
     * Sets a collection of ChildEmployeeIncentive objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $employeeIncentives A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEmployeeIncentives(Collection $employeeIncentives, ?ConnectionInterface $con = null)
    {
        /** @var ChildEmployeeIncentive[] $employeeIncentivesToDelete */
        $employeeIncentivesToDelete = $this->getEmployeeIncentives(new Criteria(), $con)->diff($employeeIncentives);


        $this->employeeIncentivesScheduledForDeletion = $employeeIncentivesToDelete;

        foreach ($employeeIncentivesToDelete as $employeeIncentiveRemoved) {
            $employeeIncentiveRemoved->setCompany(null);
        }

        $this->collEmployeeIncentives = null;
        foreach ($employeeIncentives as $employeeIncentive) {
            $this->addEmployeeIncentive($employeeIncentive);
        }

        $this->collEmployeeIncentives = $employeeIncentives;
        $this->collEmployeeIncentivesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related EmployeeIncentive objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related EmployeeIncentive objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEmployeeIncentives(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEmployeeIncentivesPartial && !$this->isNew();
        if (null === $this->collEmployeeIncentives || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEmployeeIncentives) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEmployeeIncentives());
            }

            $query = ChildEmployeeIncentiveQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEmployeeIncentives);
    }

    /**
     * Method called to associate a ChildEmployeeIncentive object to this object
     * through the ChildEmployeeIncentive foreign key attribute.
     *
     * @param ChildEmployeeIncentive $l ChildEmployeeIncentive
     * @return $this The current object (for fluent API support)
     */
    public function addEmployeeIncentive(ChildEmployeeIncentive $l)
    {
        if ($this->collEmployeeIncentives === null) {
            $this->initEmployeeIncentives();
            $this->collEmployeeIncentivesPartial = true;
        }

        if (!$this->collEmployeeIncentives->contains($l)) {
            $this->doAddEmployeeIncentive($l);

            if ($this->employeeIncentivesScheduledForDeletion and $this->employeeIncentivesScheduledForDeletion->contains($l)) {
                $this->employeeIncentivesScheduledForDeletion->remove($this->employeeIncentivesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEmployeeIncentive $employeeIncentive The ChildEmployeeIncentive object to add.
     */
    protected function doAddEmployeeIncentive(ChildEmployeeIncentive $employeeIncentive): void
    {
        $this->collEmployeeIncentives[]= $employeeIncentive;
        $employeeIncentive->setCompany($this);
    }

    /**
     * @param ChildEmployeeIncentive $employeeIncentive The ChildEmployeeIncentive object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEmployeeIncentive(ChildEmployeeIncentive $employeeIncentive)
    {
        if ($this->getEmployeeIncentives()->contains($employeeIncentive)) {
            $pos = $this->collEmployeeIncentives->search($employeeIncentive);
            $this->collEmployeeIncentives->remove($pos);
            if (null === $this->employeeIncentivesScheduledForDeletion) {
                $this->employeeIncentivesScheduledForDeletion = clone $this->collEmployeeIncentives;
                $this->employeeIncentivesScheduledForDeletion->clear();
            }
            $this->employeeIncentivesScheduledForDeletion[]= clone $employeeIncentive;
            $employeeIncentive->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related EmployeeIncentives from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEmployeeIncentive[] List of ChildEmployeeIncentive objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEmployeeIncentive}> List of ChildEmployeeIncentive objects
     */
    public function getEmployeeIncentivesJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEmployeeIncentiveQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getEmployeeIncentives($query, $con);
    }

    /**
     * Clears out the collEventTypess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEventTypess()
     */
    public function clearEventTypess()
    {
        $this->collEventTypess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEventTypess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEventTypess($v = true): void
    {
        $this->collEventTypessPartial = $v;
    }

    /**
     * Initializes the collEventTypess collection.
     *
     * By default this just sets the collEventTypess collection to an empty array (like clearcollEventTypess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEventTypess(bool $overrideExisting = true): void
    {
        if (null !== $this->collEventTypess && !$overrideExisting) {
            return;
        }

        $collectionClassName = EventTypesTableMap::getTableMap()->getCollectionClassName();

        $this->collEventTypess = new $collectionClassName;
        $this->collEventTypess->setModel('\entities\EventTypes');
    }

    /**
     * Gets an array of ChildEventTypes objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEventTypes[] List of ChildEventTypes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEventTypes> List of ChildEventTypes objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEventTypess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEventTypessPartial && !$this->isNew();
        if (null === $this->collEventTypess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEventTypess) {
                    $this->initEventTypess();
                } else {
                    $collectionClassName = EventTypesTableMap::getTableMap()->getCollectionClassName();

                    $collEventTypess = new $collectionClassName;
                    $collEventTypess->setModel('\entities\EventTypes');

                    return $collEventTypess;
                }
            } else {
                $collEventTypess = ChildEventTypesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEventTypessPartial && count($collEventTypess)) {
                        $this->initEventTypess(false);

                        foreach ($collEventTypess as $obj) {
                            if (false == $this->collEventTypess->contains($obj)) {
                                $this->collEventTypess->append($obj);
                            }
                        }

                        $this->collEventTypessPartial = true;
                    }

                    return $collEventTypess;
                }

                if ($partial && $this->collEventTypess) {
                    foreach ($this->collEventTypess as $obj) {
                        if ($obj->isNew()) {
                            $collEventTypess[] = $obj;
                        }
                    }
                }

                $this->collEventTypess = $collEventTypess;
                $this->collEventTypessPartial = false;
            }
        }

        return $this->collEventTypess;
    }

    /**
     * Sets a collection of ChildEventTypes objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $eventTypess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEventTypess(Collection $eventTypess, ?ConnectionInterface $con = null)
    {
        /** @var ChildEventTypes[] $eventTypessToDelete */
        $eventTypessToDelete = $this->getEventTypess(new Criteria(), $con)->diff($eventTypess);


        $this->eventTypessScheduledForDeletion = $eventTypessToDelete;

        foreach ($eventTypessToDelete as $eventTypesRemoved) {
            $eventTypesRemoved->setCompany(null);
        }

        $this->collEventTypess = null;
        foreach ($eventTypess as $eventTypes) {
            $this->addEventTypes($eventTypes);
        }

        $this->collEventTypess = $eventTypess;
        $this->collEventTypessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related EventTypes objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related EventTypes objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEventTypess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEventTypessPartial && !$this->isNew();
        if (null === $this->collEventTypess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEventTypess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEventTypess());
            }

            $query = ChildEventTypesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEventTypess);
    }

    /**
     * Method called to associate a ChildEventTypes object to this object
     * through the ChildEventTypes foreign key attribute.
     *
     * @param ChildEventTypes $l ChildEventTypes
     * @return $this The current object (for fluent API support)
     */
    public function addEventTypes(ChildEventTypes $l)
    {
        if ($this->collEventTypess === null) {
            $this->initEventTypess();
            $this->collEventTypessPartial = true;
        }

        if (!$this->collEventTypess->contains($l)) {
            $this->doAddEventTypes($l);

            if ($this->eventTypessScheduledForDeletion and $this->eventTypessScheduledForDeletion->contains($l)) {
                $this->eventTypessScheduledForDeletion->remove($this->eventTypessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEventTypes $eventTypes The ChildEventTypes object to add.
     */
    protected function doAddEventTypes(ChildEventTypes $eventTypes): void
    {
        $this->collEventTypess[]= $eventTypes;
        $eventTypes->setCompany($this);
    }

    /**
     * @param ChildEventTypes $eventTypes The ChildEventTypes object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEventTypes(ChildEventTypes $eventTypes)
    {
        if ($this->getEventTypess()->contains($eventTypes)) {
            $pos = $this->collEventTypess->search($eventTypes);
            $this->collEventTypess->remove($pos);
            if (null === $this->eventTypessScheduledForDeletion) {
                $this->eventTypessScheduledForDeletion = clone $this->collEventTypess;
                $this->eventTypessScheduledForDeletion->clear();
            }
            $this->eventTypessScheduledForDeletion[]= clone $eventTypes;
            $eventTypes->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collEventss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addEventss()
     */
    public function clearEventss()
    {
        $this->collEventss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collEventss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialEventss($v = true): void
    {
        $this->collEventssPartial = $v;
    }

    /**
     * Initializes the collEventss collection.
     *
     * By default this just sets the collEventss collection to an empty array (like clearcollEventss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initEventss(bool $overrideExisting = true): void
    {
        if (null !== $this->collEventss && !$overrideExisting) {
            return;
        }

        $collectionClassName = EventsTableMap::getTableMap()->getCollectionClassName();

        $this->collEventss = new $collectionClassName;
        $this->collEventss->setModel('\entities\Events');
    }

    /**
     * Gets an array of ChildEvents objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildEvents[] List of ChildEvents objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEvents> List of ChildEvents objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getEventss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collEventssPartial && !$this->isNew();
        if (null === $this->collEventss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collEventss) {
                    $this->initEventss();
                } else {
                    $collectionClassName = EventsTableMap::getTableMap()->getCollectionClassName();

                    $collEventss = new $collectionClassName;
                    $collEventss->setModel('\entities\Events');

                    return $collEventss;
                }
            } else {
                $collEventss = ChildEventsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collEventssPartial && count($collEventss)) {
                        $this->initEventss(false);

                        foreach ($collEventss as $obj) {
                            if (false == $this->collEventss->contains($obj)) {
                                $this->collEventss->append($obj);
                            }
                        }

                        $this->collEventssPartial = true;
                    }

                    return $collEventss;
                }

                if ($partial && $this->collEventss) {
                    foreach ($this->collEventss as $obj) {
                        if ($obj->isNew()) {
                            $collEventss[] = $obj;
                        }
                    }
                }

                $this->collEventss = $collEventss;
                $this->collEventssPartial = false;
            }
        }

        return $this->collEventss;
    }

    /**
     * Sets a collection of ChildEvents objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $eventss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setEventss(Collection $eventss, ?ConnectionInterface $con = null)
    {
        /** @var ChildEvents[] $eventssToDelete */
        $eventssToDelete = $this->getEventss(new Criteria(), $con)->diff($eventss);


        $this->eventssScheduledForDeletion = $eventssToDelete;

        foreach ($eventssToDelete as $eventsRemoved) {
            $eventsRemoved->setCompany(null);
        }

        $this->collEventss = null;
        foreach ($eventss as $events) {
            $this->addEvents($events);
        }

        $this->collEventss = $eventss;
        $this->collEventssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Events objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Events objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countEventss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collEventssPartial && !$this->isNew();
        if (null === $this->collEventss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collEventss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getEventss());
            }

            $query = ChildEventsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collEventss);
    }

    /**
     * Method called to associate a ChildEvents object to this object
     * through the ChildEvents foreign key attribute.
     *
     * @param ChildEvents $l ChildEvents
     * @return $this The current object (for fluent API support)
     */
    public function addEvents(ChildEvents $l)
    {
        if ($this->collEventss === null) {
            $this->initEventss();
            $this->collEventssPartial = true;
        }

        if (!$this->collEventss->contains($l)) {
            $this->doAddEvents($l);

            if ($this->eventssScheduledForDeletion and $this->eventssScheduledForDeletion->contains($l)) {
                $this->eventssScheduledForDeletion->remove($this->eventssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildEvents $events The ChildEvents object to add.
     */
    protected function doAddEvents(ChildEvents $events): void
    {
        $this->collEventss[]= $events;
        $events->setCompany($this);
    }

    /**
     * @param ChildEvents $events The ChildEvents object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeEvents(ChildEvents $events)
    {
        if ($this->getEventss()->contains($events)) {
            $pos = $this->collEventss->search($events);
            $this->collEventss->remove($pos);
            if (null === $this->eventssScheduledForDeletion) {
                $this->eventssScheduledForDeletion = clone $this->collEventss;
                $this->eventssScheduledForDeletion->clear();
            }
            $this->eventssScheduledForDeletion[]= $events;
            $events->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Eventss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEvents[] List of ChildEvents objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEvents}> List of ChildEvents objects
     */
    public function getEventssJoinEmployeeRelatedByEmployeeId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEventsQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByEmployeeId', $joinBehavior);

        return $this->getEventss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Eventss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEvents[] List of ChildEvents objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEvents}> List of ChildEvents objects
     */
    public function getEventssJoinEventTypes(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEventsQuery::create(null, $criteria);
        $query->joinWith('EventTypes', $joinBehavior);

        return $this->getEventss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Eventss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildEvents[] List of ChildEvents objects
     * @phpstan-return ObjectCollection&\Traversable<ChildEvents}> List of ChildEvents objects
     */
    public function getEventssJoinEmployeeRelatedByApproverEmpId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildEventsQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByApproverEmpId', $joinBehavior);

        return $this->getEventss($query, $con);
    }

    /**
     * Clears out the collExpenseLists collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addExpenseLists()
     */
    public function clearExpenseLists()
    {
        $this->collExpenseLists = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collExpenseLists collection loaded partially.
     *
     * @return void
     */
    public function resetPartialExpenseLists($v = true): void
    {
        $this->collExpenseListsPartial = $v;
    }

    /**
     * Initializes the collExpenseLists collection.
     *
     * By default this just sets the collExpenseLists collection to an empty array (like clearcollExpenseLists());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initExpenseLists(bool $overrideExisting = true): void
    {
        if (null !== $this->collExpenseLists && !$overrideExisting) {
            return;
        }

        $collectionClassName = ExpenseListTableMap::getTableMap()->getCollectionClassName();

        $this->collExpenseLists = new $collectionClassName;
        $this->collExpenseLists->setModel('\entities\ExpenseList');
    }

    /**
     * Gets an array of ChildExpenseList objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildExpenseList[] List of ChildExpenseList objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenseList> List of ChildExpenseList objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getExpenseLists(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collExpenseListsPartial && !$this->isNew();
        if (null === $this->collExpenseLists || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collExpenseLists) {
                    $this->initExpenseLists();
                } else {
                    $collectionClassName = ExpenseListTableMap::getTableMap()->getCollectionClassName();

                    $collExpenseLists = new $collectionClassName;
                    $collExpenseLists->setModel('\entities\ExpenseList');

                    return $collExpenseLists;
                }
            } else {
                $collExpenseLists = ChildExpenseListQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collExpenseListsPartial && count($collExpenseLists)) {
                        $this->initExpenseLists(false);

                        foreach ($collExpenseLists as $obj) {
                            if (false == $this->collExpenseLists->contains($obj)) {
                                $this->collExpenseLists->append($obj);
                            }
                        }

                        $this->collExpenseListsPartial = true;
                    }

                    return $collExpenseLists;
                }

                if ($partial && $this->collExpenseLists) {
                    foreach ($this->collExpenseLists as $obj) {
                        if ($obj->isNew()) {
                            $collExpenseLists[] = $obj;
                        }
                    }
                }

                $this->collExpenseLists = $collExpenseLists;
                $this->collExpenseListsPartial = false;
            }
        }

        return $this->collExpenseLists;
    }

    /**
     * Sets a collection of ChildExpenseList objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $expenseLists A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setExpenseLists(Collection $expenseLists, ?ConnectionInterface $con = null)
    {
        /** @var ChildExpenseList[] $expenseListsToDelete */
        $expenseListsToDelete = $this->getExpenseLists(new Criteria(), $con)->diff($expenseLists);


        $this->expenseListsScheduledForDeletion = $expenseListsToDelete;

        foreach ($expenseListsToDelete as $expenseListRemoved) {
            $expenseListRemoved->setCompany(null);
        }

        $this->collExpenseLists = null;
        foreach ($expenseLists as $expenseList) {
            $this->addExpenseList($expenseList);
        }

        $this->collExpenseLists = $expenseLists;
        $this->collExpenseListsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related ExpenseList objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related ExpenseList objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countExpenseLists(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collExpenseListsPartial && !$this->isNew();
        if (null === $this->collExpenseLists || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collExpenseLists) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getExpenseLists());
            }

            $query = ChildExpenseListQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collExpenseLists);
    }

    /**
     * Method called to associate a ChildExpenseList object to this object
     * through the ChildExpenseList foreign key attribute.
     *
     * @param ChildExpenseList $l ChildExpenseList
     * @return $this The current object (for fluent API support)
     */
    public function addExpenseList(ChildExpenseList $l)
    {
        if ($this->collExpenseLists === null) {
            $this->initExpenseLists();
            $this->collExpenseListsPartial = true;
        }

        if (!$this->collExpenseLists->contains($l)) {
            $this->doAddExpenseList($l);

            if ($this->expenseListsScheduledForDeletion and $this->expenseListsScheduledForDeletion->contains($l)) {
                $this->expenseListsScheduledForDeletion->remove($this->expenseListsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildExpenseList $expenseList The ChildExpenseList object to add.
     */
    protected function doAddExpenseList(ChildExpenseList $expenseList): void
    {
        $this->collExpenseLists[]= $expenseList;
        $expenseList->setCompany($this);
    }

    /**
     * @param ChildExpenseList $expenseList The ChildExpenseList object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeExpenseList(ChildExpenseList $expenseList)
    {
        if ($this->getExpenseLists()->contains($expenseList)) {
            $pos = $this->collExpenseLists->search($expenseList);
            $this->collExpenseLists->remove($pos);
            if (null === $this->expenseListsScheduledForDeletion) {
                $this->expenseListsScheduledForDeletion = clone $this->collExpenseLists;
                $this->expenseListsScheduledForDeletion->clear();
            }
            $this->expenseListsScheduledForDeletion[]= clone $expenseList;
            $expenseList->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related ExpenseLists from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildExpenseList[] List of ChildExpenseList objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenseList}> List of ChildExpenseList objects
     */
    public function getExpenseListsJoinExpenseMaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildExpenseListQuery::create(null, $criteria);
        $query->joinWith('ExpenseMaster', $joinBehavior);

        return $this->getExpenseLists($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related ExpenseLists from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildExpenseList[] List of ChildExpenseList objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenseList}> List of ChildExpenseList objects
     */
    public function getExpenseListsJoinExpenses(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildExpenseListQuery::create(null, $criteria);
        $query->joinWith('Expenses', $joinBehavior);

        return $this->getExpenseLists($query, $con);
    }

    /**
     * Clears out the collExpenseMastersRelatedByCompanyId collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addExpenseMastersRelatedByCompanyId()
     */
    public function clearExpenseMastersRelatedByCompanyId()
    {
        $this->collExpenseMastersRelatedByCompanyId = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collExpenseMastersRelatedByCompanyId collection loaded partially.
     *
     * @return void
     */
    public function resetPartialExpenseMastersRelatedByCompanyId($v = true): void
    {
        $this->collExpenseMastersRelatedByCompanyIdPartial = $v;
    }

    /**
     * Initializes the collExpenseMastersRelatedByCompanyId collection.
     *
     * By default this just sets the collExpenseMastersRelatedByCompanyId collection to an empty array (like clearcollExpenseMastersRelatedByCompanyId());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initExpenseMastersRelatedByCompanyId(bool $overrideExisting = true): void
    {
        if (null !== $this->collExpenseMastersRelatedByCompanyId && !$overrideExisting) {
            return;
        }

        $collectionClassName = ExpenseMasterTableMap::getTableMap()->getCollectionClassName();

        $this->collExpenseMastersRelatedByCompanyId = new $collectionClassName;
        $this->collExpenseMastersRelatedByCompanyId->setModel('\entities\ExpenseMaster');
    }

    /**
     * Gets an array of ChildExpenseMaster objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildExpenseMaster[] List of ChildExpenseMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenseMaster> List of ChildExpenseMaster objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getExpenseMastersRelatedByCompanyId(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collExpenseMastersRelatedByCompanyIdPartial && !$this->isNew();
        if (null === $this->collExpenseMastersRelatedByCompanyId || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collExpenseMastersRelatedByCompanyId) {
                    $this->initExpenseMastersRelatedByCompanyId();
                } else {
                    $collectionClassName = ExpenseMasterTableMap::getTableMap()->getCollectionClassName();

                    $collExpenseMastersRelatedByCompanyId = new $collectionClassName;
                    $collExpenseMastersRelatedByCompanyId->setModel('\entities\ExpenseMaster');

                    return $collExpenseMastersRelatedByCompanyId;
                }
            } else {
                $collExpenseMastersRelatedByCompanyId = ChildExpenseMasterQuery::create(null, $criteria)
                    ->filterByCompanyRelatedByCompanyId($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collExpenseMastersRelatedByCompanyIdPartial && count($collExpenseMastersRelatedByCompanyId)) {
                        $this->initExpenseMastersRelatedByCompanyId(false);

                        foreach ($collExpenseMastersRelatedByCompanyId as $obj) {
                            if (false == $this->collExpenseMastersRelatedByCompanyId->contains($obj)) {
                                $this->collExpenseMastersRelatedByCompanyId->append($obj);
                            }
                        }

                        $this->collExpenseMastersRelatedByCompanyIdPartial = true;
                    }

                    return $collExpenseMastersRelatedByCompanyId;
                }

                if ($partial && $this->collExpenseMastersRelatedByCompanyId) {
                    foreach ($this->collExpenseMastersRelatedByCompanyId as $obj) {
                        if ($obj->isNew()) {
                            $collExpenseMastersRelatedByCompanyId[] = $obj;
                        }
                    }
                }

                $this->collExpenseMastersRelatedByCompanyId = $collExpenseMastersRelatedByCompanyId;
                $this->collExpenseMastersRelatedByCompanyIdPartial = false;
            }
        }

        return $this->collExpenseMastersRelatedByCompanyId;
    }

    /**
     * Sets a collection of ChildExpenseMaster objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $expenseMastersRelatedByCompanyId A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setExpenseMastersRelatedByCompanyId(Collection $expenseMastersRelatedByCompanyId, ?ConnectionInterface $con = null)
    {
        /** @var ChildExpenseMaster[] $expenseMastersRelatedByCompanyIdToDelete */
        $expenseMastersRelatedByCompanyIdToDelete = $this->getExpenseMastersRelatedByCompanyId(new Criteria(), $con)->diff($expenseMastersRelatedByCompanyId);


        $this->expenseMastersRelatedByCompanyIdScheduledForDeletion = $expenseMastersRelatedByCompanyIdToDelete;

        foreach ($expenseMastersRelatedByCompanyIdToDelete as $expenseMasterRelatedByCompanyIdRemoved) {
            $expenseMasterRelatedByCompanyIdRemoved->setCompanyRelatedByCompanyId(null);
        }

        $this->collExpenseMastersRelatedByCompanyId = null;
        foreach ($expenseMastersRelatedByCompanyId as $expenseMasterRelatedByCompanyId) {
            $this->addExpenseMasterRelatedByCompanyId($expenseMasterRelatedByCompanyId);
        }

        $this->collExpenseMastersRelatedByCompanyId = $expenseMastersRelatedByCompanyId;
        $this->collExpenseMastersRelatedByCompanyIdPartial = false;

        return $this;
    }

    /**
     * Returns the number of related ExpenseMaster objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related ExpenseMaster objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countExpenseMastersRelatedByCompanyId(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collExpenseMastersRelatedByCompanyIdPartial && !$this->isNew();
        if (null === $this->collExpenseMastersRelatedByCompanyId || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collExpenseMastersRelatedByCompanyId) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getExpenseMastersRelatedByCompanyId());
            }

            $query = ChildExpenseMasterQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompanyRelatedByCompanyId($this)
                ->count($con);
        }

        return count($this->collExpenseMastersRelatedByCompanyId);
    }

    /**
     * Method called to associate a ChildExpenseMaster object to this object
     * through the ChildExpenseMaster foreign key attribute.
     *
     * @param ChildExpenseMaster $l ChildExpenseMaster
     * @return $this The current object (for fluent API support)
     */
    public function addExpenseMasterRelatedByCompanyId(ChildExpenseMaster $l)
    {
        if ($this->collExpenseMastersRelatedByCompanyId === null) {
            $this->initExpenseMastersRelatedByCompanyId();
            $this->collExpenseMastersRelatedByCompanyIdPartial = true;
        }

        if (!$this->collExpenseMastersRelatedByCompanyId->contains($l)) {
            $this->doAddExpenseMasterRelatedByCompanyId($l);

            if ($this->expenseMastersRelatedByCompanyIdScheduledForDeletion and $this->expenseMastersRelatedByCompanyIdScheduledForDeletion->contains($l)) {
                $this->expenseMastersRelatedByCompanyIdScheduledForDeletion->remove($this->expenseMastersRelatedByCompanyIdScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildExpenseMaster $expenseMasterRelatedByCompanyId The ChildExpenseMaster object to add.
     */
    protected function doAddExpenseMasterRelatedByCompanyId(ChildExpenseMaster $expenseMasterRelatedByCompanyId): void
    {
        $this->collExpenseMastersRelatedByCompanyId[]= $expenseMasterRelatedByCompanyId;
        $expenseMasterRelatedByCompanyId->setCompanyRelatedByCompanyId($this);
    }

    /**
     * @param ChildExpenseMaster $expenseMasterRelatedByCompanyId The ChildExpenseMaster object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeExpenseMasterRelatedByCompanyId(ChildExpenseMaster $expenseMasterRelatedByCompanyId)
    {
        if ($this->getExpenseMastersRelatedByCompanyId()->contains($expenseMasterRelatedByCompanyId)) {
            $pos = $this->collExpenseMastersRelatedByCompanyId->search($expenseMasterRelatedByCompanyId);
            $this->collExpenseMastersRelatedByCompanyId->remove($pos);
            if (null === $this->expenseMastersRelatedByCompanyIdScheduledForDeletion) {
                $this->expenseMastersRelatedByCompanyIdScheduledForDeletion = clone $this->collExpenseMastersRelatedByCompanyId;
                $this->expenseMastersRelatedByCompanyIdScheduledForDeletion->clear();
            }
            $this->expenseMastersRelatedByCompanyIdScheduledForDeletion[]= clone $expenseMasterRelatedByCompanyId;
            $expenseMasterRelatedByCompanyId->setCompanyRelatedByCompanyId(null);
        }

        return $this;
    }

    /**
     * Clears out the collExpensePaymentss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addExpensePaymentss()
     */
    public function clearExpensePaymentss()
    {
        $this->collExpensePaymentss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collExpensePaymentss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialExpensePaymentss($v = true): void
    {
        $this->collExpensePaymentssPartial = $v;
    }

    /**
     * Initializes the collExpensePaymentss collection.
     *
     * By default this just sets the collExpensePaymentss collection to an empty array (like clearcollExpensePaymentss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initExpensePaymentss(bool $overrideExisting = true): void
    {
        if (null !== $this->collExpensePaymentss && !$overrideExisting) {
            return;
        }

        $collectionClassName = ExpensePaymentsTableMap::getTableMap()->getCollectionClassName();

        $this->collExpensePaymentss = new $collectionClassName;
        $this->collExpensePaymentss->setModel('\entities\ExpensePayments');
    }

    /**
     * Gets an array of ChildExpensePayments objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildExpensePayments[] List of ChildExpensePayments objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpensePayments> List of ChildExpensePayments objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getExpensePaymentss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collExpensePaymentssPartial && !$this->isNew();
        if (null === $this->collExpensePaymentss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collExpensePaymentss) {
                    $this->initExpensePaymentss();
                } else {
                    $collectionClassName = ExpensePaymentsTableMap::getTableMap()->getCollectionClassName();

                    $collExpensePaymentss = new $collectionClassName;
                    $collExpensePaymentss->setModel('\entities\ExpensePayments');

                    return $collExpensePaymentss;
                }
            } else {
                $collExpensePaymentss = ChildExpensePaymentsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collExpensePaymentssPartial && count($collExpensePaymentss)) {
                        $this->initExpensePaymentss(false);

                        foreach ($collExpensePaymentss as $obj) {
                            if (false == $this->collExpensePaymentss->contains($obj)) {
                                $this->collExpensePaymentss->append($obj);
                            }
                        }

                        $this->collExpensePaymentssPartial = true;
                    }

                    return $collExpensePaymentss;
                }

                if ($partial && $this->collExpensePaymentss) {
                    foreach ($this->collExpensePaymentss as $obj) {
                        if ($obj->isNew()) {
                            $collExpensePaymentss[] = $obj;
                        }
                    }
                }

                $this->collExpensePaymentss = $collExpensePaymentss;
                $this->collExpensePaymentssPartial = false;
            }
        }

        return $this->collExpensePaymentss;
    }

    /**
     * Sets a collection of ChildExpensePayments objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $expensePaymentss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setExpensePaymentss(Collection $expensePaymentss, ?ConnectionInterface $con = null)
    {
        /** @var ChildExpensePayments[] $expensePaymentssToDelete */
        $expensePaymentssToDelete = $this->getExpensePaymentss(new Criteria(), $con)->diff($expensePaymentss);


        $this->expensePaymentssScheduledForDeletion = $expensePaymentssToDelete;

        foreach ($expensePaymentssToDelete as $expensePaymentsRemoved) {
            $expensePaymentsRemoved->setCompany(null);
        }

        $this->collExpensePaymentss = null;
        foreach ($expensePaymentss as $expensePayments) {
            $this->addExpensePayments($expensePayments);
        }

        $this->collExpensePaymentss = $expensePaymentss;
        $this->collExpensePaymentssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related ExpensePayments objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related ExpensePayments objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countExpensePaymentss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collExpensePaymentssPartial && !$this->isNew();
        if (null === $this->collExpensePaymentss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collExpensePaymentss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getExpensePaymentss());
            }

            $query = ChildExpensePaymentsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collExpensePaymentss);
    }

    /**
     * Method called to associate a ChildExpensePayments object to this object
     * through the ChildExpensePayments foreign key attribute.
     *
     * @param ChildExpensePayments $l ChildExpensePayments
     * @return $this The current object (for fluent API support)
     */
    public function addExpensePayments(ChildExpensePayments $l)
    {
        if ($this->collExpensePaymentss === null) {
            $this->initExpensePaymentss();
            $this->collExpensePaymentssPartial = true;
        }

        if (!$this->collExpensePaymentss->contains($l)) {
            $this->doAddExpensePayments($l);

            if ($this->expensePaymentssScheduledForDeletion and $this->expensePaymentssScheduledForDeletion->contains($l)) {
                $this->expensePaymentssScheduledForDeletion->remove($this->expensePaymentssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildExpensePayments $expensePayments The ChildExpensePayments object to add.
     */
    protected function doAddExpensePayments(ChildExpensePayments $expensePayments): void
    {
        $this->collExpensePaymentss[]= $expensePayments;
        $expensePayments->setCompany($this);
    }

    /**
     * @param ChildExpensePayments $expensePayments The ChildExpensePayments object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeExpensePayments(ChildExpensePayments $expensePayments)
    {
        if ($this->getExpensePaymentss()->contains($expensePayments)) {
            $pos = $this->collExpensePaymentss->search($expensePayments);
            $this->collExpensePaymentss->remove($pos);
            if (null === $this->expensePaymentssScheduledForDeletion) {
                $this->expensePaymentssScheduledForDeletion = clone $this->collExpensePaymentss;
                $this->expensePaymentssScheduledForDeletion->clear();
            }
            $this->expensePaymentssScheduledForDeletion[]= $expensePayments;
            $expensePayments->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related ExpensePaymentss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildExpensePayments[] List of ChildExpensePayments objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpensePayments}> List of ChildExpensePayments objects
     */
    public function getExpensePaymentssJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildExpensePaymentsQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getExpensePaymentss($query, $con);
    }

    /**
     * Clears out the collExpensess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addExpensess()
     */
    public function clearExpensess()
    {
        $this->collExpensess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collExpensess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialExpensess($v = true): void
    {
        $this->collExpensessPartial = $v;
    }

    /**
     * Initializes the collExpensess collection.
     *
     * By default this just sets the collExpensess collection to an empty array (like clearcollExpensess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initExpensess(bool $overrideExisting = true): void
    {
        if (null !== $this->collExpensess && !$overrideExisting) {
            return;
        }

        $collectionClassName = ExpensesTableMap::getTableMap()->getCollectionClassName();

        $this->collExpensess = new $collectionClassName;
        $this->collExpensess->setModel('\entities\Expenses');
    }

    /**
     * Gets an array of ChildExpenses objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildExpenses[] List of ChildExpenses objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenses> List of ChildExpenses objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getExpensess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collExpensessPartial && !$this->isNew();
        if (null === $this->collExpensess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collExpensess) {
                    $this->initExpensess();
                } else {
                    $collectionClassName = ExpensesTableMap::getTableMap()->getCollectionClassName();

                    $collExpensess = new $collectionClassName;
                    $collExpensess->setModel('\entities\Expenses');

                    return $collExpensess;
                }
            } else {
                $collExpensess = ChildExpensesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collExpensessPartial && count($collExpensess)) {
                        $this->initExpensess(false);

                        foreach ($collExpensess as $obj) {
                            if (false == $this->collExpensess->contains($obj)) {
                                $this->collExpensess->append($obj);
                            }
                        }

                        $this->collExpensessPartial = true;
                    }

                    return $collExpensess;
                }

                if ($partial && $this->collExpensess) {
                    foreach ($this->collExpensess as $obj) {
                        if ($obj->isNew()) {
                            $collExpensess[] = $obj;
                        }
                    }
                }

                $this->collExpensess = $collExpensess;
                $this->collExpensessPartial = false;
            }
        }

        return $this->collExpensess;
    }

    /**
     * Sets a collection of ChildExpenses objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $expensess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setExpensess(Collection $expensess, ?ConnectionInterface $con = null)
    {
        /** @var ChildExpenses[] $expensessToDelete */
        $expensessToDelete = $this->getExpensess(new Criteria(), $con)->diff($expensess);


        $this->expensessScheduledForDeletion = $expensessToDelete;

        foreach ($expensessToDelete as $expensesRemoved) {
            $expensesRemoved->setCompany(null);
        }

        $this->collExpensess = null;
        foreach ($expensess as $expenses) {
            $this->addExpenses($expenses);
        }

        $this->collExpensess = $expensess;
        $this->collExpensessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Expenses objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Expenses objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countExpensess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collExpensessPartial && !$this->isNew();
        if (null === $this->collExpensess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collExpensess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getExpensess());
            }

            $query = ChildExpensesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collExpensess);
    }

    /**
     * Method called to associate a ChildExpenses object to this object
     * through the ChildExpenses foreign key attribute.
     *
     * @param ChildExpenses $l ChildExpenses
     * @return $this The current object (for fluent API support)
     */
    public function addExpenses(ChildExpenses $l)
    {
        if ($this->collExpensess === null) {
            $this->initExpensess();
            $this->collExpensessPartial = true;
        }

        if (!$this->collExpensess->contains($l)) {
            $this->doAddExpenses($l);

            if ($this->expensessScheduledForDeletion and $this->expensessScheduledForDeletion->contains($l)) {
                $this->expensessScheduledForDeletion->remove($this->expensessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildExpenses $expenses The ChildExpenses object to add.
     */
    protected function doAddExpenses(ChildExpenses $expenses): void
    {
        $this->collExpensess[]= $expenses;
        $expenses->setCompany($this);
    }

    /**
     * @param ChildExpenses $expenses The ChildExpenses object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeExpenses(ChildExpenses $expenses)
    {
        if ($this->getExpensess()->contains($expenses)) {
            $pos = $this->collExpensess->search($expenses);
            $this->collExpensess->remove($pos);
            if (null === $this->expensessScheduledForDeletion) {
                $this->expensessScheduledForDeletion = clone $this->collExpensess;
                $this->expensessScheduledForDeletion->clear();
            }
            $this->expensessScheduledForDeletion[]= clone $expenses;
            $expenses->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Expensess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildExpenses[] List of ChildExpenses objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenses}> List of ChildExpenses objects
     */
    public function getExpensessJoinBudgetGroup(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildExpensesQuery::create(null, $criteria);
        $query->joinWith('BudgetGroup', $joinBehavior);

        return $this->getExpensess($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Expensess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildExpenses[] List of ChildExpenses objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenses}> List of ChildExpenses objects
     */
    public function getExpensessJoinCurrencies(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildExpensesQuery::create(null, $criteria);
        $query->joinWith('Currencies', $joinBehavior);

        return $this->getExpensess($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Expensess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildExpenses[] List of ChildExpenses objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenses}> List of ChildExpenses objects
     */
    public function getExpensessJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildExpensesQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getExpensess($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Expensess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildExpenses[] List of ChildExpenses objects
     * @phpstan-return ObjectCollection&\Traversable<ChildExpenses}> List of ChildExpenses objects
     */
    public function getExpensessJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildExpensesQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getExpensess($query, $con);
    }

    /**
     * Clears out the collFtpConfigss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addFtpConfigss()
     */
    public function clearFtpConfigss()
    {
        $this->collFtpConfigss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collFtpConfigss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialFtpConfigss($v = true): void
    {
        $this->collFtpConfigssPartial = $v;
    }

    /**
     * Initializes the collFtpConfigss collection.
     *
     * By default this just sets the collFtpConfigss collection to an empty array (like clearcollFtpConfigss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initFtpConfigss(bool $overrideExisting = true): void
    {
        if (null !== $this->collFtpConfigss && !$overrideExisting) {
            return;
        }

        $collectionClassName = FtpConfigsTableMap::getTableMap()->getCollectionClassName();

        $this->collFtpConfigss = new $collectionClassName;
        $this->collFtpConfigss->setModel('\entities\FtpConfigs');
    }

    /**
     * Gets an array of ChildFtpConfigs objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildFtpConfigs[] List of ChildFtpConfigs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildFtpConfigs> List of ChildFtpConfigs objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getFtpConfigss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collFtpConfigssPartial && !$this->isNew();
        if (null === $this->collFtpConfigss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collFtpConfigss) {
                    $this->initFtpConfigss();
                } else {
                    $collectionClassName = FtpConfigsTableMap::getTableMap()->getCollectionClassName();

                    $collFtpConfigss = new $collectionClassName;
                    $collFtpConfigss->setModel('\entities\FtpConfigs');

                    return $collFtpConfigss;
                }
            } else {
                $collFtpConfigss = ChildFtpConfigsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collFtpConfigssPartial && count($collFtpConfigss)) {
                        $this->initFtpConfigss(false);

                        foreach ($collFtpConfigss as $obj) {
                            if (false == $this->collFtpConfigss->contains($obj)) {
                                $this->collFtpConfigss->append($obj);
                            }
                        }

                        $this->collFtpConfigssPartial = true;
                    }

                    return $collFtpConfigss;
                }

                if ($partial && $this->collFtpConfigss) {
                    foreach ($this->collFtpConfigss as $obj) {
                        if ($obj->isNew()) {
                            $collFtpConfigss[] = $obj;
                        }
                    }
                }

                $this->collFtpConfigss = $collFtpConfigss;
                $this->collFtpConfigssPartial = false;
            }
        }

        return $this->collFtpConfigss;
    }

    /**
     * Sets a collection of ChildFtpConfigs objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $ftpConfigss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setFtpConfigss(Collection $ftpConfigss, ?ConnectionInterface $con = null)
    {
        /** @var ChildFtpConfigs[] $ftpConfigssToDelete */
        $ftpConfigssToDelete = $this->getFtpConfigss(new Criteria(), $con)->diff($ftpConfigss);


        $this->ftpConfigssScheduledForDeletion = $ftpConfigssToDelete;

        foreach ($ftpConfigssToDelete as $ftpConfigsRemoved) {
            $ftpConfigsRemoved->setCompany(null);
        }

        $this->collFtpConfigss = null;
        foreach ($ftpConfigss as $ftpConfigs) {
            $this->addFtpConfigs($ftpConfigs);
        }

        $this->collFtpConfigss = $ftpConfigss;
        $this->collFtpConfigssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related FtpConfigs objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related FtpConfigs objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countFtpConfigss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collFtpConfigssPartial && !$this->isNew();
        if (null === $this->collFtpConfigss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collFtpConfigss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getFtpConfigss());
            }

            $query = ChildFtpConfigsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collFtpConfigss);
    }

    /**
     * Method called to associate a ChildFtpConfigs object to this object
     * through the ChildFtpConfigs foreign key attribute.
     *
     * @param ChildFtpConfigs $l ChildFtpConfigs
     * @return $this The current object (for fluent API support)
     */
    public function addFtpConfigs(ChildFtpConfigs $l)
    {
        if ($this->collFtpConfigss === null) {
            $this->initFtpConfigss();
            $this->collFtpConfigssPartial = true;
        }

        if (!$this->collFtpConfigss->contains($l)) {
            $this->doAddFtpConfigs($l);

            if ($this->ftpConfigssScheduledForDeletion and $this->ftpConfigssScheduledForDeletion->contains($l)) {
                $this->ftpConfigssScheduledForDeletion->remove($this->ftpConfigssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildFtpConfigs $ftpConfigs The ChildFtpConfigs object to add.
     */
    protected function doAddFtpConfigs(ChildFtpConfigs $ftpConfigs): void
    {
        $this->collFtpConfigss[]= $ftpConfigs;
        $ftpConfigs->setCompany($this);
    }

    /**
     * @param ChildFtpConfigs $ftpConfigs The ChildFtpConfigs object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeFtpConfigs(ChildFtpConfigs $ftpConfigs)
    {
        if ($this->getFtpConfigss()->contains($ftpConfigs)) {
            $pos = $this->collFtpConfigss->search($ftpConfigs);
            $this->collFtpConfigss->remove($pos);
            if (null === $this->ftpConfigssScheduledForDeletion) {
                $this->ftpConfigssScheduledForDeletion = clone $this->collFtpConfigss;
                $this->ftpConfigssScheduledForDeletion->clear();
            }
            $this->ftpConfigssScheduledForDeletion[]= clone $ftpConfigs;
            $ftpConfigs->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collFtpExportBatchess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addFtpExportBatchess()
     */
    public function clearFtpExportBatchess()
    {
        $this->collFtpExportBatchess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collFtpExportBatchess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialFtpExportBatchess($v = true): void
    {
        $this->collFtpExportBatchessPartial = $v;
    }

    /**
     * Initializes the collFtpExportBatchess collection.
     *
     * By default this just sets the collFtpExportBatchess collection to an empty array (like clearcollFtpExportBatchess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initFtpExportBatchess(bool $overrideExisting = true): void
    {
        if (null !== $this->collFtpExportBatchess && !$overrideExisting) {
            return;
        }

        $collectionClassName = FtpExportBatchesTableMap::getTableMap()->getCollectionClassName();

        $this->collFtpExportBatchess = new $collectionClassName;
        $this->collFtpExportBatchess->setModel('\entities\FtpExportBatches');
    }

    /**
     * Gets an array of ChildFtpExportBatches objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildFtpExportBatches[] List of ChildFtpExportBatches objects
     * @phpstan-return ObjectCollection&\Traversable<ChildFtpExportBatches> List of ChildFtpExportBatches objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getFtpExportBatchess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collFtpExportBatchessPartial && !$this->isNew();
        if (null === $this->collFtpExportBatchess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collFtpExportBatchess) {
                    $this->initFtpExportBatchess();
                } else {
                    $collectionClassName = FtpExportBatchesTableMap::getTableMap()->getCollectionClassName();

                    $collFtpExportBatchess = new $collectionClassName;
                    $collFtpExportBatchess->setModel('\entities\FtpExportBatches');

                    return $collFtpExportBatchess;
                }
            } else {
                $collFtpExportBatchess = ChildFtpExportBatchesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collFtpExportBatchessPartial && count($collFtpExportBatchess)) {
                        $this->initFtpExportBatchess(false);

                        foreach ($collFtpExportBatchess as $obj) {
                            if (false == $this->collFtpExportBatchess->contains($obj)) {
                                $this->collFtpExportBatchess->append($obj);
                            }
                        }

                        $this->collFtpExportBatchessPartial = true;
                    }

                    return $collFtpExportBatchess;
                }

                if ($partial && $this->collFtpExportBatchess) {
                    foreach ($this->collFtpExportBatchess as $obj) {
                        if ($obj->isNew()) {
                            $collFtpExportBatchess[] = $obj;
                        }
                    }
                }

                $this->collFtpExportBatchess = $collFtpExportBatchess;
                $this->collFtpExportBatchessPartial = false;
            }
        }

        return $this->collFtpExportBatchess;
    }

    /**
     * Sets a collection of ChildFtpExportBatches objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $ftpExportBatchess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setFtpExportBatchess(Collection $ftpExportBatchess, ?ConnectionInterface $con = null)
    {
        /** @var ChildFtpExportBatches[] $ftpExportBatchessToDelete */
        $ftpExportBatchessToDelete = $this->getFtpExportBatchess(new Criteria(), $con)->diff($ftpExportBatchess);


        $this->ftpExportBatchessScheduledForDeletion = $ftpExportBatchessToDelete;

        foreach ($ftpExportBatchessToDelete as $ftpExportBatchesRemoved) {
            $ftpExportBatchesRemoved->setCompany(null);
        }

        $this->collFtpExportBatchess = null;
        foreach ($ftpExportBatchess as $ftpExportBatches) {
            $this->addFtpExportBatches($ftpExportBatches);
        }

        $this->collFtpExportBatchess = $ftpExportBatchess;
        $this->collFtpExportBatchessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related FtpExportBatches objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related FtpExportBatches objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countFtpExportBatchess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collFtpExportBatchessPartial && !$this->isNew();
        if (null === $this->collFtpExportBatchess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collFtpExportBatchess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getFtpExportBatchess());
            }

            $query = ChildFtpExportBatchesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collFtpExportBatchess);
    }

    /**
     * Method called to associate a ChildFtpExportBatches object to this object
     * through the ChildFtpExportBatches foreign key attribute.
     *
     * @param ChildFtpExportBatches $l ChildFtpExportBatches
     * @return $this The current object (for fluent API support)
     */
    public function addFtpExportBatches(ChildFtpExportBatches $l)
    {
        if ($this->collFtpExportBatchess === null) {
            $this->initFtpExportBatchess();
            $this->collFtpExportBatchessPartial = true;
        }

        if (!$this->collFtpExportBatchess->contains($l)) {
            $this->doAddFtpExportBatches($l);

            if ($this->ftpExportBatchessScheduledForDeletion and $this->ftpExportBatchessScheduledForDeletion->contains($l)) {
                $this->ftpExportBatchessScheduledForDeletion->remove($this->ftpExportBatchessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildFtpExportBatches $ftpExportBatches The ChildFtpExportBatches object to add.
     */
    protected function doAddFtpExportBatches(ChildFtpExportBatches $ftpExportBatches): void
    {
        $this->collFtpExportBatchess[]= $ftpExportBatches;
        $ftpExportBatches->setCompany($this);
    }

    /**
     * @param ChildFtpExportBatches $ftpExportBatches The ChildFtpExportBatches object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeFtpExportBatches(ChildFtpExportBatches $ftpExportBatches)
    {
        if ($this->getFtpExportBatchess()->contains($ftpExportBatches)) {
            $pos = $this->collFtpExportBatchess->search($ftpExportBatches);
            $this->collFtpExportBatchess->remove($pos);
            if (null === $this->ftpExportBatchessScheduledForDeletion) {
                $this->ftpExportBatchessScheduledForDeletion = clone $this->collFtpExportBatchess;
                $this->ftpExportBatchessScheduledForDeletion->clear();
            }
            $this->ftpExportBatchessScheduledForDeletion[]= $ftpExportBatches;
            $ftpExportBatches->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collFtpExportLogss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addFtpExportLogss()
     */
    public function clearFtpExportLogss()
    {
        $this->collFtpExportLogss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collFtpExportLogss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialFtpExportLogss($v = true): void
    {
        $this->collFtpExportLogssPartial = $v;
    }

    /**
     * Initializes the collFtpExportLogss collection.
     *
     * By default this just sets the collFtpExportLogss collection to an empty array (like clearcollFtpExportLogss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initFtpExportLogss(bool $overrideExisting = true): void
    {
        if (null !== $this->collFtpExportLogss && !$overrideExisting) {
            return;
        }

        $collectionClassName = FtpExportLogsTableMap::getTableMap()->getCollectionClassName();

        $this->collFtpExportLogss = new $collectionClassName;
        $this->collFtpExportLogss->setModel('\entities\FtpExportLogs');
    }

    /**
     * Gets an array of ChildFtpExportLogs objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildFtpExportLogs[] List of ChildFtpExportLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildFtpExportLogs> List of ChildFtpExportLogs objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getFtpExportLogss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collFtpExportLogssPartial && !$this->isNew();
        if (null === $this->collFtpExportLogss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collFtpExportLogss) {
                    $this->initFtpExportLogss();
                } else {
                    $collectionClassName = FtpExportLogsTableMap::getTableMap()->getCollectionClassName();

                    $collFtpExportLogss = new $collectionClassName;
                    $collFtpExportLogss->setModel('\entities\FtpExportLogs');

                    return $collFtpExportLogss;
                }
            } else {
                $collFtpExportLogss = ChildFtpExportLogsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collFtpExportLogssPartial && count($collFtpExportLogss)) {
                        $this->initFtpExportLogss(false);

                        foreach ($collFtpExportLogss as $obj) {
                            if (false == $this->collFtpExportLogss->contains($obj)) {
                                $this->collFtpExportLogss->append($obj);
                            }
                        }

                        $this->collFtpExportLogssPartial = true;
                    }

                    return $collFtpExportLogss;
                }

                if ($partial && $this->collFtpExportLogss) {
                    foreach ($this->collFtpExportLogss as $obj) {
                        if ($obj->isNew()) {
                            $collFtpExportLogss[] = $obj;
                        }
                    }
                }

                $this->collFtpExportLogss = $collFtpExportLogss;
                $this->collFtpExportLogssPartial = false;
            }
        }

        return $this->collFtpExportLogss;
    }

    /**
     * Sets a collection of ChildFtpExportLogs objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $ftpExportLogss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setFtpExportLogss(Collection $ftpExportLogss, ?ConnectionInterface $con = null)
    {
        /** @var ChildFtpExportLogs[] $ftpExportLogssToDelete */
        $ftpExportLogssToDelete = $this->getFtpExportLogss(new Criteria(), $con)->diff($ftpExportLogss);


        $this->ftpExportLogssScheduledForDeletion = $ftpExportLogssToDelete;

        foreach ($ftpExportLogssToDelete as $ftpExportLogsRemoved) {
            $ftpExportLogsRemoved->setCompany(null);
        }

        $this->collFtpExportLogss = null;
        foreach ($ftpExportLogss as $ftpExportLogs) {
            $this->addFtpExportLogs($ftpExportLogs);
        }

        $this->collFtpExportLogss = $ftpExportLogss;
        $this->collFtpExportLogssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related FtpExportLogs objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related FtpExportLogs objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countFtpExportLogss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collFtpExportLogssPartial && !$this->isNew();
        if (null === $this->collFtpExportLogss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collFtpExportLogss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getFtpExportLogss());
            }

            $query = ChildFtpExportLogsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collFtpExportLogss);
    }

    /**
     * Method called to associate a ChildFtpExportLogs object to this object
     * through the ChildFtpExportLogs foreign key attribute.
     *
     * @param ChildFtpExportLogs $l ChildFtpExportLogs
     * @return $this The current object (for fluent API support)
     */
    public function addFtpExportLogs(ChildFtpExportLogs $l)
    {
        if ($this->collFtpExportLogss === null) {
            $this->initFtpExportLogss();
            $this->collFtpExportLogssPartial = true;
        }

        if (!$this->collFtpExportLogss->contains($l)) {
            $this->doAddFtpExportLogs($l);

            if ($this->ftpExportLogssScheduledForDeletion and $this->ftpExportLogssScheduledForDeletion->contains($l)) {
                $this->ftpExportLogssScheduledForDeletion->remove($this->ftpExportLogssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildFtpExportLogs $ftpExportLogs The ChildFtpExportLogs object to add.
     */
    protected function doAddFtpExportLogs(ChildFtpExportLogs $ftpExportLogs): void
    {
        $this->collFtpExportLogss[]= $ftpExportLogs;
        $ftpExportLogs->setCompany($this);
    }

    /**
     * @param ChildFtpExportLogs $ftpExportLogs The ChildFtpExportLogs object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeFtpExportLogs(ChildFtpExportLogs $ftpExportLogs)
    {
        if ($this->getFtpExportLogss()->contains($ftpExportLogs)) {
            $pos = $this->collFtpExportLogss->search($ftpExportLogs);
            $this->collFtpExportLogss->remove($pos);
            if (null === $this->ftpExportLogssScheduledForDeletion) {
                $this->ftpExportLogssScheduledForDeletion = clone $this->collFtpExportLogss;
                $this->ftpExportLogssScheduledForDeletion->clear();
            }
            $this->ftpExportLogssScheduledForDeletion[]= $ftpExportLogs;
            $ftpExportLogs->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related FtpExportLogss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildFtpExportLogs[] List of ChildFtpExportLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildFtpExportLogs}> List of ChildFtpExportLogs objects
     */
    public function getFtpExportLogssJoinFtpExportBatches(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildFtpExportLogsQuery::create(null, $criteria);
        $query->joinWith('FtpExportBatches', $joinBehavior);

        return $this->getFtpExportLogss($query, $con);
    }

    /**
     * Clears out the collFtpImportBatchess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addFtpImportBatchess()
     */
    public function clearFtpImportBatchess()
    {
        $this->collFtpImportBatchess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collFtpImportBatchess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialFtpImportBatchess($v = true): void
    {
        $this->collFtpImportBatchessPartial = $v;
    }

    /**
     * Initializes the collFtpImportBatchess collection.
     *
     * By default this just sets the collFtpImportBatchess collection to an empty array (like clearcollFtpImportBatchess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initFtpImportBatchess(bool $overrideExisting = true): void
    {
        if (null !== $this->collFtpImportBatchess && !$overrideExisting) {
            return;
        }

        $collectionClassName = FtpImportBatchesTableMap::getTableMap()->getCollectionClassName();

        $this->collFtpImportBatchess = new $collectionClassName;
        $this->collFtpImportBatchess->setModel('\entities\FtpImportBatches');
    }

    /**
     * Gets an array of ChildFtpImportBatches objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildFtpImportBatches[] List of ChildFtpImportBatches objects
     * @phpstan-return ObjectCollection&\Traversable<ChildFtpImportBatches> List of ChildFtpImportBatches objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getFtpImportBatchess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collFtpImportBatchessPartial && !$this->isNew();
        if (null === $this->collFtpImportBatchess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collFtpImportBatchess) {
                    $this->initFtpImportBatchess();
                } else {
                    $collectionClassName = FtpImportBatchesTableMap::getTableMap()->getCollectionClassName();

                    $collFtpImportBatchess = new $collectionClassName;
                    $collFtpImportBatchess->setModel('\entities\FtpImportBatches');

                    return $collFtpImportBatchess;
                }
            } else {
                $collFtpImportBatchess = ChildFtpImportBatchesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collFtpImportBatchessPartial && count($collFtpImportBatchess)) {
                        $this->initFtpImportBatchess(false);

                        foreach ($collFtpImportBatchess as $obj) {
                            if (false == $this->collFtpImportBatchess->contains($obj)) {
                                $this->collFtpImportBatchess->append($obj);
                            }
                        }

                        $this->collFtpImportBatchessPartial = true;
                    }

                    return $collFtpImportBatchess;
                }

                if ($partial && $this->collFtpImportBatchess) {
                    foreach ($this->collFtpImportBatchess as $obj) {
                        if ($obj->isNew()) {
                            $collFtpImportBatchess[] = $obj;
                        }
                    }
                }

                $this->collFtpImportBatchess = $collFtpImportBatchess;
                $this->collFtpImportBatchessPartial = false;
            }
        }

        return $this->collFtpImportBatchess;
    }

    /**
     * Sets a collection of ChildFtpImportBatches objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $ftpImportBatchess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setFtpImportBatchess(Collection $ftpImportBatchess, ?ConnectionInterface $con = null)
    {
        /** @var ChildFtpImportBatches[] $ftpImportBatchessToDelete */
        $ftpImportBatchessToDelete = $this->getFtpImportBatchess(new Criteria(), $con)->diff($ftpImportBatchess);


        $this->ftpImportBatchessScheduledForDeletion = $ftpImportBatchessToDelete;

        foreach ($ftpImportBatchessToDelete as $ftpImportBatchesRemoved) {
            $ftpImportBatchesRemoved->setCompany(null);
        }

        $this->collFtpImportBatchess = null;
        foreach ($ftpImportBatchess as $ftpImportBatches) {
            $this->addFtpImportBatches($ftpImportBatches);
        }

        $this->collFtpImportBatchess = $ftpImportBatchess;
        $this->collFtpImportBatchessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related FtpImportBatches objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related FtpImportBatches objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countFtpImportBatchess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collFtpImportBatchessPartial && !$this->isNew();
        if (null === $this->collFtpImportBatchess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collFtpImportBatchess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getFtpImportBatchess());
            }

            $query = ChildFtpImportBatchesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collFtpImportBatchess);
    }

    /**
     * Method called to associate a ChildFtpImportBatches object to this object
     * through the ChildFtpImportBatches foreign key attribute.
     *
     * @param ChildFtpImportBatches $l ChildFtpImportBatches
     * @return $this The current object (for fluent API support)
     */
    public function addFtpImportBatches(ChildFtpImportBatches $l)
    {
        if ($this->collFtpImportBatchess === null) {
            $this->initFtpImportBatchess();
            $this->collFtpImportBatchessPartial = true;
        }

        if (!$this->collFtpImportBatchess->contains($l)) {
            $this->doAddFtpImportBatches($l);

            if ($this->ftpImportBatchessScheduledForDeletion and $this->ftpImportBatchessScheduledForDeletion->contains($l)) {
                $this->ftpImportBatchessScheduledForDeletion->remove($this->ftpImportBatchessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildFtpImportBatches $ftpImportBatches The ChildFtpImportBatches object to add.
     */
    protected function doAddFtpImportBatches(ChildFtpImportBatches $ftpImportBatches): void
    {
        $this->collFtpImportBatchess[]= $ftpImportBatches;
        $ftpImportBatches->setCompany($this);
    }

    /**
     * @param ChildFtpImportBatches $ftpImportBatches The ChildFtpImportBatches object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeFtpImportBatches(ChildFtpImportBatches $ftpImportBatches)
    {
        if ($this->getFtpImportBatchess()->contains($ftpImportBatches)) {
            $pos = $this->collFtpImportBatchess->search($ftpImportBatches);
            $this->collFtpImportBatchess->remove($pos);
            if (null === $this->ftpImportBatchessScheduledForDeletion) {
                $this->ftpImportBatchessScheduledForDeletion = clone $this->collFtpImportBatchess;
                $this->ftpImportBatchessScheduledForDeletion->clear();
            }
            $this->ftpImportBatchessScheduledForDeletion[]= $ftpImportBatches;
            $ftpImportBatches->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collFtpImportLogss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addFtpImportLogss()
     */
    public function clearFtpImportLogss()
    {
        $this->collFtpImportLogss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collFtpImportLogss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialFtpImportLogss($v = true): void
    {
        $this->collFtpImportLogssPartial = $v;
    }

    /**
     * Initializes the collFtpImportLogss collection.
     *
     * By default this just sets the collFtpImportLogss collection to an empty array (like clearcollFtpImportLogss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initFtpImportLogss(bool $overrideExisting = true): void
    {
        if (null !== $this->collFtpImportLogss && !$overrideExisting) {
            return;
        }

        $collectionClassName = FtpImportLogsTableMap::getTableMap()->getCollectionClassName();

        $this->collFtpImportLogss = new $collectionClassName;
        $this->collFtpImportLogss->setModel('\entities\FtpImportLogs');
    }

    /**
     * Gets an array of ChildFtpImportLogs objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildFtpImportLogs[] List of ChildFtpImportLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildFtpImportLogs> List of ChildFtpImportLogs objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getFtpImportLogss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collFtpImportLogssPartial && !$this->isNew();
        if (null === $this->collFtpImportLogss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collFtpImportLogss) {
                    $this->initFtpImportLogss();
                } else {
                    $collectionClassName = FtpImportLogsTableMap::getTableMap()->getCollectionClassName();

                    $collFtpImportLogss = new $collectionClassName;
                    $collFtpImportLogss->setModel('\entities\FtpImportLogs');

                    return $collFtpImportLogss;
                }
            } else {
                $collFtpImportLogss = ChildFtpImportLogsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collFtpImportLogssPartial && count($collFtpImportLogss)) {
                        $this->initFtpImportLogss(false);

                        foreach ($collFtpImportLogss as $obj) {
                            if (false == $this->collFtpImportLogss->contains($obj)) {
                                $this->collFtpImportLogss->append($obj);
                            }
                        }

                        $this->collFtpImportLogssPartial = true;
                    }

                    return $collFtpImportLogss;
                }

                if ($partial && $this->collFtpImportLogss) {
                    foreach ($this->collFtpImportLogss as $obj) {
                        if ($obj->isNew()) {
                            $collFtpImportLogss[] = $obj;
                        }
                    }
                }

                $this->collFtpImportLogss = $collFtpImportLogss;
                $this->collFtpImportLogssPartial = false;
            }
        }

        return $this->collFtpImportLogss;
    }

    /**
     * Sets a collection of ChildFtpImportLogs objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $ftpImportLogss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setFtpImportLogss(Collection $ftpImportLogss, ?ConnectionInterface $con = null)
    {
        /** @var ChildFtpImportLogs[] $ftpImportLogssToDelete */
        $ftpImportLogssToDelete = $this->getFtpImportLogss(new Criteria(), $con)->diff($ftpImportLogss);


        $this->ftpImportLogssScheduledForDeletion = $ftpImportLogssToDelete;

        foreach ($ftpImportLogssToDelete as $ftpImportLogsRemoved) {
            $ftpImportLogsRemoved->setCompany(null);
        }

        $this->collFtpImportLogss = null;
        foreach ($ftpImportLogss as $ftpImportLogs) {
            $this->addFtpImportLogs($ftpImportLogs);
        }

        $this->collFtpImportLogss = $ftpImportLogss;
        $this->collFtpImportLogssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related FtpImportLogs objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related FtpImportLogs objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countFtpImportLogss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collFtpImportLogssPartial && !$this->isNew();
        if (null === $this->collFtpImportLogss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collFtpImportLogss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getFtpImportLogss());
            }

            $query = ChildFtpImportLogsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collFtpImportLogss);
    }

    /**
     * Method called to associate a ChildFtpImportLogs object to this object
     * through the ChildFtpImportLogs foreign key attribute.
     *
     * @param ChildFtpImportLogs $l ChildFtpImportLogs
     * @return $this The current object (for fluent API support)
     */
    public function addFtpImportLogs(ChildFtpImportLogs $l)
    {
        if ($this->collFtpImportLogss === null) {
            $this->initFtpImportLogss();
            $this->collFtpImportLogssPartial = true;
        }

        if (!$this->collFtpImportLogss->contains($l)) {
            $this->doAddFtpImportLogs($l);

            if ($this->ftpImportLogssScheduledForDeletion and $this->ftpImportLogssScheduledForDeletion->contains($l)) {
                $this->ftpImportLogssScheduledForDeletion->remove($this->ftpImportLogssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildFtpImportLogs $ftpImportLogs The ChildFtpImportLogs object to add.
     */
    protected function doAddFtpImportLogs(ChildFtpImportLogs $ftpImportLogs): void
    {
        $this->collFtpImportLogss[]= $ftpImportLogs;
        $ftpImportLogs->setCompany($this);
    }

    /**
     * @param ChildFtpImportLogs $ftpImportLogs The ChildFtpImportLogs object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeFtpImportLogs(ChildFtpImportLogs $ftpImportLogs)
    {
        if ($this->getFtpImportLogss()->contains($ftpImportLogs)) {
            $pos = $this->collFtpImportLogss->search($ftpImportLogs);
            $this->collFtpImportLogss->remove($pos);
            if (null === $this->ftpImportLogssScheduledForDeletion) {
                $this->ftpImportLogssScheduledForDeletion = clone $this->collFtpImportLogss;
                $this->ftpImportLogssScheduledForDeletion->clear();
            }
            $this->ftpImportLogssScheduledForDeletion[]= $ftpImportLogs;
            $ftpImportLogs->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related FtpImportLogss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildFtpImportLogs[] List of ChildFtpImportLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildFtpImportLogs}> List of ChildFtpImportLogs objects
     */
    public function getFtpImportLogssJoinFtpImportBatches(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildFtpImportLogsQuery::create(null, $criteria);
        $query->joinWith('FtpImportBatches', $joinBehavior);

        return $this->getFtpImportLogss($query, $con);
    }

    /**
     * Clears out the collGradeMasters collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addGradeMasters()
     */
    public function clearGradeMasters()
    {
        $this->collGradeMasters = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collGradeMasters collection loaded partially.
     *
     * @return void
     */
    public function resetPartialGradeMasters($v = true): void
    {
        $this->collGradeMastersPartial = $v;
    }

    /**
     * Initializes the collGradeMasters collection.
     *
     * By default this just sets the collGradeMasters collection to an empty array (like clearcollGradeMasters());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initGradeMasters(bool $overrideExisting = true): void
    {
        if (null !== $this->collGradeMasters && !$overrideExisting) {
            return;
        }

        $collectionClassName = GradeMasterTableMap::getTableMap()->getCollectionClassName();

        $this->collGradeMasters = new $collectionClassName;
        $this->collGradeMasters->setModel('\entities\GradeMaster');
    }

    /**
     * Gets an array of ChildGradeMaster objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildGradeMaster[] List of ChildGradeMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildGradeMaster> List of ChildGradeMaster objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getGradeMasters(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collGradeMastersPartial && !$this->isNew();
        if (null === $this->collGradeMasters || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collGradeMasters) {
                    $this->initGradeMasters();
                } else {
                    $collectionClassName = GradeMasterTableMap::getTableMap()->getCollectionClassName();

                    $collGradeMasters = new $collectionClassName;
                    $collGradeMasters->setModel('\entities\GradeMaster');

                    return $collGradeMasters;
                }
            } else {
                $collGradeMasters = ChildGradeMasterQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collGradeMastersPartial && count($collGradeMasters)) {
                        $this->initGradeMasters(false);

                        foreach ($collGradeMasters as $obj) {
                            if (false == $this->collGradeMasters->contains($obj)) {
                                $this->collGradeMasters->append($obj);
                            }
                        }

                        $this->collGradeMastersPartial = true;
                    }

                    return $collGradeMasters;
                }

                if ($partial && $this->collGradeMasters) {
                    foreach ($this->collGradeMasters as $obj) {
                        if ($obj->isNew()) {
                            $collGradeMasters[] = $obj;
                        }
                    }
                }

                $this->collGradeMasters = $collGradeMasters;
                $this->collGradeMastersPartial = false;
            }
        }

        return $this->collGradeMasters;
    }

    /**
     * Sets a collection of ChildGradeMaster objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $gradeMasters A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setGradeMasters(Collection $gradeMasters, ?ConnectionInterface $con = null)
    {
        /** @var ChildGradeMaster[] $gradeMastersToDelete */
        $gradeMastersToDelete = $this->getGradeMasters(new Criteria(), $con)->diff($gradeMasters);


        $this->gradeMastersScheduledForDeletion = $gradeMastersToDelete;

        foreach ($gradeMastersToDelete as $gradeMasterRemoved) {
            $gradeMasterRemoved->setCompany(null);
        }

        $this->collGradeMasters = null;
        foreach ($gradeMasters as $gradeMaster) {
            $this->addGradeMaster($gradeMaster);
        }

        $this->collGradeMasters = $gradeMasters;
        $this->collGradeMastersPartial = false;

        return $this;
    }

    /**
     * Returns the number of related GradeMaster objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related GradeMaster objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countGradeMasters(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collGradeMastersPartial && !$this->isNew();
        if (null === $this->collGradeMasters || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collGradeMasters) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getGradeMasters());
            }

            $query = ChildGradeMasterQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collGradeMasters);
    }

    /**
     * Method called to associate a ChildGradeMaster object to this object
     * through the ChildGradeMaster foreign key attribute.
     *
     * @param ChildGradeMaster $l ChildGradeMaster
     * @return $this The current object (for fluent API support)
     */
    public function addGradeMaster(ChildGradeMaster $l)
    {
        if ($this->collGradeMasters === null) {
            $this->initGradeMasters();
            $this->collGradeMastersPartial = true;
        }

        if (!$this->collGradeMasters->contains($l)) {
            $this->doAddGradeMaster($l);

            if ($this->gradeMastersScheduledForDeletion and $this->gradeMastersScheduledForDeletion->contains($l)) {
                $this->gradeMastersScheduledForDeletion->remove($this->gradeMastersScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildGradeMaster $gradeMaster The ChildGradeMaster object to add.
     */
    protected function doAddGradeMaster(ChildGradeMaster $gradeMaster): void
    {
        $this->collGradeMasters[]= $gradeMaster;
        $gradeMaster->setCompany($this);
    }

    /**
     * @param ChildGradeMaster $gradeMaster The ChildGradeMaster object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeGradeMaster(ChildGradeMaster $gradeMaster)
    {
        if ($this->getGradeMasters()->contains($gradeMaster)) {
            $pos = $this->collGradeMasters->search($gradeMaster);
            $this->collGradeMasters->remove($pos);
            if (null === $this->gradeMastersScheduledForDeletion) {
                $this->gradeMastersScheduledForDeletion = clone $this->collGradeMasters;
                $this->gradeMastersScheduledForDeletion->clear();
            }
            $this->gradeMastersScheduledForDeletion[]= clone $gradeMaster;
            $gradeMaster->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collHolidayss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addHolidayss()
     */
    public function clearHolidayss()
    {
        $this->collHolidayss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collHolidayss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialHolidayss($v = true): void
    {
        $this->collHolidayssPartial = $v;
    }

    /**
     * Initializes the collHolidayss collection.
     *
     * By default this just sets the collHolidayss collection to an empty array (like clearcollHolidayss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initHolidayss(bool $overrideExisting = true): void
    {
        if (null !== $this->collHolidayss && !$overrideExisting) {
            return;
        }

        $collectionClassName = HolidaysTableMap::getTableMap()->getCollectionClassName();

        $this->collHolidayss = new $collectionClassName;
        $this->collHolidayss->setModel('\entities\Holidays');
    }

    /**
     * Gets an array of ChildHolidays objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildHolidays[] List of ChildHolidays objects
     * @phpstan-return ObjectCollection&\Traversable<ChildHolidays> List of ChildHolidays objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getHolidayss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collHolidayssPartial && !$this->isNew();
        if (null === $this->collHolidayss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collHolidayss) {
                    $this->initHolidayss();
                } else {
                    $collectionClassName = HolidaysTableMap::getTableMap()->getCollectionClassName();

                    $collHolidayss = new $collectionClassName;
                    $collHolidayss->setModel('\entities\Holidays');

                    return $collHolidayss;
                }
            } else {
                $collHolidayss = ChildHolidaysQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collHolidayssPartial && count($collHolidayss)) {
                        $this->initHolidayss(false);

                        foreach ($collHolidayss as $obj) {
                            if (false == $this->collHolidayss->contains($obj)) {
                                $this->collHolidayss->append($obj);
                            }
                        }

                        $this->collHolidayssPartial = true;
                    }

                    return $collHolidayss;
                }

                if ($partial && $this->collHolidayss) {
                    foreach ($this->collHolidayss as $obj) {
                        if ($obj->isNew()) {
                            $collHolidayss[] = $obj;
                        }
                    }
                }

                $this->collHolidayss = $collHolidayss;
                $this->collHolidayssPartial = false;
            }
        }

        return $this->collHolidayss;
    }

    /**
     * Sets a collection of ChildHolidays objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $holidayss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setHolidayss(Collection $holidayss, ?ConnectionInterface $con = null)
    {
        /** @var ChildHolidays[] $holidayssToDelete */
        $holidayssToDelete = $this->getHolidayss(new Criteria(), $con)->diff($holidayss);


        $this->holidayssScheduledForDeletion = $holidayssToDelete;

        foreach ($holidayssToDelete as $holidaysRemoved) {
            $holidaysRemoved->setCompany(null);
        }

        $this->collHolidayss = null;
        foreach ($holidayss as $holidays) {
            $this->addHolidays($holidays);
        }

        $this->collHolidayss = $holidayss;
        $this->collHolidayssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Holidays objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Holidays objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countHolidayss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collHolidayssPartial && !$this->isNew();
        if (null === $this->collHolidayss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collHolidayss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getHolidayss());
            }

            $query = ChildHolidaysQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collHolidayss);
    }

    /**
     * Method called to associate a ChildHolidays object to this object
     * through the ChildHolidays foreign key attribute.
     *
     * @param ChildHolidays $l ChildHolidays
     * @return $this The current object (for fluent API support)
     */
    public function addHolidays(ChildHolidays $l)
    {
        if ($this->collHolidayss === null) {
            $this->initHolidayss();
            $this->collHolidayssPartial = true;
        }

        if (!$this->collHolidayss->contains($l)) {
            $this->doAddHolidays($l);

            if ($this->holidayssScheduledForDeletion and $this->holidayssScheduledForDeletion->contains($l)) {
                $this->holidayssScheduledForDeletion->remove($this->holidayssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildHolidays $holidays The ChildHolidays object to add.
     */
    protected function doAddHolidays(ChildHolidays $holidays): void
    {
        $this->collHolidayss[]= $holidays;
        $holidays->setCompany($this);
    }

    /**
     * @param ChildHolidays $holidays The ChildHolidays object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeHolidays(ChildHolidays $holidays)
    {
        if ($this->getHolidayss()->contains($holidays)) {
            $pos = $this->collHolidayss->search($holidays);
            $this->collHolidayss->remove($pos);
            if (null === $this->holidayssScheduledForDeletion) {
                $this->holidayssScheduledForDeletion = clone $this->collHolidayss;
                $this->holidayssScheduledForDeletion->clear();
            }
            $this->holidayssScheduledForDeletion[]= $holidays;
            $holidays->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Holidayss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildHolidays[] List of ChildHolidays objects
     * @phpstan-return ObjectCollection&\Traversable<ChildHolidays}> List of ChildHolidays objects
     */
    public function getHolidayssJoinGeoState(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildHolidaysQuery::create(null, $criteria);
        $query->joinWith('GeoState', $joinBehavior);

        return $this->getHolidayss($query, $con);
    }

    /**
     * Clears out the collIntegrationApiLogss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addIntegrationApiLogss()
     */
    public function clearIntegrationApiLogss()
    {
        $this->collIntegrationApiLogss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collIntegrationApiLogss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialIntegrationApiLogss($v = true): void
    {
        $this->collIntegrationApiLogssPartial = $v;
    }

    /**
     * Initializes the collIntegrationApiLogss collection.
     *
     * By default this just sets the collIntegrationApiLogss collection to an empty array (like clearcollIntegrationApiLogss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initIntegrationApiLogss(bool $overrideExisting = true): void
    {
        if (null !== $this->collIntegrationApiLogss && !$overrideExisting) {
            return;
        }

        $collectionClassName = IntegrationApiLogsTableMap::getTableMap()->getCollectionClassName();

        $this->collIntegrationApiLogss = new $collectionClassName;
        $this->collIntegrationApiLogss->setModel('\entities\IntegrationApiLogs');
    }

    /**
     * Gets an array of ChildIntegrationApiLogs objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildIntegrationApiLogs[] List of ChildIntegrationApiLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildIntegrationApiLogs> List of ChildIntegrationApiLogs objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getIntegrationApiLogss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collIntegrationApiLogssPartial && !$this->isNew();
        if (null === $this->collIntegrationApiLogss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collIntegrationApiLogss) {
                    $this->initIntegrationApiLogss();
                } else {
                    $collectionClassName = IntegrationApiLogsTableMap::getTableMap()->getCollectionClassName();

                    $collIntegrationApiLogss = new $collectionClassName;
                    $collIntegrationApiLogss->setModel('\entities\IntegrationApiLogs');

                    return $collIntegrationApiLogss;
                }
            } else {
                $collIntegrationApiLogss = ChildIntegrationApiLogsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collIntegrationApiLogssPartial && count($collIntegrationApiLogss)) {
                        $this->initIntegrationApiLogss(false);

                        foreach ($collIntegrationApiLogss as $obj) {
                            if (false == $this->collIntegrationApiLogss->contains($obj)) {
                                $this->collIntegrationApiLogss->append($obj);
                            }
                        }

                        $this->collIntegrationApiLogssPartial = true;
                    }

                    return $collIntegrationApiLogss;
                }

                if ($partial && $this->collIntegrationApiLogss) {
                    foreach ($this->collIntegrationApiLogss as $obj) {
                        if ($obj->isNew()) {
                            $collIntegrationApiLogss[] = $obj;
                        }
                    }
                }

                $this->collIntegrationApiLogss = $collIntegrationApiLogss;
                $this->collIntegrationApiLogssPartial = false;
            }
        }

        return $this->collIntegrationApiLogss;
    }

    /**
     * Sets a collection of ChildIntegrationApiLogs objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $integrationApiLogss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setIntegrationApiLogss(Collection $integrationApiLogss, ?ConnectionInterface $con = null)
    {
        /** @var ChildIntegrationApiLogs[] $integrationApiLogssToDelete */
        $integrationApiLogssToDelete = $this->getIntegrationApiLogss(new Criteria(), $con)->diff($integrationApiLogss);


        $this->integrationApiLogssScheduledForDeletion = $integrationApiLogssToDelete;

        foreach ($integrationApiLogssToDelete as $integrationApiLogsRemoved) {
            $integrationApiLogsRemoved->setCompany(null);
        }

        $this->collIntegrationApiLogss = null;
        foreach ($integrationApiLogss as $integrationApiLogs) {
            $this->addIntegrationApiLogs($integrationApiLogs);
        }

        $this->collIntegrationApiLogss = $integrationApiLogss;
        $this->collIntegrationApiLogssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related IntegrationApiLogs objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related IntegrationApiLogs objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countIntegrationApiLogss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collIntegrationApiLogssPartial && !$this->isNew();
        if (null === $this->collIntegrationApiLogss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collIntegrationApiLogss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getIntegrationApiLogss());
            }

            $query = ChildIntegrationApiLogsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collIntegrationApiLogss);
    }

    /**
     * Method called to associate a ChildIntegrationApiLogs object to this object
     * through the ChildIntegrationApiLogs foreign key attribute.
     *
     * @param ChildIntegrationApiLogs $l ChildIntegrationApiLogs
     * @return $this The current object (for fluent API support)
     */
    public function addIntegrationApiLogs(ChildIntegrationApiLogs $l)
    {
        if ($this->collIntegrationApiLogss === null) {
            $this->initIntegrationApiLogss();
            $this->collIntegrationApiLogssPartial = true;
        }

        if (!$this->collIntegrationApiLogss->contains($l)) {
            $this->doAddIntegrationApiLogs($l);

            if ($this->integrationApiLogssScheduledForDeletion and $this->integrationApiLogssScheduledForDeletion->contains($l)) {
                $this->integrationApiLogssScheduledForDeletion->remove($this->integrationApiLogssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildIntegrationApiLogs $integrationApiLogs The ChildIntegrationApiLogs object to add.
     */
    protected function doAddIntegrationApiLogs(ChildIntegrationApiLogs $integrationApiLogs): void
    {
        $this->collIntegrationApiLogss[]= $integrationApiLogs;
        $integrationApiLogs->setCompany($this);
    }

    /**
     * @param ChildIntegrationApiLogs $integrationApiLogs The ChildIntegrationApiLogs object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeIntegrationApiLogs(ChildIntegrationApiLogs $integrationApiLogs)
    {
        if ($this->getIntegrationApiLogss()->contains($integrationApiLogs)) {
            $pos = $this->collIntegrationApiLogss->search($integrationApiLogs);
            $this->collIntegrationApiLogss->remove($pos);
            if (null === $this->integrationApiLogssScheduledForDeletion) {
                $this->integrationApiLogssScheduledForDeletion = clone $this->collIntegrationApiLogss;
                $this->integrationApiLogssScheduledForDeletion->clear();
            }
            $this->integrationApiLogssScheduledForDeletion[]= $integrationApiLogs;
            $integrationApiLogs->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collLeaveRequests collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addLeaveRequests()
     */
    public function clearLeaveRequests()
    {
        $this->collLeaveRequests = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collLeaveRequests collection loaded partially.
     *
     * @return void
     */
    public function resetPartialLeaveRequests($v = true): void
    {
        $this->collLeaveRequestsPartial = $v;
    }

    /**
     * Initializes the collLeaveRequests collection.
     *
     * By default this just sets the collLeaveRequests collection to an empty array (like clearcollLeaveRequests());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initLeaveRequests(bool $overrideExisting = true): void
    {
        if (null !== $this->collLeaveRequests && !$overrideExisting) {
            return;
        }

        $collectionClassName = LeaveRequestTableMap::getTableMap()->getCollectionClassName();

        $this->collLeaveRequests = new $collectionClassName;
        $this->collLeaveRequests->setModel('\entities\LeaveRequest');
    }

    /**
     * Gets an array of ChildLeaveRequest objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildLeaveRequest[] List of ChildLeaveRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildLeaveRequest> List of ChildLeaveRequest objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getLeaveRequests(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collLeaveRequestsPartial && !$this->isNew();
        if (null === $this->collLeaveRequests || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collLeaveRequests) {
                    $this->initLeaveRequests();
                } else {
                    $collectionClassName = LeaveRequestTableMap::getTableMap()->getCollectionClassName();

                    $collLeaveRequests = new $collectionClassName;
                    $collLeaveRequests->setModel('\entities\LeaveRequest');

                    return $collLeaveRequests;
                }
            } else {
                $collLeaveRequests = ChildLeaveRequestQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collLeaveRequestsPartial && count($collLeaveRequests)) {
                        $this->initLeaveRequests(false);

                        foreach ($collLeaveRequests as $obj) {
                            if (false == $this->collLeaveRequests->contains($obj)) {
                                $this->collLeaveRequests->append($obj);
                            }
                        }

                        $this->collLeaveRequestsPartial = true;
                    }

                    return $collLeaveRequests;
                }

                if ($partial && $this->collLeaveRequests) {
                    foreach ($this->collLeaveRequests as $obj) {
                        if ($obj->isNew()) {
                            $collLeaveRequests[] = $obj;
                        }
                    }
                }

                $this->collLeaveRequests = $collLeaveRequests;
                $this->collLeaveRequestsPartial = false;
            }
        }

        return $this->collLeaveRequests;
    }

    /**
     * Sets a collection of ChildLeaveRequest objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $leaveRequests A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setLeaveRequests(Collection $leaveRequests, ?ConnectionInterface $con = null)
    {
        /** @var ChildLeaveRequest[] $leaveRequestsToDelete */
        $leaveRequestsToDelete = $this->getLeaveRequests(new Criteria(), $con)->diff($leaveRequests);


        $this->leaveRequestsScheduledForDeletion = $leaveRequestsToDelete;

        foreach ($leaveRequestsToDelete as $leaveRequestRemoved) {
            $leaveRequestRemoved->setCompany(null);
        }

        $this->collLeaveRequests = null;
        foreach ($leaveRequests as $leaveRequest) {
            $this->addLeaveRequest($leaveRequest);
        }

        $this->collLeaveRequests = $leaveRequests;
        $this->collLeaveRequestsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related LeaveRequest objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related LeaveRequest objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countLeaveRequests(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collLeaveRequestsPartial && !$this->isNew();
        if (null === $this->collLeaveRequests || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collLeaveRequests) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getLeaveRequests());
            }

            $query = ChildLeaveRequestQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collLeaveRequests);
    }

    /**
     * Method called to associate a ChildLeaveRequest object to this object
     * through the ChildLeaveRequest foreign key attribute.
     *
     * @param ChildLeaveRequest $l ChildLeaveRequest
     * @return $this The current object (for fluent API support)
     */
    public function addLeaveRequest(ChildLeaveRequest $l)
    {
        if ($this->collLeaveRequests === null) {
            $this->initLeaveRequests();
            $this->collLeaveRequestsPartial = true;
        }

        if (!$this->collLeaveRequests->contains($l)) {
            $this->doAddLeaveRequest($l);

            if ($this->leaveRequestsScheduledForDeletion and $this->leaveRequestsScheduledForDeletion->contains($l)) {
                $this->leaveRequestsScheduledForDeletion->remove($this->leaveRequestsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildLeaveRequest $leaveRequest The ChildLeaveRequest object to add.
     */
    protected function doAddLeaveRequest(ChildLeaveRequest $leaveRequest): void
    {
        $this->collLeaveRequests[]= $leaveRequest;
        $leaveRequest->setCompany($this);
    }

    /**
     * @param ChildLeaveRequest $leaveRequest The ChildLeaveRequest object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeLeaveRequest(ChildLeaveRequest $leaveRequest)
    {
        if ($this->getLeaveRequests()->contains($leaveRequest)) {
            $pos = $this->collLeaveRequests->search($leaveRequest);
            $this->collLeaveRequests->remove($pos);
            if (null === $this->leaveRequestsScheduledForDeletion) {
                $this->leaveRequestsScheduledForDeletion = clone $this->collLeaveRequests;
                $this->leaveRequestsScheduledForDeletion->clear();
            }
            $this->leaveRequestsScheduledForDeletion[]= clone $leaveRequest;
            $leaveRequest->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related LeaveRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildLeaveRequest[] List of ChildLeaveRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildLeaveRequest}> List of ChildLeaveRequest objects
     */
    public function getLeaveRequestsJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildLeaveRequestQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getLeaveRequests($query, $con);
    }

    /**
     * Clears out the collLeavess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addLeavess()
     */
    public function clearLeavess()
    {
        $this->collLeavess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collLeavess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialLeavess($v = true): void
    {
        $this->collLeavessPartial = $v;
    }

    /**
     * Initializes the collLeavess collection.
     *
     * By default this just sets the collLeavess collection to an empty array (like clearcollLeavess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initLeavess(bool $overrideExisting = true): void
    {
        if (null !== $this->collLeavess && !$overrideExisting) {
            return;
        }

        $collectionClassName = LeavesTableMap::getTableMap()->getCollectionClassName();

        $this->collLeavess = new $collectionClassName;
        $this->collLeavess->setModel('\entities\Leaves');
    }

    /**
     * Gets an array of ChildLeaves objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildLeaves[] List of ChildLeaves objects
     * @phpstan-return ObjectCollection&\Traversable<ChildLeaves> List of ChildLeaves objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getLeavess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collLeavessPartial && !$this->isNew();
        if (null === $this->collLeavess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collLeavess) {
                    $this->initLeavess();
                } else {
                    $collectionClassName = LeavesTableMap::getTableMap()->getCollectionClassName();

                    $collLeavess = new $collectionClassName;
                    $collLeavess->setModel('\entities\Leaves');

                    return $collLeavess;
                }
            } else {
                $collLeavess = ChildLeavesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collLeavessPartial && count($collLeavess)) {
                        $this->initLeavess(false);

                        foreach ($collLeavess as $obj) {
                            if (false == $this->collLeavess->contains($obj)) {
                                $this->collLeavess->append($obj);
                            }
                        }

                        $this->collLeavessPartial = true;
                    }

                    return $collLeavess;
                }

                if ($partial && $this->collLeavess) {
                    foreach ($this->collLeavess as $obj) {
                        if ($obj->isNew()) {
                            $collLeavess[] = $obj;
                        }
                    }
                }

                $this->collLeavess = $collLeavess;
                $this->collLeavessPartial = false;
            }
        }

        return $this->collLeavess;
    }

    /**
     * Sets a collection of ChildLeaves objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $leavess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setLeavess(Collection $leavess, ?ConnectionInterface $con = null)
    {
        /** @var ChildLeaves[] $leavessToDelete */
        $leavessToDelete = $this->getLeavess(new Criteria(), $con)->diff($leavess);


        $this->leavessScheduledForDeletion = $leavessToDelete;

        foreach ($leavessToDelete as $leavesRemoved) {
            $leavesRemoved->setCompany(null);
        }

        $this->collLeavess = null;
        foreach ($leavess as $leaves) {
            $this->addLeaves($leaves);
        }

        $this->collLeavess = $leavess;
        $this->collLeavessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Leaves objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Leaves objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countLeavess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collLeavessPartial && !$this->isNew();
        if (null === $this->collLeavess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collLeavess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getLeavess());
            }

            $query = ChildLeavesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collLeavess);
    }

    /**
     * Method called to associate a ChildLeaves object to this object
     * through the ChildLeaves foreign key attribute.
     *
     * @param ChildLeaves $l ChildLeaves
     * @return $this The current object (for fluent API support)
     */
    public function addLeaves(ChildLeaves $l)
    {
        if ($this->collLeavess === null) {
            $this->initLeavess();
            $this->collLeavessPartial = true;
        }

        if (!$this->collLeavess->contains($l)) {
            $this->doAddLeaves($l);

            if ($this->leavessScheduledForDeletion and $this->leavessScheduledForDeletion->contains($l)) {
                $this->leavessScheduledForDeletion->remove($this->leavessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildLeaves $leaves The ChildLeaves object to add.
     */
    protected function doAddLeaves(ChildLeaves $leaves): void
    {
        $this->collLeavess[]= $leaves;
        $leaves->setCompany($this);
    }

    /**
     * @param ChildLeaves $leaves The ChildLeaves object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeLeaves(ChildLeaves $leaves)
    {
        if ($this->getLeavess()->contains($leaves)) {
            $pos = $this->collLeavess->search($leaves);
            $this->collLeavess->remove($pos);
            if (null === $this->leavessScheduledForDeletion) {
                $this->leavessScheduledForDeletion = clone $this->collLeavess;
                $this->leavessScheduledForDeletion->clear();
            }
            $this->leavessScheduledForDeletion[]= $leaves;
            $leaves->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Leavess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildLeaves[] List of ChildLeaves objects
     * @phpstan-return ObjectCollection&\Traversable<ChildLeaves}> List of ChildLeaves objects
     */
    public function getLeavessJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildLeavesQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getLeavess($query, $con);
    }

    /**
     * Clears out the collMaterialFolderss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addMaterialFolderss()
     */
    public function clearMaterialFolderss()
    {
        $this->collMaterialFolderss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collMaterialFolderss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialMaterialFolderss($v = true): void
    {
        $this->collMaterialFolderssPartial = $v;
    }

    /**
     * Initializes the collMaterialFolderss collection.
     *
     * By default this just sets the collMaterialFolderss collection to an empty array (like clearcollMaterialFolderss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMaterialFolderss(bool $overrideExisting = true): void
    {
        if (null !== $this->collMaterialFolderss && !$overrideExisting) {
            return;
        }

        $collectionClassName = MaterialFoldersTableMap::getTableMap()->getCollectionClassName();

        $this->collMaterialFolderss = new $collectionClassName;
        $this->collMaterialFolderss->setModel('\entities\MaterialFolders');
    }

    /**
     * Gets an array of ChildMaterialFolders objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildMaterialFolders[] List of ChildMaterialFolders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMaterialFolders> List of ChildMaterialFolders objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getMaterialFolderss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collMaterialFolderssPartial && !$this->isNew();
        if (null === $this->collMaterialFolderss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collMaterialFolderss) {
                    $this->initMaterialFolderss();
                } else {
                    $collectionClassName = MaterialFoldersTableMap::getTableMap()->getCollectionClassName();

                    $collMaterialFolderss = new $collectionClassName;
                    $collMaterialFolderss->setModel('\entities\MaterialFolders');

                    return $collMaterialFolderss;
                }
            } else {
                $collMaterialFolderss = ChildMaterialFoldersQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collMaterialFolderssPartial && count($collMaterialFolderss)) {
                        $this->initMaterialFolderss(false);

                        foreach ($collMaterialFolderss as $obj) {
                            if (false == $this->collMaterialFolderss->contains($obj)) {
                                $this->collMaterialFolderss->append($obj);
                            }
                        }

                        $this->collMaterialFolderssPartial = true;
                    }

                    return $collMaterialFolderss;
                }

                if ($partial && $this->collMaterialFolderss) {
                    foreach ($this->collMaterialFolderss as $obj) {
                        if ($obj->isNew()) {
                            $collMaterialFolderss[] = $obj;
                        }
                    }
                }

                $this->collMaterialFolderss = $collMaterialFolderss;
                $this->collMaterialFolderssPartial = false;
            }
        }

        return $this->collMaterialFolderss;
    }

    /**
     * Sets a collection of ChildMaterialFolders objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $materialFolderss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setMaterialFolderss(Collection $materialFolderss, ?ConnectionInterface $con = null)
    {
        /** @var ChildMaterialFolders[] $materialFolderssToDelete */
        $materialFolderssToDelete = $this->getMaterialFolderss(new Criteria(), $con)->diff($materialFolderss);


        $this->materialFolderssScheduledForDeletion = $materialFolderssToDelete;

        foreach ($materialFolderssToDelete as $materialFoldersRemoved) {
            $materialFoldersRemoved->setCompany(null);
        }

        $this->collMaterialFolderss = null;
        foreach ($materialFolderss as $materialFolders) {
            $this->addMaterialFolders($materialFolders);
        }

        $this->collMaterialFolderss = $materialFolderss;
        $this->collMaterialFolderssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related MaterialFolders objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related MaterialFolders objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countMaterialFolderss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collMaterialFolderssPartial && !$this->isNew();
        if (null === $this->collMaterialFolderss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMaterialFolderss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getMaterialFolderss());
            }

            $query = ChildMaterialFoldersQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collMaterialFolderss);
    }

    /**
     * Method called to associate a ChildMaterialFolders object to this object
     * through the ChildMaterialFolders foreign key attribute.
     *
     * @param ChildMaterialFolders $l ChildMaterialFolders
     * @return $this The current object (for fluent API support)
     */
    public function addMaterialFolders(ChildMaterialFolders $l)
    {
        if ($this->collMaterialFolderss === null) {
            $this->initMaterialFolderss();
            $this->collMaterialFolderssPartial = true;
        }

        if (!$this->collMaterialFolderss->contains($l)) {
            $this->doAddMaterialFolders($l);

            if ($this->materialFolderssScheduledForDeletion and $this->materialFolderssScheduledForDeletion->contains($l)) {
                $this->materialFolderssScheduledForDeletion->remove($this->materialFolderssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildMaterialFolders $materialFolders The ChildMaterialFolders object to add.
     */
    protected function doAddMaterialFolders(ChildMaterialFolders $materialFolders): void
    {
        $this->collMaterialFolderss[]= $materialFolders;
        $materialFolders->setCompany($this);
    }

    /**
     * @param ChildMaterialFolders $materialFolders The ChildMaterialFolders object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeMaterialFolders(ChildMaterialFolders $materialFolders)
    {
        if ($this->getMaterialFolderss()->contains($materialFolders)) {
            $pos = $this->collMaterialFolderss->search($materialFolders);
            $this->collMaterialFolderss->remove($pos);
            if (null === $this->materialFolderssScheduledForDeletion) {
                $this->materialFolderssScheduledForDeletion = clone $this->collMaterialFolderss;
                $this->materialFolderssScheduledForDeletion->clear();
            }
            $this->materialFolderssScheduledForDeletion[]= $materialFolders;
            $materialFolders->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collMediaFiless collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addMediaFiless()
     */
    public function clearMediaFiless()
    {
        $this->collMediaFiless = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collMediaFiless collection loaded partially.
     *
     * @return void
     */
    public function resetPartialMediaFiless($v = true): void
    {
        $this->collMediaFilessPartial = $v;
    }

    /**
     * Initializes the collMediaFiless collection.
     *
     * By default this just sets the collMediaFiless collection to an empty array (like clearcollMediaFiless());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMediaFiless(bool $overrideExisting = true): void
    {
        if (null !== $this->collMediaFiless && !$overrideExisting) {
            return;
        }

        $collectionClassName = MediaFilesTableMap::getTableMap()->getCollectionClassName();

        $this->collMediaFiless = new $collectionClassName;
        $this->collMediaFiless->setModel('\entities\MediaFiles');
    }

    /**
     * Gets an array of ChildMediaFiles objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildMediaFiles[] List of ChildMediaFiles objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMediaFiles> List of ChildMediaFiles objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getMediaFiless(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collMediaFilessPartial && !$this->isNew();
        if (null === $this->collMediaFiless || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collMediaFiless) {
                    $this->initMediaFiless();
                } else {
                    $collectionClassName = MediaFilesTableMap::getTableMap()->getCollectionClassName();

                    $collMediaFiless = new $collectionClassName;
                    $collMediaFiless->setModel('\entities\MediaFiles');

                    return $collMediaFiless;
                }
            } else {
                $collMediaFiless = ChildMediaFilesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collMediaFilessPartial && count($collMediaFiless)) {
                        $this->initMediaFiless(false);

                        foreach ($collMediaFiless as $obj) {
                            if (false == $this->collMediaFiless->contains($obj)) {
                                $this->collMediaFiless->append($obj);
                            }
                        }

                        $this->collMediaFilessPartial = true;
                    }

                    return $collMediaFiless;
                }

                if ($partial && $this->collMediaFiless) {
                    foreach ($this->collMediaFiless as $obj) {
                        if ($obj->isNew()) {
                            $collMediaFiless[] = $obj;
                        }
                    }
                }

                $this->collMediaFiless = $collMediaFiless;
                $this->collMediaFilessPartial = false;
            }
        }

        return $this->collMediaFiless;
    }

    /**
     * Sets a collection of ChildMediaFiles objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $mediaFiless A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setMediaFiless(Collection $mediaFiless, ?ConnectionInterface $con = null)
    {
        /** @var ChildMediaFiles[] $mediaFilessToDelete */
        $mediaFilessToDelete = $this->getMediaFiless(new Criteria(), $con)->diff($mediaFiless);


        $this->mediaFilessScheduledForDeletion = $mediaFilessToDelete;

        foreach ($mediaFilessToDelete as $mediaFilesRemoved) {
            $mediaFilesRemoved->setCompany(null);
        }

        $this->collMediaFiless = null;
        foreach ($mediaFiless as $mediaFiles) {
            $this->addMediaFiles($mediaFiles);
        }

        $this->collMediaFiless = $mediaFiless;
        $this->collMediaFilessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related MediaFiles objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related MediaFiles objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countMediaFiless(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collMediaFilessPartial && !$this->isNew();
        if (null === $this->collMediaFiless || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMediaFiless) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getMediaFiless());
            }

            $query = ChildMediaFilesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collMediaFiless);
    }

    /**
     * Method called to associate a ChildMediaFiles object to this object
     * through the ChildMediaFiles foreign key attribute.
     *
     * @param ChildMediaFiles $l ChildMediaFiles
     * @return $this The current object (for fluent API support)
     */
    public function addMediaFiles(ChildMediaFiles $l)
    {
        if ($this->collMediaFiless === null) {
            $this->initMediaFiless();
            $this->collMediaFilessPartial = true;
        }

        if (!$this->collMediaFiless->contains($l)) {
            $this->doAddMediaFiles($l);

            if ($this->mediaFilessScheduledForDeletion and $this->mediaFilessScheduledForDeletion->contains($l)) {
                $this->mediaFilessScheduledForDeletion->remove($this->mediaFilessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildMediaFiles $mediaFiles The ChildMediaFiles object to add.
     */
    protected function doAddMediaFiles(ChildMediaFiles $mediaFiles): void
    {
        $this->collMediaFiless[]= $mediaFiles;
        $mediaFiles->setCompany($this);
    }

    /**
     * @param ChildMediaFiles $mediaFiles The ChildMediaFiles object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeMediaFiles(ChildMediaFiles $mediaFiles)
    {
        if ($this->getMediaFiless()->contains($mediaFiles)) {
            $pos = $this->collMediaFiless->search($mediaFiles);
            $this->collMediaFiless->remove($pos);
            if (null === $this->mediaFilessScheduledForDeletion) {
                $this->mediaFilessScheduledForDeletion = clone $this->collMediaFiless;
                $this->mediaFilessScheduledForDeletion->clear();
            }
            $this->mediaFilessScheduledForDeletion[]= $mediaFiles;
            $mediaFiles->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related MediaFiless from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildMediaFiles[] List of ChildMediaFiles objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMediaFiles}> List of ChildMediaFiles objects
     */
    public function getMediaFilessJoinMediaFolders(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildMediaFilesQuery::create(null, $criteria);
        $query->joinWith('MediaFolders', $joinBehavior);

        return $this->getMediaFiless($query, $con);
    }

    /**
     * Clears out the collMediaFolderss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addMediaFolderss()
     */
    public function clearMediaFolderss()
    {
        $this->collMediaFolderss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collMediaFolderss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialMediaFolderss($v = true): void
    {
        $this->collMediaFolderssPartial = $v;
    }

    /**
     * Initializes the collMediaFolderss collection.
     *
     * By default this just sets the collMediaFolderss collection to an empty array (like clearcollMediaFolderss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMediaFolderss(bool $overrideExisting = true): void
    {
        if (null !== $this->collMediaFolderss && !$overrideExisting) {
            return;
        }

        $collectionClassName = MediaFoldersTableMap::getTableMap()->getCollectionClassName();

        $this->collMediaFolderss = new $collectionClassName;
        $this->collMediaFolderss->setModel('\entities\MediaFolders');
    }

    /**
     * Gets an array of ChildMediaFolders objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildMediaFolders[] List of ChildMediaFolders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMediaFolders> List of ChildMediaFolders objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getMediaFolderss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collMediaFolderssPartial && !$this->isNew();
        if (null === $this->collMediaFolderss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collMediaFolderss) {
                    $this->initMediaFolderss();
                } else {
                    $collectionClassName = MediaFoldersTableMap::getTableMap()->getCollectionClassName();

                    $collMediaFolderss = new $collectionClassName;
                    $collMediaFolderss->setModel('\entities\MediaFolders');

                    return $collMediaFolderss;
                }
            } else {
                $collMediaFolderss = ChildMediaFoldersQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collMediaFolderssPartial && count($collMediaFolderss)) {
                        $this->initMediaFolderss(false);

                        foreach ($collMediaFolderss as $obj) {
                            if (false == $this->collMediaFolderss->contains($obj)) {
                                $this->collMediaFolderss->append($obj);
                            }
                        }

                        $this->collMediaFolderssPartial = true;
                    }

                    return $collMediaFolderss;
                }

                if ($partial && $this->collMediaFolderss) {
                    foreach ($this->collMediaFolderss as $obj) {
                        if ($obj->isNew()) {
                            $collMediaFolderss[] = $obj;
                        }
                    }
                }

                $this->collMediaFolderss = $collMediaFolderss;
                $this->collMediaFolderssPartial = false;
            }
        }

        return $this->collMediaFolderss;
    }

    /**
     * Sets a collection of ChildMediaFolders objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $mediaFolderss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setMediaFolderss(Collection $mediaFolderss, ?ConnectionInterface $con = null)
    {
        /** @var ChildMediaFolders[] $mediaFolderssToDelete */
        $mediaFolderssToDelete = $this->getMediaFolderss(new Criteria(), $con)->diff($mediaFolderss);


        $this->mediaFolderssScheduledForDeletion = $mediaFolderssToDelete;

        foreach ($mediaFolderssToDelete as $mediaFoldersRemoved) {
            $mediaFoldersRemoved->setCompany(null);
        }

        $this->collMediaFolderss = null;
        foreach ($mediaFolderss as $mediaFolders) {
            $this->addMediaFolders($mediaFolders);
        }

        $this->collMediaFolderss = $mediaFolderss;
        $this->collMediaFolderssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related MediaFolders objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related MediaFolders objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countMediaFolderss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collMediaFolderssPartial && !$this->isNew();
        if (null === $this->collMediaFolderss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMediaFolderss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getMediaFolderss());
            }

            $query = ChildMediaFoldersQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collMediaFolderss);
    }

    /**
     * Method called to associate a ChildMediaFolders object to this object
     * through the ChildMediaFolders foreign key attribute.
     *
     * @param ChildMediaFolders $l ChildMediaFolders
     * @return $this The current object (for fluent API support)
     */
    public function addMediaFolders(ChildMediaFolders $l)
    {
        if ($this->collMediaFolderss === null) {
            $this->initMediaFolderss();
            $this->collMediaFolderssPartial = true;
        }

        if (!$this->collMediaFolderss->contains($l)) {
            $this->doAddMediaFolders($l);

            if ($this->mediaFolderssScheduledForDeletion and $this->mediaFolderssScheduledForDeletion->contains($l)) {
                $this->mediaFolderssScheduledForDeletion->remove($this->mediaFolderssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildMediaFolders $mediaFolders The ChildMediaFolders object to add.
     */
    protected function doAddMediaFolders(ChildMediaFolders $mediaFolders): void
    {
        $this->collMediaFolderss[]= $mediaFolders;
        $mediaFolders->setCompany($this);
    }

    /**
     * @param ChildMediaFolders $mediaFolders The ChildMediaFolders object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeMediaFolders(ChildMediaFolders $mediaFolders)
    {
        if ($this->getMediaFolderss()->contains($mediaFolders)) {
            $pos = $this->collMediaFolderss->search($mediaFolders);
            $this->collMediaFolderss->remove($pos);
            if (null === $this->mediaFolderssScheduledForDeletion) {
                $this->mediaFolderssScheduledForDeletion = clone $this->collMediaFolderss;
                $this->mediaFolderssScheduledForDeletion->clear();
            }
            $this->mediaFolderssScheduledForDeletion[]= clone $mediaFolders;
            $mediaFolders->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collMtps collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addMtps()
     */
    public function clearMtps()
    {
        $this->collMtps = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collMtps collection loaded partially.
     *
     * @return void
     */
    public function resetPartialMtps($v = true): void
    {
        $this->collMtpsPartial = $v;
    }

    /**
     * Initializes the collMtps collection.
     *
     * By default this just sets the collMtps collection to an empty array (like clearcollMtps());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMtps(bool $overrideExisting = true): void
    {
        if (null !== $this->collMtps && !$overrideExisting) {
            return;
        }

        $collectionClassName = MtpTableMap::getTableMap()->getCollectionClassName();

        $this->collMtps = new $collectionClassName;
        $this->collMtps->setModel('\entities\Mtp');
    }

    /**
     * Gets an array of ChildMtp objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildMtp[] List of ChildMtp objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMtp> List of ChildMtp objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getMtps(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collMtpsPartial && !$this->isNew();
        if (null === $this->collMtps || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collMtps) {
                    $this->initMtps();
                } else {
                    $collectionClassName = MtpTableMap::getTableMap()->getCollectionClassName();

                    $collMtps = new $collectionClassName;
                    $collMtps->setModel('\entities\Mtp');

                    return $collMtps;
                }
            } else {
                $collMtps = ChildMtpQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collMtpsPartial && count($collMtps)) {
                        $this->initMtps(false);

                        foreach ($collMtps as $obj) {
                            if (false == $this->collMtps->contains($obj)) {
                                $this->collMtps->append($obj);
                            }
                        }

                        $this->collMtpsPartial = true;
                    }

                    return $collMtps;
                }

                if ($partial && $this->collMtps) {
                    foreach ($this->collMtps as $obj) {
                        if ($obj->isNew()) {
                            $collMtps[] = $obj;
                        }
                    }
                }

                $this->collMtps = $collMtps;
                $this->collMtpsPartial = false;
            }
        }

        return $this->collMtps;
    }

    /**
     * Sets a collection of ChildMtp objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $mtps A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setMtps(Collection $mtps, ?ConnectionInterface $con = null)
    {
        /** @var ChildMtp[] $mtpsToDelete */
        $mtpsToDelete = $this->getMtps(new Criteria(), $con)->diff($mtps);


        $this->mtpsScheduledForDeletion = $mtpsToDelete;

        foreach ($mtpsToDelete as $mtpRemoved) {
            $mtpRemoved->setCompany(null);
        }

        $this->collMtps = null;
        foreach ($mtps as $mtp) {
            $this->addMtp($mtp);
        }

        $this->collMtps = $mtps;
        $this->collMtpsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Mtp objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Mtp objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countMtps(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collMtpsPartial && !$this->isNew();
        if (null === $this->collMtps || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMtps) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getMtps());
            }

            $query = ChildMtpQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collMtps);
    }

    /**
     * Method called to associate a ChildMtp object to this object
     * through the ChildMtp foreign key attribute.
     *
     * @param ChildMtp $l ChildMtp
     * @return $this The current object (for fluent API support)
     */
    public function addMtp(ChildMtp $l)
    {
        if ($this->collMtps === null) {
            $this->initMtps();
            $this->collMtpsPartial = true;
        }

        if (!$this->collMtps->contains($l)) {
            $this->doAddMtp($l);

            if ($this->mtpsScheduledForDeletion and $this->mtpsScheduledForDeletion->contains($l)) {
                $this->mtpsScheduledForDeletion->remove($this->mtpsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildMtp $mtp The ChildMtp object to add.
     */
    protected function doAddMtp(ChildMtp $mtp): void
    {
        $this->collMtps[]= $mtp;
        $mtp->setCompany($this);
    }

    /**
     * @param ChildMtp $mtp The ChildMtp object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeMtp(ChildMtp $mtp)
    {
        if ($this->getMtps()->contains($mtp)) {
            $pos = $this->collMtps->search($mtp);
            $this->collMtps->remove($pos);
            if (null === $this->mtpsScheduledForDeletion) {
                $this->mtpsScheduledForDeletion = clone $this->collMtps;
                $this->mtpsScheduledForDeletion->clear();
            }
            $this->mtpsScheduledForDeletion[]= clone $mtp;
            $mtp->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Mtps from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildMtp[] List of ChildMtp objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMtp}> List of ChildMtp objects
     */
    public function getMtpsJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildMtpQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getMtps($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Mtps from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildMtp[] List of ChildMtp objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMtp}> List of ChildMtp objects
     */
    public function getMtpsJoinPositions(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildMtpQuery::create(null, $criteria);
        $query->joinWith('Positions', $joinBehavior);

        return $this->getMtps($query, $con);
    }

    /**
     * Clears out the collMtpDays collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addMtpDays()
     */
    public function clearMtpDays()
    {
        $this->collMtpDays = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collMtpDays collection loaded partially.
     *
     * @return void
     */
    public function resetPartialMtpDays($v = true): void
    {
        $this->collMtpDaysPartial = $v;
    }

    /**
     * Initializes the collMtpDays collection.
     *
     * By default this just sets the collMtpDays collection to an empty array (like clearcollMtpDays());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMtpDays(bool $overrideExisting = true): void
    {
        if (null !== $this->collMtpDays && !$overrideExisting) {
            return;
        }

        $collectionClassName = MtpDayTableMap::getTableMap()->getCollectionClassName();

        $this->collMtpDays = new $collectionClassName;
        $this->collMtpDays->setModel('\entities\MtpDay');
    }

    /**
     * Gets an array of ChildMtpDay objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildMtpDay[] List of ChildMtpDay objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMtpDay> List of ChildMtpDay objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getMtpDays(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collMtpDaysPartial && !$this->isNew();
        if (null === $this->collMtpDays || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collMtpDays) {
                    $this->initMtpDays();
                } else {
                    $collectionClassName = MtpDayTableMap::getTableMap()->getCollectionClassName();

                    $collMtpDays = new $collectionClassName;
                    $collMtpDays->setModel('\entities\MtpDay');

                    return $collMtpDays;
                }
            } else {
                $collMtpDays = ChildMtpDayQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collMtpDaysPartial && count($collMtpDays)) {
                        $this->initMtpDays(false);

                        foreach ($collMtpDays as $obj) {
                            if (false == $this->collMtpDays->contains($obj)) {
                                $this->collMtpDays->append($obj);
                            }
                        }

                        $this->collMtpDaysPartial = true;
                    }

                    return $collMtpDays;
                }

                if ($partial && $this->collMtpDays) {
                    foreach ($this->collMtpDays as $obj) {
                        if ($obj->isNew()) {
                            $collMtpDays[] = $obj;
                        }
                    }
                }

                $this->collMtpDays = $collMtpDays;
                $this->collMtpDaysPartial = false;
            }
        }

        return $this->collMtpDays;
    }

    /**
     * Sets a collection of ChildMtpDay objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $mtpDays A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setMtpDays(Collection $mtpDays, ?ConnectionInterface $con = null)
    {
        /** @var ChildMtpDay[] $mtpDaysToDelete */
        $mtpDaysToDelete = $this->getMtpDays(new Criteria(), $con)->diff($mtpDays);


        $this->mtpDaysScheduledForDeletion = $mtpDaysToDelete;

        foreach ($mtpDaysToDelete as $mtpDayRemoved) {
            $mtpDayRemoved->setCompany(null);
        }

        $this->collMtpDays = null;
        foreach ($mtpDays as $mtpDay) {
            $this->addMtpDay($mtpDay);
        }

        $this->collMtpDays = $mtpDays;
        $this->collMtpDaysPartial = false;

        return $this;
    }

    /**
     * Returns the number of related MtpDay objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related MtpDay objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countMtpDays(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collMtpDaysPartial && !$this->isNew();
        if (null === $this->collMtpDays || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMtpDays) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getMtpDays());
            }

            $query = ChildMtpDayQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collMtpDays);
    }

    /**
     * Method called to associate a ChildMtpDay object to this object
     * through the ChildMtpDay foreign key attribute.
     *
     * @param ChildMtpDay $l ChildMtpDay
     * @return $this The current object (for fluent API support)
     */
    public function addMtpDay(ChildMtpDay $l)
    {
        if ($this->collMtpDays === null) {
            $this->initMtpDays();
            $this->collMtpDaysPartial = true;
        }

        if (!$this->collMtpDays->contains($l)) {
            $this->doAddMtpDay($l);

            if ($this->mtpDaysScheduledForDeletion and $this->mtpDaysScheduledForDeletion->contains($l)) {
                $this->mtpDaysScheduledForDeletion->remove($this->mtpDaysScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildMtpDay $mtpDay The ChildMtpDay object to add.
     */
    protected function doAddMtpDay(ChildMtpDay $mtpDay): void
    {
        $this->collMtpDays[]= $mtpDay;
        $mtpDay->setCompany($this);
    }

    /**
     * @param ChildMtpDay $mtpDay The ChildMtpDay object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeMtpDay(ChildMtpDay $mtpDay)
    {
        if ($this->getMtpDays()->contains($mtpDay)) {
            $pos = $this->collMtpDays->search($mtpDay);
            $this->collMtpDays->remove($pos);
            if (null === $this->mtpDaysScheduledForDeletion) {
                $this->mtpDaysScheduledForDeletion = clone $this->collMtpDays;
                $this->mtpDaysScheduledForDeletion->clear();
            }
            $this->mtpDaysScheduledForDeletion[]= $mtpDay;
            $mtpDay->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related MtpDays from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildMtpDay[] List of ChildMtpDay objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMtpDay}> List of ChildMtpDay objects
     */
    public function getMtpDaysJoinMtp(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildMtpDayQuery::create(null, $criteria);
        $query->joinWith('Mtp', $joinBehavior);

        return $this->getMtpDays($query, $con);
    }

    /**
     * Clears out the collMtpLogss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addMtpLogss()
     */
    public function clearMtpLogss()
    {
        $this->collMtpLogss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collMtpLogss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialMtpLogss($v = true): void
    {
        $this->collMtpLogssPartial = $v;
    }

    /**
     * Initializes the collMtpLogss collection.
     *
     * By default this just sets the collMtpLogss collection to an empty array (like clearcollMtpLogss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initMtpLogss(bool $overrideExisting = true): void
    {
        if (null !== $this->collMtpLogss && !$overrideExisting) {
            return;
        }

        $collectionClassName = MtpLogsTableMap::getTableMap()->getCollectionClassName();

        $this->collMtpLogss = new $collectionClassName;
        $this->collMtpLogss->setModel('\entities\MtpLogs');
    }

    /**
     * Gets an array of ChildMtpLogs objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildMtpLogs[] List of ChildMtpLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMtpLogs> List of ChildMtpLogs objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getMtpLogss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collMtpLogssPartial && !$this->isNew();
        if (null === $this->collMtpLogss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collMtpLogss) {
                    $this->initMtpLogss();
                } else {
                    $collectionClassName = MtpLogsTableMap::getTableMap()->getCollectionClassName();

                    $collMtpLogss = new $collectionClassName;
                    $collMtpLogss->setModel('\entities\MtpLogs');

                    return $collMtpLogss;
                }
            } else {
                $collMtpLogss = ChildMtpLogsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collMtpLogssPartial && count($collMtpLogss)) {
                        $this->initMtpLogss(false);

                        foreach ($collMtpLogss as $obj) {
                            if (false == $this->collMtpLogss->contains($obj)) {
                                $this->collMtpLogss->append($obj);
                            }
                        }

                        $this->collMtpLogssPartial = true;
                    }

                    return $collMtpLogss;
                }

                if ($partial && $this->collMtpLogss) {
                    foreach ($this->collMtpLogss as $obj) {
                        if ($obj->isNew()) {
                            $collMtpLogss[] = $obj;
                        }
                    }
                }

                $this->collMtpLogss = $collMtpLogss;
                $this->collMtpLogssPartial = false;
            }
        }

        return $this->collMtpLogss;
    }

    /**
     * Sets a collection of ChildMtpLogs objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $mtpLogss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setMtpLogss(Collection $mtpLogss, ?ConnectionInterface $con = null)
    {
        /** @var ChildMtpLogs[] $mtpLogssToDelete */
        $mtpLogssToDelete = $this->getMtpLogss(new Criteria(), $con)->diff($mtpLogss);


        $this->mtpLogssScheduledForDeletion = $mtpLogssToDelete;

        foreach ($mtpLogssToDelete as $mtpLogsRemoved) {
            $mtpLogsRemoved->setCompany(null);
        }

        $this->collMtpLogss = null;
        foreach ($mtpLogss as $mtpLogs) {
            $this->addMtpLogs($mtpLogs);
        }

        $this->collMtpLogss = $mtpLogss;
        $this->collMtpLogssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related MtpLogs objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related MtpLogs objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countMtpLogss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collMtpLogssPartial && !$this->isNew();
        if (null === $this->collMtpLogss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collMtpLogss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getMtpLogss());
            }

            $query = ChildMtpLogsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collMtpLogss);
    }

    /**
     * Method called to associate a ChildMtpLogs object to this object
     * through the ChildMtpLogs foreign key attribute.
     *
     * @param ChildMtpLogs $l ChildMtpLogs
     * @return $this The current object (for fluent API support)
     */
    public function addMtpLogs(ChildMtpLogs $l)
    {
        if ($this->collMtpLogss === null) {
            $this->initMtpLogss();
            $this->collMtpLogssPartial = true;
        }

        if (!$this->collMtpLogss->contains($l)) {
            $this->doAddMtpLogs($l);

            if ($this->mtpLogssScheduledForDeletion and $this->mtpLogssScheduledForDeletion->contains($l)) {
                $this->mtpLogssScheduledForDeletion->remove($this->mtpLogssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildMtpLogs $mtpLogs The ChildMtpLogs object to add.
     */
    protected function doAddMtpLogs(ChildMtpLogs $mtpLogs): void
    {
        $this->collMtpLogss[]= $mtpLogs;
        $mtpLogs->setCompany($this);
    }

    /**
     * @param ChildMtpLogs $mtpLogs The ChildMtpLogs object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeMtpLogs(ChildMtpLogs $mtpLogs)
    {
        if ($this->getMtpLogss()->contains($mtpLogs)) {
            $pos = $this->collMtpLogss->search($mtpLogs);
            $this->collMtpLogss->remove($pos);
            if (null === $this->mtpLogssScheduledForDeletion) {
                $this->mtpLogssScheduledForDeletion = clone $this->collMtpLogss;
                $this->mtpLogssScheduledForDeletion->clear();
            }
            $this->mtpLogssScheduledForDeletion[]= $mtpLogs;
            $mtpLogs->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related MtpLogss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildMtpLogs[] List of ChildMtpLogs objects
     * @phpstan-return ObjectCollection&\Traversable<ChildMtpLogs}> List of ChildMtpLogs objects
     */
    public function getMtpLogssJoinMtp(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildMtpLogsQuery::create(null, $criteria);
        $query->joinWith('Mtp', $joinBehavior);

        return $this->getMtpLogss($query, $con);
    }

    /**
     * Clears out the collOfferss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOfferss()
     */
    public function clearOfferss()
    {
        $this->collOfferss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOfferss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOfferss($v = true): void
    {
        $this->collOfferssPartial = $v;
    }

    /**
     * Initializes the collOfferss collection.
     *
     * By default this just sets the collOfferss collection to an empty array (like clearcollOfferss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOfferss(bool $overrideExisting = true): void
    {
        if (null !== $this->collOfferss && !$overrideExisting) {
            return;
        }

        $collectionClassName = OffersTableMap::getTableMap()->getCollectionClassName();

        $this->collOfferss = new $collectionClassName;
        $this->collOfferss->setModel('\entities\Offers');
    }

    /**
     * Gets an array of ChildOffers objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOffers[] List of ChildOffers objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOffers> List of ChildOffers objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOfferss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOfferssPartial && !$this->isNew();
        if (null === $this->collOfferss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOfferss) {
                    $this->initOfferss();
                } else {
                    $collectionClassName = OffersTableMap::getTableMap()->getCollectionClassName();

                    $collOfferss = new $collectionClassName;
                    $collOfferss->setModel('\entities\Offers');

                    return $collOfferss;
                }
            } else {
                $collOfferss = ChildOffersQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOfferssPartial && count($collOfferss)) {
                        $this->initOfferss(false);

                        foreach ($collOfferss as $obj) {
                            if (false == $this->collOfferss->contains($obj)) {
                                $this->collOfferss->append($obj);
                            }
                        }

                        $this->collOfferssPartial = true;
                    }

                    return $collOfferss;
                }

                if ($partial && $this->collOfferss) {
                    foreach ($this->collOfferss as $obj) {
                        if ($obj->isNew()) {
                            $collOfferss[] = $obj;
                        }
                    }
                }

                $this->collOfferss = $collOfferss;
                $this->collOfferssPartial = false;
            }
        }

        return $this->collOfferss;
    }

    /**
     * Sets a collection of ChildOffers objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $offerss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOfferss(Collection $offerss, ?ConnectionInterface $con = null)
    {
        /** @var ChildOffers[] $offerssToDelete */
        $offerssToDelete = $this->getOfferss(new Criteria(), $con)->diff($offerss);


        $this->offerssScheduledForDeletion = $offerssToDelete;

        foreach ($offerssToDelete as $offersRemoved) {
            $offersRemoved->setCompany(null);
        }

        $this->collOfferss = null;
        foreach ($offerss as $offers) {
            $this->addOffers($offers);
        }

        $this->collOfferss = $offerss;
        $this->collOfferssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Offers objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Offers objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOfferss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOfferssPartial && !$this->isNew();
        if (null === $this->collOfferss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOfferss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOfferss());
            }

            $query = ChildOffersQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOfferss);
    }

    /**
     * Method called to associate a ChildOffers object to this object
     * through the ChildOffers foreign key attribute.
     *
     * @param ChildOffers $l ChildOffers
     * @return $this The current object (for fluent API support)
     */
    public function addOffers(ChildOffers $l)
    {
        if ($this->collOfferss === null) {
            $this->initOfferss();
            $this->collOfferssPartial = true;
        }

        if (!$this->collOfferss->contains($l)) {
            $this->doAddOffers($l);

            if ($this->offerssScheduledForDeletion and $this->offerssScheduledForDeletion->contains($l)) {
                $this->offerssScheduledForDeletion->remove($this->offerssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOffers $offers The ChildOffers object to add.
     */
    protected function doAddOffers(ChildOffers $offers): void
    {
        $this->collOfferss[]= $offers;
        $offers->setCompany($this);
    }

    /**
     * @param ChildOffers $offers The ChildOffers object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOffers(ChildOffers $offers)
    {
        if ($this->getOfferss()->contains($offers)) {
            $pos = $this->collOfferss->search($offers);
            $this->collOfferss->remove($pos);
            if (null === $this->offerssScheduledForDeletion) {
                $this->offerssScheduledForDeletion = clone $this->collOfferss;
                $this->offerssScheduledForDeletion->clear();
            }
            $this->offerssScheduledForDeletion[]= $offers;
            $offers->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Offerss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOffers[] List of ChildOffers objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOffers}> List of ChildOffers objects
     */
    public function getOfferssJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOffersQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getOfferss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Offerss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOffers[] List of ChildOffers objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOffers}> List of ChildOffers objects
     */
    public function getOfferssJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOffersQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getOfferss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Offerss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOffers[] List of ChildOffers objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOffers}> List of ChildOffers objects
     */
    public function getOfferssJoinMediaFiles(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOffersQuery::create(null, $criteria);
        $query->joinWith('MediaFiles', $joinBehavior);

        return $this->getOfferss($query, $con);
    }

    /**
     * Clears out the collOnBoardRequests collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOnBoardRequests()
     */
    public function clearOnBoardRequests()
    {
        $this->collOnBoardRequests = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOnBoardRequests collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOnBoardRequests($v = true): void
    {
        $this->collOnBoardRequestsPartial = $v;
    }

    /**
     * Initializes the collOnBoardRequests collection.
     *
     * By default this just sets the collOnBoardRequests collection to an empty array (like clearcollOnBoardRequests());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOnBoardRequests(bool $overrideExisting = true): void
    {
        if (null !== $this->collOnBoardRequests && !$overrideExisting) {
            return;
        }

        $collectionClassName = OnBoardRequestTableMap::getTableMap()->getCollectionClassName();

        $this->collOnBoardRequests = new $collectionClassName;
        $this->collOnBoardRequests->setModel('\entities\OnBoardRequest');
    }

    /**
     * Gets an array of ChildOnBoardRequest objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest> List of ChildOnBoardRequest objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOnBoardRequests(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOnBoardRequestsPartial && !$this->isNew();
        if (null === $this->collOnBoardRequests || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOnBoardRequests) {
                    $this->initOnBoardRequests();
                } else {
                    $collectionClassName = OnBoardRequestTableMap::getTableMap()->getCollectionClassName();

                    $collOnBoardRequests = new $collectionClassName;
                    $collOnBoardRequests->setModel('\entities\OnBoardRequest');

                    return $collOnBoardRequests;
                }
            } else {
                $collOnBoardRequests = ChildOnBoardRequestQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOnBoardRequestsPartial && count($collOnBoardRequests)) {
                        $this->initOnBoardRequests(false);

                        foreach ($collOnBoardRequests as $obj) {
                            if (false == $this->collOnBoardRequests->contains($obj)) {
                                $this->collOnBoardRequests->append($obj);
                            }
                        }

                        $this->collOnBoardRequestsPartial = true;
                    }

                    return $collOnBoardRequests;
                }

                if ($partial && $this->collOnBoardRequests) {
                    foreach ($this->collOnBoardRequests as $obj) {
                        if ($obj->isNew()) {
                            $collOnBoardRequests[] = $obj;
                        }
                    }
                }

                $this->collOnBoardRequests = $collOnBoardRequests;
                $this->collOnBoardRequestsPartial = false;
            }
        }

        return $this->collOnBoardRequests;
    }

    /**
     * Sets a collection of ChildOnBoardRequest objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $onBoardRequests A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOnBoardRequests(Collection $onBoardRequests, ?ConnectionInterface $con = null)
    {
        /** @var ChildOnBoardRequest[] $onBoardRequestsToDelete */
        $onBoardRequestsToDelete = $this->getOnBoardRequests(new Criteria(), $con)->diff($onBoardRequests);


        $this->onBoardRequestsScheduledForDeletion = $onBoardRequestsToDelete;

        foreach ($onBoardRequestsToDelete as $onBoardRequestRemoved) {
            $onBoardRequestRemoved->setCompany(null);
        }

        $this->collOnBoardRequests = null;
        foreach ($onBoardRequests as $onBoardRequest) {
            $this->addOnBoardRequest($onBoardRequest);
        }

        $this->collOnBoardRequests = $onBoardRequests;
        $this->collOnBoardRequestsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OnBoardRequest objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OnBoardRequest objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOnBoardRequests(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOnBoardRequestsPartial && !$this->isNew();
        if (null === $this->collOnBoardRequests || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOnBoardRequests) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOnBoardRequests());
            }

            $query = ChildOnBoardRequestQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOnBoardRequests);
    }

    /**
     * Method called to associate a ChildOnBoardRequest object to this object
     * through the ChildOnBoardRequest foreign key attribute.
     *
     * @param ChildOnBoardRequest $l ChildOnBoardRequest
     * @return $this The current object (for fluent API support)
     */
    public function addOnBoardRequest(ChildOnBoardRequest $l)
    {
        if ($this->collOnBoardRequests === null) {
            $this->initOnBoardRequests();
            $this->collOnBoardRequestsPartial = true;
        }

        if (!$this->collOnBoardRequests->contains($l)) {
            $this->doAddOnBoardRequest($l);

            if ($this->onBoardRequestsScheduledForDeletion and $this->onBoardRequestsScheduledForDeletion->contains($l)) {
                $this->onBoardRequestsScheduledForDeletion->remove($this->onBoardRequestsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOnBoardRequest $onBoardRequest The ChildOnBoardRequest object to add.
     */
    protected function doAddOnBoardRequest(ChildOnBoardRequest $onBoardRequest): void
    {
        $this->collOnBoardRequests[]= $onBoardRequest;
        $onBoardRequest->setCompany($this);
    }

    /**
     * @param ChildOnBoardRequest $onBoardRequest The ChildOnBoardRequest object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOnBoardRequest(ChildOnBoardRequest $onBoardRequest)
    {
        if ($this->getOnBoardRequests()->contains($onBoardRequest)) {
            $pos = $this->collOnBoardRequests->search($onBoardRequest);
            $this->collOnBoardRequests->remove($pos);
            if (null === $this->onBoardRequestsScheduledForDeletion) {
                $this->onBoardRequestsScheduledForDeletion = clone $this->collOnBoardRequests;
                $this->onBoardRequestsScheduledForDeletion->clear();
            }
            $this->onBoardRequestsScheduledForDeletion[]= $onBoardRequest;
            $onBoardRequest->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinEmployeeRelatedByApprovedByEmployeeId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByApprovedByEmployeeId', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinPositionsRelatedByApprovedByPositionId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('PositionsRelatedByApprovedByPositionId', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinEmployeeRelatedByCreatedByEmployeeId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByCreatedByEmployeeId', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinPositionsRelatedByCreatedByPositionId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('PositionsRelatedByCreatedByPositionId', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinEmployeeRelatedByFinalApprovedByEmployeeId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByFinalApprovedByEmployeeId', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinPositionsRelatedByFinalApprovedByPositionId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('PositionsRelatedByFinalApprovedByPositionId', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinPositionsRelatedByPosition(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('PositionsRelatedByPosition', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinTerritories(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('Territories', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinEmployeeRelatedByUpdatedByEmployeeId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByUpdatedByEmployeeId', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequests from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequest[] List of ChildOnBoardRequest objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequest}> List of ChildOnBoardRequest objects
     */
    public function getOnBoardRequestsJoinPositionsRelatedByUpdatedByPositionId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestQuery::create(null, $criteria);
        $query->joinWith('PositionsRelatedByUpdatedByPositionId', $joinBehavior);

        return $this->getOnBoardRequests($query, $con);
    }

    /**
     * Clears out the collOnBoardRequestAddresses collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOnBoardRequestAddresses()
     */
    public function clearOnBoardRequestAddresses()
    {
        $this->collOnBoardRequestAddresses = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOnBoardRequestAddresses collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOnBoardRequestAddresses($v = true): void
    {
        $this->collOnBoardRequestAddressesPartial = $v;
    }

    /**
     * Initializes the collOnBoardRequestAddresses collection.
     *
     * By default this just sets the collOnBoardRequestAddresses collection to an empty array (like clearcollOnBoardRequestAddresses());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOnBoardRequestAddresses(bool $overrideExisting = true): void
    {
        if (null !== $this->collOnBoardRequestAddresses && !$overrideExisting) {
            return;
        }

        $collectionClassName = OnBoardRequestAddressTableMap::getTableMap()->getCollectionClassName();

        $this->collOnBoardRequestAddresses = new $collectionClassName;
        $this->collOnBoardRequestAddresses->setModel('\entities\OnBoardRequestAddress');
    }

    /**
     * Gets an array of ChildOnBoardRequestAddress objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress> List of ChildOnBoardRequestAddress objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOnBoardRequestAddresses(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOnBoardRequestAddressesPartial && !$this->isNew();
        if (null === $this->collOnBoardRequestAddresses || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOnBoardRequestAddresses) {
                    $this->initOnBoardRequestAddresses();
                } else {
                    $collectionClassName = OnBoardRequestAddressTableMap::getTableMap()->getCollectionClassName();

                    $collOnBoardRequestAddresses = new $collectionClassName;
                    $collOnBoardRequestAddresses->setModel('\entities\OnBoardRequestAddress');

                    return $collOnBoardRequestAddresses;
                }
            } else {
                $collOnBoardRequestAddresses = ChildOnBoardRequestAddressQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOnBoardRequestAddressesPartial && count($collOnBoardRequestAddresses)) {
                        $this->initOnBoardRequestAddresses(false);

                        foreach ($collOnBoardRequestAddresses as $obj) {
                            if (false == $this->collOnBoardRequestAddresses->contains($obj)) {
                                $this->collOnBoardRequestAddresses->append($obj);
                            }
                        }

                        $this->collOnBoardRequestAddressesPartial = true;
                    }

                    return $collOnBoardRequestAddresses;
                }

                if ($partial && $this->collOnBoardRequestAddresses) {
                    foreach ($this->collOnBoardRequestAddresses as $obj) {
                        if ($obj->isNew()) {
                            $collOnBoardRequestAddresses[] = $obj;
                        }
                    }
                }

                $this->collOnBoardRequestAddresses = $collOnBoardRequestAddresses;
                $this->collOnBoardRequestAddressesPartial = false;
            }
        }

        return $this->collOnBoardRequestAddresses;
    }

    /**
     * Sets a collection of ChildOnBoardRequestAddress objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $onBoardRequestAddresses A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOnBoardRequestAddresses(Collection $onBoardRequestAddresses, ?ConnectionInterface $con = null)
    {
        /** @var ChildOnBoardRequestAddress[] $onBoardRequestAddressesToDelete */
        $onBoardRequestAddressesToDelete = $this->getOnBoardRequestAddresses(new Criteria(), $con)->diff($onBoardRequestAddresses);


        $this->onBoardRequestAddressesScheduledForDeletion = $onBoardRequestAddressesToDelete;

        foreach ($onBoardRequestAddressesToDelete as $onBoardRequestAddressRemoved) {
            $onBoardRequestAddressRemoved->setCompany(null);
        }

        $this->collOnBoardRequestAddresses = null;
        foreach ($onBoardRequestAddresses as $onBoardRequestAddress) {
            $this->addOnBoardRequestAddress($onBoardRequestAddress);
        }

        $this->collOnBoardRequestAddresses = $onBoardRequestAddresses;
        $this->collOnBoardRequestAddressesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OnBoardRequestAddress objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OnBoardRequestAddress objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOnBoardRequestAddresses(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOnBoardRequestAddressesPartial && !$this->isNew();
        if (null === $this->collOnBoardRequestAddresses || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOnBoardRequestAddresses) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOnBoardRequestAddresses());
            }

            $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOnBoardRequestAddresses);
    }

    /**
     * Method called to associate a ChildOnBoardRequestAddress object to this object
     * through the ChildOnBoardRequestAddress foreign key attribute.
     *
     * @param ChildOnBoardRequestAddress $l ChildOnBoardRequestAddress
     * @return $this The current object (for fluent API support)
     */
    public function addOnBoardRequestAddress(ChildOnBoardRequestAddress $l)
    {
        if ($this->collOnBoardRequestAddresses === null) {
            $this->initOnBoardRequestAddresses();
            $this->collOnBoardRequestAddressesPartial = true;
        }

        if (!$this->collOnBoardRequestAddresses->contains($l)) {
            $this->doAddOnBoardRequestAddress($l);

            if ($this->onBoardRequestAddressesScheduledForDeletion and $this->onBoardRequestAddressesScheduledForDeletion->contains($l)) {
                $this->onBoardRequestAddressesScheduledForDeletion->remove($this->onBoardRequestAddressesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOnBoardRequestAddress $onBoardRequestAddress The ChildOnBoardRequestAddress object to add.
     */
    protected function doAddOnBoardRequestAddress(ChildOnBoardRequestAddress $onBoardRequestAddress): void
    {
        $this->collOnBoardRequestAddresses[]= $onBoardRequestAddress;
        $onBoardRequestAddress->setCompany($this);
    }

    /**
     * @param ChildOnBoardRequestAddress $onBoardRequestAddress The ChildOnBoardRequestAddress object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOnBoardRequestAddress(ChildOnBoardRequestAddress $onBoardRequestAddress)
    {
        if ($this->getOnBoardRequestAddresses()->contains($onBoardRequestAddress)) {
            $pos = $this->collOnBoardRequestAddresses->search($onBoardRequestAddress);
            $this->collOnBoardRequestAddresses->remove($pos);
            if (null === $this->onBoardRequestAddressesScheduledForDeletion) {
                $this->onBoardRequestAddressesScheduledForDeletion = clone $this->collOnBoardRequestAddresses;
                $this->onBoardRequestAddressesScheduledForDeletion->clear();
            }
            $this->onBoardRequestAddressesScheduledForDeletion[]= $onBoardRequestAddress;
            $onBoardRequestAddress->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinOutletAddress(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('OutletAddress', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinClassification(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('Classification', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinOutletTags(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('OutletTags', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinBeats(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('Beats', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinGeoCity(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('GeoCity', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinGeoState(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('GeoState', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinOnBoardRequest(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('OnBoardRequest', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequestAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequestAddress[] List of ChildOnBoardRequestAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequestAddress}> List of ChildOnBoardRequestAddress objects
     */
    public function getOnBoardRequestAddressesJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequestAddressQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getOnBoardRequestAddresses($query, $con);
    }

    /**
     * Clears out the collOnBoardRequiredFieldss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOnBoardRequiredFieldss()
     */
    public function clearOnBoardRequiredFieldss()
    {
        $this->collOnBoardRequiredFieldss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOnBoardRequiredFieldss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOnBoardRequiredFieldss($v = true): void
    {
        $this->collOnBoardRequiredFieldssPartial = $v;
    }

    /**
     * Initializes the collOnBoardRequiredFieldss collection.
     *
     * By default this just sets the collOnBoardRequiredFieldss collection to an empty array (like clearcollOnBoardRequiredFieldss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOnBoardRequiredFieldss(bool $overrideExisting = true): void
    {
        if (null !== $this->collOnBoardRequiredFieldss && !$overrideExisting) {
            return;
        }

        $collectionClassName = OnBoardRequiredFieldsTableMap::getTableMap()->getCollectionClassName();

        $this->collOnBoardRequiredFieldss = new $collectionClassName;
        $this->collOnBoardRequiredFieldss->setModel('\entities\OnBoardRequiredFields');
    }

    /**
     * Gets an array of ChildOnBoardRequiredFields objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOnBoardRequiredFields[] List of ChildOnBoardRequiredFields objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequiredFields> List of ChildOnBoardRequiredFields objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOnBoardRequiredFieldss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOnBoardRequiredFieldssPartial && !$this->isNew();
        if (null === $this->collOnBoardRequiredFieldss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOnBoardRequiredFieldss) {
                    $this->initOnBoardRequiredFieldss();
                } else {
                    $collectionClassName = OnBoardRequiredFieldsTableMap::getTableMap()->getCollectionClassName();

                    $collOnBoardRequiredFieldss = new $collectionClassName;
                    $collOnBoardRequiredFieldss->setModel('\entities\OnBoardRequiredFields');

                    return $collOnBoardRequiredFieldss;
                }
            } else {
                $collOnBoardRequiredFieldss = ChildOnBoardRequiredFieldsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOnBoardRequiredFieldssPartial && count($collOnBoardRequiredFieldss)) {
                        $this->initOnBoardRequiredFieldss(false);

                        foreach ($collOnBoardRequiredFieldss as $obj) {
                            if (false == $this->collOnBoardRequiredFieldss->contains($obj)) {
                                $this->collOnBoardRequiredFieldss->append($obj);
                            }
                        }

                        $this->collOnBoardRequiredFieldssPartial = true;
                    }

                    return $collOnBoardRequiredFieldss;
                }

                if ($partial && $this->collOnBoardRequiredFieldss) {
                    foreach ($this->collOnBoardRequiredFieldss as $obj) {
                        if ($obj->isNew()) {
                            $collOnBoardRequiredFieldss[] = $obj;
                        }
                    }
                }

                $this->collOnBoardRequiredFieldss = $collOnBoardRequiredFieldss;
                $this->collOnBoardRequiredFieldssPartial = false;
            }
        }

        return $this->collOnBoardRequiredFieldss;
    }

    /**
     * Sets a collection of ChildOnBoardRequiredFields objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $onBoardRequiredFieldss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOnBoardRequiredFieldss(Collection $onBoardRequiredFieldss, ?ConnectionInterface $con = null)
    {
        /** @var ChildOnBoardRequiredFields[] $onBoardRequiredFieldssToDelete */
        $onBoardRequiredFieldssToDelete = $this->getOnBoardRequiredFieldss(new Criteria(), $con)->diff($onBoardRequiredFieldss);


        $this->onBoardRequiredFieldssScheduledForDeletion = $onBoardRequiredFieldssToDelete;

        foreach ($onBoardRequiredFieldssToDelete as $onBoardRequiredFieldsRemoved) {
            $onBoardRequiredFieldsRemoved->setCompany(null);
        }

        $this->collOnBoardRequiredFieldss = null;
        foreach ($onBoardRequiredFieldss as $onBoardRequiredFields) {
            $this->addOnBoardRequiredFields($onBoardRequiredFields);
        }

        $this->collOnBoardRequiredFieldss = $onBoardRequiredFieldss;
        $this->collOnBoardRequiredFieldssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OnBoardRequiredFields objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OnBoardRequiredFields objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOnBoardRequiredFieldss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOnBoardRequiredFieldssPartial && !$this->isNew();
        if (null === $this->collOnBoardRequiredFieldss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOnBoardRequiredFieldss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOnBoardRequiredFieldss());
            }

            $query = ChildOnBoardRequiredFieldsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOnBoardRequiredFieldss);
    }

    /**
     * Method called to associate a ChildOnBoardRequiredFields object to this object
     * through the ChildOnBoardRequiredFields foreign key attribute.
     *
     * @param ChildOnBoardRequiredFields $l ChildOnBoardRequiredFields
     * @return $this The current object (for fluent API support)
     */
    public function addOnBoardRequiredFields(ChildOnBoardRequiredFields $l)
    {
        if ($this->collOnBoardRequiredFieldss === null) {
            $this->initOnBoardRequiredFieldss();
            $this->collOnBoardRequiredFieldssPartial = true;
        }

        if (!$this->collOnBoardRequiredFieldss->contains($l)) {
            $this->doAddOnBoardRequiredFields($l);

            if ($this->onBoardRequiredFieldssScheduledForDeletion and $this->onBoardRequiredFieldssScheduledForDeletion->contains($l)) {
                $this->onBoardRequiredFieldssScheduledForDeletion->remove($this->onBoardRequiredFieldssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOnBoardRequiredFields $onBoardRequiredFields The ChildOnBoardRequiredFields object to add.
     */
    protected function doAddOnBoardRequiredFields(ChildOnBoardRequiredFields $onBoardRequiredFields): void
    {
        $this->collOnBoardRequiredFieldss[]= $onBoardRequiredFields;
        $onBoardRequiredFields->setCompany($this);
    }

    /**
     * @param ChildOnBoardRequiredFields $onBoardRequiredFields The ChildOnBoardRequiredFields object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOnBoardRequiredFields(ChildOnBoardRequiredFields $onBoardRequiredFields)
    {
        if ($this->getOnBoardRequiredFieldss()->contains($onBoardRequiredFields)) {
            $pos = $this->collOnBoardRequiredFieldss->search($onBoardRequiredFields);
            $this->collOnBoardRequiredFieldss->remove($pos);
            if (null === $this->onBoardRequiredFieldssScheduledForDeletion) {
                $this->onBoardRequiredFieldssScheduledForDeletion = clone $this->collOnBoardRequiredFieldss;
                $this->onBoardRequiredFieldssScheduledForDeletion->clear();
            }
            $this->onBoardRequiredFieldssScheduledForDeletion[]= $onBoardRequiredFields;
            $onBoardRequiredFields->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequiredFieldss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequiredFields[] List of ChildOnBoardRequiredFields objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequiredFields}> List of ChildOnBoardRequiredFields objects
     */
    public function getOnBoardRequiredFieldssJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequiredFieldsQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getOnBoardRequiredFieldss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OnBoardRequiredFieldss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOnBoardRequiredFields[] List of ChildOnBoardRequiredFields objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOnBoardRequiredFields}> List of ChildOnBoardRequiredFields objects
     */
    public function getOnBoardRequiredFieldssJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOnBoardRequiredFieldsQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getOnBoardRequiredFieldss($query, $con);
    }

    /**
     * Clears out the collOrderLogs collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOrderLogs()
     */
    public function clearOrderLogs()
    {
        $this->collOrderLogs = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOrderLogs collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOrderLogs($v = true): void
    {
        $this->collOrderLogsPartial = $v;
    }

    /**
     * Initializes the collOrderLogs collection.
     *
     * By default this just sets the collOrderLogs collection to an empty array (like clearcollOrderLogs());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOrderLogs(bool $overrideExisting = true): void
    {
        if (null !== $this->collOrderLogs && !$overrideExisting) {
            return;
        }

        $collectionClassName = OrderLogTableMap::getTableMap()->getCollectionClassName();

        $this->collOrderLogs = new $collectionClassName;
        $this->collOrderLogs->setModel('\entities\OrderLog');
    }

    /**
     * Gets an array of ChildOrderLog objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOrderLog[] List of ChildOrderLog objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrderLog> List of ChildOrderLog objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOrderLogs(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOrderLogsPartial && !$this->isNew();
        if (null === $this->collOrderLogs || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOrderLogs) {
                    $this->initOrderLogs();
                } else {
                    $collectionClassName = OrderLogTableMap::getTableMap()->getCollectionClassName();

                    $collOrderLogs = new $collectionClassName;
                    $collOrderLogs->setModel('\entities\OrderLog');

                    return $collOrderLogs;
                }
            } else {
                $collOrderLogs = ChildOrderLogQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOrderLogsPartial && count($collOrderLogs)) {
                        $this->initOrderLogs(false);

                        foreach ($collOrderLogs as $obj) {
                            if (false == $this->collOrderLogs->contains($obj)) {
                                $this->collOrderLogs->append($obj);
                            }
                        }

                        $this->collOrderLogsPartial = true;
                    }

                    return $collOrderLogs;
                }

                if ($partial && $this->collOrderLogs) {
                    foreach ($this->collOrderLogs as $obj) {
                        if ($obj->isNew()) {
                            $collOrderLogs[] = $obj;
                        }
                    }
                }

                $this->collOrderLogs = $collOrderLogs;
                $this->collOrderLogsPartial = false;
            }
        }

        return $this->collOrderLogs;
    }

    /**
     * Sets a collection of ChildOrderLog objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $orderLogs A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOrderLogs(Collection $orderLogs, ?ConnectionInterface $con = null)
    {
        /** @var ChildOrderLog[] $orderLogsToDelete */
        $orderLogsToDelete = $this->getOrderLogs(new Criteria(), $con)->diff($orderLogs);


        $this->orderLogsScheduledForDeletion = $orderLogsToDelete;

        foreach ($orderLogsToDelete as $orderLogRemoved) {
            $orderLogRemoved->setCompany(null);
        }

        $this->collOrderLogs = null;
        foreach ($orderLogs as $orderLog) {
            $this->addOrderLog($orderLog);
        }

        $this->collOrderLogs = $orderLogs;
        $this->collOrderLogsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OrderLog objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OrderLog objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOrderLogs(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOrderLogsPartial && !$this->isNew();
        if (null === $this->collOrderLogs || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOrderLogs) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOrderLogs());
            }

            $query = ChildOrderLogQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOrderLogs);
    }

    /**
     * Method called to associate a ChildOrderLog object to this object
     * through the ChildOrderLog foreign key attribute.
     *
     * @param ChildOrderLog $l ChildOrderLog
     * @return $this The current object (for fluent API support)
     */
    public function addOrderLog(ChildOrderLog $l)
    {
        if ($this->collOrderLogs === null) {
            $this->initOrderLogs();
            $this->collOrderLogsPartial = true;
        }

        if (!$this->collOrderLogs->contains($l)) {
            $this->doAddOrderLog($l);

            if ($this->orderLogsScheduledForDeletion and $this->orderLogsScheduledForDeletion->contains($l)) {
                $this->orderLogsScheduledForDeletion->remove($this->orderLogsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOrderLog $orderLog The ChildOrderLog object to add.
     */
    protected function doAddOrderLog(ChildOrderLog $orderLog): void
    {
        $this->collOrderLogs[]= $orderLog;
        $orderLog->setCompany($this);
    }

    /**
     * @param ChildOrderLog $orderLog The ChildOrderLog object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOrderLog(ChildOrderLog $orderLog)
    {
        if ($this->getOrderLogs()->contains($orderLog)) {
            $pos = $this->collOrderLogs->search($orderLog);
            $this->collOrderLogs->remove($pos);
            if (null === $this->orderLogsScheduledForDeletion) {
                $this->orderLogsScheduledForDeletion = clone $this->collOrderLogs;
                $this->orderLogsScheduledForDeletion->clear();
            }
            $this->orderLogsScheduledForDeletion[]= clone $orderLog;
            $orderLog->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OrderLogs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrderLog[] List of ChildOrderLog objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrderLog}> List of ChildOrderLog objects
     */
    public function getOrderLogsJoinOrders(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrderLogQuery::create(null, $criteria);
        $query->joinWith('Orders', $joinBehavior);

        return $this->getOrderLogs($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OrderLogs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrderLog[] List of ChildOrderLog objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrderLog}> List of ChildOrderLog objects
     */
    public function getOrderLogsJoinUsers(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrderLogQuery::create(null, $criteria);
        $query->joinWith('Users', $joinBehavior);

        return $this->getOrderLogs($query, $con);
    }

    /**
     * Clears out the collOrderliness collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOrderliness()
     */
    public function clearOrderliness()
    {
        $this->collOrderliness = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOrderliness collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOrderliness($v = true): void
    {
        $this->collOrderlinessPartial = $v;
    }

    /**
     * Initializes the collOrderliness collection.
     *
     * By default this just sets the collOrderliness collection to an empty array (like clearcollOrderliness());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOrderliness(bool $overrideExisting = true): void
    {
        if (null !== $this->collOrderliness && !$overrideExisting) {
            return;
        }

        $collectionClassName = OrderlinesTableMap::getTableMap()->getCollectionClassName();

        $this->collOrderliness = new $collectionClassName;
        $this->collOrderliness->setModel('\entities\Orderlines');
    }

    /**
     * Gets an array of ChildOrderlines objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOrderlines[] List of ChildOrderlines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrderlines> List of ChildOrderlines objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOrderliness(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOrderlinessPartial && !$this->isNew();
        if (null === $this->collOrderliness || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOrderliness) {
                    $this->initOrderliness();
                } else {
                    $collectionClassName = OrderlinesTableMap::getTableMap()->getCollectionClassName();

                    $collOrderliness = new $collectionClassName;
                    $collOrderliness->setModel('\entities\Orderlines');

                    return $collOrderliness;
                }
            } else {
                $collOrderliness = ChildOrderlinesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOrderlinessPartial && count($collOrderliness)) {
                        $this->initOrderliness(false);

                        foreach ($collOrderliness as $obj) {
                            if (false == $this->collOrderliness->contains($obj)) {
                                $this->collOrderliness->append($obj);
                            }
                        }

                        $this->collOrderlinessPartial = true;
                    }

                    return $collOrderliness;
                }

                if ($partial && $this->collOrderliness) {
                    foreach ($this->collOrderliness as $obj) {
                        if ($obj->isNew()) {
                            $collOrderliness[] = $obj;
                        }
                    }
                }

                $this->collOrderliness = $collOrderliness;
                $this->collOrderlinessPartial = false;
            }
        }

        return $this->collOrderliness;
    }

    /**
     * Sets a collection of ChildOrderlines objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $orderliness A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOrderliness(Collection $orderliness, ?ConnectionInterface $con = null)
    {
        /** @var ChildOrderlines[] $orderlinessToDelete */
        $orderlinessToDelete = $this->getOrderliness(new Criteria(), $con)->diff($orderliness);


        $this->orderlinessScheduledForDeletion = $orderlinessToDelete;

        foreach ($orderlinessToDelete as $orderlinesRemoved) {
            $orderlinesRemoved->setCompany(null);
        }

        $this->collOrderliness = null;
        foreach ($orderliness as $orderlines) {
            $this->addOrderlines($orderlines);
        }

        $this->collOrderliness = $orderliness;
        $this->collOrderlinessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Orderlines objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Orderlines objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOrderliness(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOrderlinessPartial && !$this->isNew();
        if (null === $this->collOrderliness || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOrderliness) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOrderliness());
            }

            $query = ChildOrderlinesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOrderliness);
    }

    /**
     * Method called to associate a ChildOrderlines object to this object
     * through the ChildOrderlines foreign key attribute.
     *
     * @param ChildOrderlines $l ChildOrderlines
     * @return $this The current object (for fluent API support)
     */
    public function addOrderlines(ChildOrderlines $l)
    {
        if ($this->collOrderliness === null) {
            $this->initOrderliness();
            $this->collOrderlinessPartial = true;
        }

        if (!$this->collOrderliness->contains($l)) {
            $this->doAddOrderlines($l);

            if ($this->orderlinessScheduledForDeletion and $this->orderlinessScheduledForDeletion->contains($l)) {
                $this->orderlinessScheduledForDeletion->remove($this->orderlinessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOrderlines $orderlines The ChildOrderlines object to add.
     */
    protected function doAddOrderlines(ChildOrderlines $orderlines): void
    {
        $this->collOrderliness[]= $orderlines;
        $orderlines->setCompany($this);
    }

    /**
     * @param ChildOrderlines $orderlines The ChildOrderlines object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOrderlines(ChildOrderlines $orderlines)
    {
        if ($this->getOrderliness()->contains($orderlines)) {
            $pos = $this->collOrderliness->search($orderlines);
            $this->collOrderliness->remove($pos);
            if (null === $this->orderlinessScheduledForDeletion) {
                $this->orderlinessScheduledForDeletion = clone $this->collOrderliness;
                $this->orderlinessScheduledForDeletion->clear();
            }
            $this->orderlinessScheduledForDeletion[]= clone $orderlines;
            $orderlines->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderliness from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrderlines[] List of ChildOrderlines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrderlines}> List of ChildOrderlines objects
     */
    public function getOrderlinessJoinOrders(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrderlinesQuery::create(null, $criteria);
        $query->joinWith('Orders', $joinBehavior);

        return $this->getOrderliness($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderliness from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrderlines[] List of ChildOrderlines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrderlines}> List of ChildOrderlines objects
     */
    public function getOrderlinessJoinProducts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrderlinesQuery::create(null, $criteria);
        $query->joinWith('Products', $joinBehavior);

        return $this->getOrderliness($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderliness from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrderlines[] List of ChildOrderlines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrderlines}> List of ChildOrderlines objects
     */
    public function getOrderlinessJoinUnitmaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrderlinesQuery::create(null, $criteria);
        $query->joinWith('Unitmaster', $joinBehavior);

        return $this->getOrderliness($query, $con);
    }

    /**
     * Clears out the collOrderss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOrderss()
     */
    public function clearOrderss()
    {
        $this->collOrderss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOrderss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOrderss($v = true): void
    {
        $this->collOrderssPartial = $v;
    }

    /**
     * Initializes the collOrderss collection.
     *
     * By default this just sets the collOrderss collection to an empty array (like clearcollOrderss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOrderss(bool $overrideExisting = true): void
    {
        if (null !== $this->collOrderss && !$overrideExisting) {
            return;
        }

        $collectionClassName = OrdersTableMap::getTableMap()->getCollectionClassName();

        $this->collOrderss = new $collectionClassName;
        $this->collOrderss->setModel('\entities\Orders');
    }

    /**
     * Gets an array of ChildOrders objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOrders[] List of ChildOrders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrders> List of ChildOrders objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOrderss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOrderssPartial && !$this->isNew();
        if (null === $this->collOrderss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOrderss) {
                    $this->initOrderss();
                } else {
                    $collectionClassName = OrdersTableMap::getTableMap()->getCollectionClassName();

                    $collOrderss = new $collectionClassName;
                    $collOrderss->setModel('\entities\Orders');

                    return $collOrderss;
                }
            } else {
                $collOrderss = ChildOrdersQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOrderssPartial && count($collOrderss)) {
                        $this->initOrderss(false);

                        foreach ($collOrderss as $obj) {
                            if (false == $this->collOrderss->contains($obj)) {
                                $this->collOrderss->append($obj);
                            }
                        }

                        $this->collOrderssPartial = true;
                    }

                    return $collOrderss;
                }

                if ($partial && $this->collOrderss) {
                    foreach ($this->collOrderss as $obj) {
                        if ($obj->isNew()) {
                            $collOrderss[] = $obj;
                        }
                    }
                }

                $this->collOrderss = $collOrderss;
                $this->collOrderssPartial = false;
            }
        }

        return $this->collOrderss;
    }

    /**
     * Sets a collection of ChildOrders objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $orderss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOrderss(Collection $orderss, ?ConnectionInterface $con = null)
    {
        /** @var ChildOrders[] $orderssToDelete */
        $orderssToDelete = $this->getOrderss(new Criteria(), $con)->diff($orderss);


        $this->orderssScheduledForDeletion = $orderssToDelete;

        foreach ($orderssToDelete as $ordersRemoved) {
            $ordersRemoved->setCompany(null);
        }

        $this->collOrderss = null;
        foreach ($orderss as $orders) {
            $this->addOrders($orders);
        }

        $this->collOrderss = $orderss;
        $this->collOrderssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Orders objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Orders objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOrderss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOrderssPartial && !$this->isNew();
        if (null === $this->collOrderss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOrderss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOrderss());
            }

            $query = ChildOrdersQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOrderss);
    }

    /**
     * Method called to associate a ChildOrders object to this object
     * through the ChildOrders foreign key attribute.
     *
     * @param ChildOrders $l ChildOrders
     * @return $this The current object (for fluent API support)
     */
    public function addOrders(ChildOrders $l)
    {
        if ($this->collOrderss === null) {
            $this->initOrderss();
            $this->collOrderssPartial = true;
        }

        if (!$this->collOrderss->contains($l)) {
            $this->doAddOrders($l);

            if ($this->orderssScheduledForDeletion and $this->orderssScheduledForDeletion->contains($l)) {
                $this->orderssScheduledForDeletion->remove($this->orderssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOrders $orders The ChildOrders object to add.
     */
    protected function doAddOrders(ChildOrders $orders): void
    {
        $this->collOrderss[]= $orders;
        $orders->setCompany($this);
    }

    /**
     * @param ChildOrders $orders The ChildOrders object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOrders(ChildOrders $orders)
    {
        if ($this->getOrderss()->contains($orders)) {
            $pos = $this->collOrderss->search($orders);
            $this->collOrderss->remove($pos);
            if (null === $this->orderssScheduledForDeletion) {
                $this->orderssScheduledForDeletion = clone $this->collOrderss;
                $this->orderssScheduledForDeletion->clear();
            }
            $this->orderssScheduledForDeletion[]= $orders;
            $orders->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrders[] List of ChildOrders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrders}> List of ChildOrders objects
     */
    public function getOrderssJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrdersQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getOrderss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrders[] List of ChildOrders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrders}> List of ChildOrders objects
     */
    public function getOrderssJoinOutletsRelatedByOutletFrom(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrdersQuery::create(null, $criteria);
        $query->joinWith('OutletsRelatedByOutletFrom', $joinBehavior);

        return $this->getOrderss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrders[] List of ChildOrders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrders}> List of ChildOrders objects
     */
    public function getOrderssJoinOutletsRelatedByOutletTo(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrdersQuery::create(null, $criteria);
        $query->joinWith('OutletsRelatedByOutletTo', $joinBehavior);

        return $this->getOrderss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrders[] List of ChildOrders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrders}> List of ChildOrders objects
     */
    public function getOrderssJoinTerritories(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrdersQuery::create(null, $criteria);
        $query->joinWith('Territories', $joinBehavior);

        return $this->getOrderss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrders[] List of ChildOrders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrders}> List of ChildOrders objects
     */
    public function getOrderssJoinBeats(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrdersQuery::create(null, $criteria);
        $query->joinWith('Beats', $joinBehavior);

        return $this->getOrderss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Orderss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrders[] List of ChildOrders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrders}> List of ChildOrders objects
     */
    public function getOrderssJoinPricebooks(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrdersQuery::create(null, $criteria);
        $query->joinWith('Pricebooks', $joinBehavior);

        return $this->getOrderss($query, $con);
    }

    /**
     * Clears out the collOrgUnits collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOrgUnits()
     */
    public function clearOrgUnits()
    {
        $this->collOrgUnits = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOrgUnits collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOrgUnits($v = true): void
    {
        $this->collOrgUnitsPartial = $v;
    }

    /**
     * Initializes the collOrgUnits collection.
     *
     * By default this just sets the collOrgUnits collection to an empty array (like clearcollOrgUnits());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOrgUnits(bool $overrideExisting = true): void
    {
        if (null !== $this->collOrgUnits && !$overrideExisting) {
            return;
        }

        $collectionClassName = OrgUnitTableMap::getTableMap()->getCollectionClassName();

        $this->collOrgUnits = new $collectionClassName;
        $this->collOrgUnits->setModel('\entities\OrgUnit');
    }

    /**
     * Gets an array of ChildOrgUnit objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOrgUnit[] List of ChildOrgUnit objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrgUnit> List of ChildOrgUnit objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOrgUnits(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOrgUnitsPartial && !$this->isNew();
        if (null === $this->collOrgUnits || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOrgUnits) {
                    $this->initOrgUnits();
                } else {
                    $collectionClassName = OrgUnitTableMap::getTableMap()->getCollectionClassName();

                    $collOrgUnits = new $collectionClassName;
                    $collOrgUnits->setModel('\entities\OrgUnit');

                    return $collOrgUnits;
                }
            } else {
                $collOrgUnits = ChildOrgUnitQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOrgUnitsPartial && count($collOrgUnits)) {
                        $this->initOrgUnits(false);

                        foreach ($collOrgUnits as $obj) {
                            if (false == $this->collOrgUnits->contains($obj)) {
                                $this->collOrgUnits->append($obj);
                            }
                        }

                        $this->collOrgUnitsPartial = true;
                    }

                    return $collOrgUnits;
                }

                if ($partial && $this->collOrgUnits) {
                    foreach ($this->collOrgUnits as $obj) {
                        if ($obj->isNew()) {
                            $collOrgUnits[] = $obj;
                        }
                    }
                }

                $this->collOrgUnits = $collOrgUnits;
                $this->collOrgUnitsPartial = false;
            }
        }

        return $this->collOrgUnits;
    }

    /**
     * Sets a collection of ChildOrgUnit objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $orgUnits A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOrgUnits(Collection $orgUnits, ?ConnectionInterface $con = null)
    {
        /** @var ChildOrgUnit[] $orgUnitsToDelete */
        $orgUnitsToDelete = $this->getOrgUnits(new Criteria(), $con)->diff($orgUnits);


        $this->orgUnitsScheduledForDeletion = $orgUnitsToDelete;

        foreach ($orgUnitsToDelete as $orgUnitRemoved) {
            $orgUnitRemoved->setCompany(null);
        }

        $this->collOrgUnits = null;
        foreach ($orgUnits as $orgUnit) {
            $this->addOrgUnit($orgUnit);
        }

        $this->collOrgUnits = $orgUnits;
        $this->collOrgUnitsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OrgUnit objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OrgUnit objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOrgUnits(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOrgUnitsPartial && !$this->isNew();
        if (null === $this->collOrgUnits || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOrgUnits) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOrgUnits());
            }

            $query = ChildOrgUnitQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOrgUnits);
    }

    /**
     * Method called to associate a ChildOrgUnit object to this object
     * through the ChildOrgUnit foreign key attribute.
     *
     * @param ChildOrgUnit $l ChildOrgUnit
     * @return $this The current object (for fluent API support)
     */
    public function addOrgUnit(ChildOrgUnit $l)
    {
        if ($this->collOrgUnits === null) {
            $this->initOrgUnits();
            $this->collOrgUnitsPartial = true;
        }

        if (!$this->collOrgUnits->contains($l)) {
            $this->doAddOrgUnit($l);

            if ($this->orgUnitsScheduledForDeletion and $this->orgUnitsScheduledForDeletion->contains($l)) {
                $this->orgUnitsScheduledForDeletion->remove($this->orgUnitsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOrgUnit $orgUnit The ChildOrgUnit object to add.
     */
    protected function doAddOrgUnit(ChildOrgUnit $orgUnit): void
    {
        $this->collOrgUnits[]= $orgUnit;
        $orgUnit->setCompany($this);
    }

    /**
     * @param ChildOrgUnit $orgUnit The ChildOrgUnit object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOrgUnit(ChildOrgUnit $orgUnit)
    {
        if ($this->getOrgUnits()->contains($orgUnit)) {
            $pos = $this->collOrgUnits->search($orgUnit);
            $this->collOrgUnits->remove($pos);
            if (null === $this->orgUnitsScheduledForDeletion) {
                $this->orgUnitsScheduledForDeletion = clone $this->collOrgUnits;
                $this->orgUnitsScheduledForDeletion->clear();
            }
            $this->orgUnitsScheduledForDeletion[]= clone $orgUnit;
            $orgUnit->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OrgUnits from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrgUnit[] List of ChildOrgUnit objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrgUnit}> List of ChildOrgUnit objects
     */
    public function getOrgUnitsJoinGeoCountry(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrgUnitQuery::create(null, $criteria);
        $query->joinWith('GeoCountry', $joinBehavior);

        return $this->getOrgUnits($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OrgUnits from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOrgUnit[] List of ChildOrgUnit objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOrgUnit}> List of ChildOrgUnit objects
     */
    public function getOrgUnitsJoinCurrencies(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOrgUnitQuery::create(null, $criteria);
        $query->joinWith('Currencies', $joinBehavior);

        return $this->getOrgUnits($query, $con);
    }

    /**
     * Clears out the collOtpRequestss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOtpRequestss()
     */
    public function clearOtpRequestss()
    {
        $this->collOtpRequestss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOtpRequestss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOtpRequestss($v = true): void
    {
        $this->collOtpRequestssPartial = $v;
    }

    /**
     * Initializes the collOtpRequestss collection.
     *
     * By default this just sets the collOtpRequestss collection to an empty array (like clearcollOtpRequestss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOtpRequestss(bool $overrideExisting = true): void
    {
        if (null !== $this->collOtpRequestss && !$overrideExisting) {
            return;
        }

        $collectionClassName = OtpRequestsTableMap::getTableMap()->getCollectionClassName();

        $this->collOtpRequestss = new $collectionClassName;
        $this->collOtpRequestss->setModel('\entities\OtpRequests');
    }

    /**
     * Gets an array of ChildOtpRequests objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOtpRequests[] List of ChildOtpRequests objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOtpRequests> List of ChildOtpRequests objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOtpRequestss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOtpRequestssPartial && !$this->isNew();
        if (null === $this->collOtpRequestss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOtpRequestss) {
                    $this->initOtpRequestss();
                } else {
                    $collectionClassName = OtpRequestsTableMap::getTableMap()->getCollectionClassName();

                    $collOtpRequestss = new $collectionClassName;
                    $collOtpRequestss->setModel('\entities\OtpRequests');

                    return $collOtpRequestss;
                }
            } else {
                $collOtpRequestss = ChildOtpRequestsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOtpRequestssPartial && count($collOtpRequestss)) {
                        $this->initOtpRequestss(false);

                        foreach ($collOtpRequestss as $obj) {
                            if (false == $this->collOtpRequestss->contains($obj)) {
                                $this->collOtpRequestss->append($obj);
                            }
                        }

                        $this->collOtpRequestssPartial = true;
                    }

                    return $collOtpRequestss;
                }

                if ($partial && $this->collOtpRequestss) {
                    foreach ($this->collOtpRequestss as $obj) {
                        if ($obj->isNew()) {
                            $collOtpRequestss[] = $obj;
                        }
                    }
                }

                $this->collOtpRequestss = $collOtpRequestss;
                $this->collOtpRequestssPartial = false;
            }
        }

        return $this->collOtpRequestss;
    }

    /**
     * Sets a collection of ChildOtpRequests objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $otpRequestss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOtpRequestss(Collection $otpRequestss, ?ConnectionInterface $con = null)
    {
        /** @var ChildOtpRequests[] $otpRequestssToDelete */
        $otpRequestssToDelete = $this->getOtpRequestss(new Criteria(), $con)->diff($otpRequestss);


        $this->otpRequestssScheduledForDeletion = $otpRequestssToDelete;

        foreach ($otpRequestssToDelete as $otpRequestsRemoved) {
            $otpRequestsRemoved->setCompany(null);
        }

        $this->collOtpRequestss = null;
        foreach ($otpRequestss as $otpRequests) {
            $this->addOtpRequests($otpRequests);
        }

        $this->collOtpRequestss = $otpRequestss;
        $this->collOtpRequestssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OtpRequests objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OtpRequests objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOtpRequestss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOtpRequestssPartial && !$this->isNew();
        if (null === $this->collOtpRequestss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOtpRequestss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOtpRequestss());
            }

            $query = ChildOtpRequestsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOtpRequestss);
    }

    /**
     * Method called to associate a ChildOtpRequests object to this object
     * through the ChildOtpRequests foreign key attribute.
     *
     * @param ChildOtpRequests $l ChildOtpRequests
     * @return $this The current object (for fluent API support)
     */
    public function addOtpRequests(ChildOtpRequests $l)
    {
        if ($this->collOtpRequestss === null) {
            $this->initOtpRequestss();
            $this->collOtpRequestssPartial = true;
        }

        if (!$this->collOtpRequestss->contains($l)) {
            $this->doAddOtpRequests($l);

            if ($this->otpRequestssScheduledForDeletion and $this->otpRequestssScheduledForDeletion->contains($l)) {
                $this->otpRequestssScheduledForDeletion->remove($this->otpRequestssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOtpRequests $otpRequests The ChildOtpRequests object to add.
     */
    protected function doAddOtpRequests(ChildOtpRequests $otpRequests): void
    {
        $this->collOtpRequestss[]= $otpRequests;
        $otpRequests->setCompany($this);
    }

    /**
     * @param ChildOtpRequests $otpRequests The ChildOtpRequests object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOtpRequests(ChildOtpRequests $otpRequests)
    {
        if ($this->getOtpRequestss()->contains($otpRequests)) {
            $pos = $this->collOtpRequestss->search($otpRequests);
            $this->collOtpRequestss->remove($pos);
            if (null === $this->otpRequestssScheduledForDeletion) {
                $this->otpRequestssScheduledForDeletion = clone $this->collOtpRequestss;
                $this->otpRequestssScheduledForDeletion->clear();
            }
            $this->otpRequestssScheduledForDeletion[]= clone $otpRequests;
            $otpRequests->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OtpRequestss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOtpRequests[] List of ChildOtpRequests objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOtpRequests}> List of ChildOtpRequests objects
     */
    public function getOtpRequestssJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOtpRequestsQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getOtpRequestss($query, $con);
    }

    /**
     * Clears out the collOutletAddresses collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletAddresses()
     */
    public function clearOutletAddresses()
    {
        $this->collOutletAddresses = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletAddresses collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletAddresses($v = true): void
    {
        $this->collOutletAddressesPartial = $v;
    }

    /**
     * Initializes the collOutletAddresses collection.
     *
     * By default this just sets the collOutletAddresses collection to an empty array (like clearcollOutletAddresses());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletAddresses(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletAddresses && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletAddressTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletAddresses = new $collectionClassName;
        $this->collOutletAddresses->setModel('\entities\OutletAddress');
    }

    /**
     * Gets an array of ChildOutletAddress objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletAddress[] List of ChildOutletAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletAddress> List of ChildOutletAddress objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletAddresses(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletAddressesPartial && !$this->isNew();
        if (null === $this->collOutletAddresses || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletAddresses) {
                    $this->initOutletAddresses();
                } else {
                    $collectionClassName = OutletAddressTableMap::getTableMap()->getCollectionClassName();

                    $collOutletAddresses = new $collectionClassName;
                    $collOutletAddresses->setModel('\entities\OutletAddress');

                    return $collOutletAddresses;
                }
            } else {
                $collOutletAddresses = ChildOutletAddressQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletAddressesPartial && count($collOutletAddresses)) {
                        $this->initOutletAddresses(false);

                        foreach ($collOutletAddresses as $obj) {
                            if (false == $this->collOutletAddresses->contains($obj)) {
                                $this->collOutletAddresses->append($obj);
                            }
                        }

                        $this->collOutletAddressesPartial = true;
                    }

                    return $collOutletAddresses;
                }

                if ($partial && $this->collOutletAddresses) {
                    foreach ($this->collOutletAddresses as $obj) {
                        if ($obj->isNew()) {
                            $collOutletAddresses[] = $obj;
                        }
                    }
                }

                $this->collOutletAddresses = $collOutletAddresses;
                $this->collOutletAddressesPartial = false;
            }
        }

        return $this->collOutletAddresses;
    }

    /**
     * Sets a collection of ChildOutletAddress objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletAddresses A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletAddresses(Collection $outletAddresses, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletAddress[] $outletAddressesToDelete */
        $outletAddressesToDelete = $this->getOutletAddresses(new Criteria(), $con)->diff($outletAddresses);


        $this->outletAddressesScheduledForDeletion = $outletAddressesToDelete;

        foreach ($outletAddressesToDelete as $outletAddressRemoved) {
            $outletAddressRemoved->setCompany(null);
        }

        $this->collOutletAddresses = null;
        foreach ($outletAddresses as $outletAddress) {
            $this->addOutletAddress($outletAddress);
        }

        $this->collOutletAddresses = $outletAddresses;
        $this->collOutletAddressesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletAddress objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletAddress objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletAddresses(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletAddressesPartial && !$this->isNew();
        if (null === $this->collOutletAddresses || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletAddresses) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletAddresses());
            }

            $query = ChildOutletAddressQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletAddresses);
    }

    /**
     * Method called to associate a ChildOutletAddress object to this object
     * through the ChildOutletAddress foreign key attribute.
     *
     * @param ChildOutletAddress $l ChildOutletAddress
     * @return $this The current object (for fluent API support)
     */
    public function addOutletAddress(ChildOutletAddress $l)
    {
        if ($this->collOutletAddresses === null) {
            $this->initOutletAddresses();
            $this->collOutletAddressesPartial = true;
        }

        if (!$this->collOutletAddresses->contains($l)) {
            $this->doAddOutletAddress($l);

            if ($this->outletAddressesScheduledForDeletion and $this->outletAddressesScheduledForDeletion->contains($l)) {
                $this->outletAddressesScheduledForDeletion->remove($this->outletAddressesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletAddress $outletAddress The ChildOutletAddress object to add.
     */
    protected function doAddOutletAddress(ChildOutletAddress $outletAddress): void
    {
        $this->collOutletAddresses[]= $outletAddress;
        $outletAddress->setCompany($this);
    }

    /**
     * @param ChildOutletAddress $outletAddress The ChildOutletAddress object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletAddress(ChildOutletAddress $outletAddress)
    {
        if ($this->getOutletAddresses()->contains($outletAddress)) {
            $pos = $this->collOutletAddresses->search($outletAddress);
            $this->collOutletAddresses->remove($pos);
            if (null === $this->outletAddressesScheduledForDeletion) {
                $this->outletAddressesScheduledForDeletion = clone $this->collOutletAddresses;
                $this->outletAddressesScheduledForDeletion->clear();
            }
            $this->outletAddressesScheduledForDeletion[]= $outletAddress;
            $outletAddress->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletAddress[] List of ChildOutletAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletAddress}> List of ChildOutletAddress objects
     */
    public function getOutletAddressesJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletAddressQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getOutletAddresses($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletAddresses from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletAddress[] List of ChildOutletAddress objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletAddress}> List of ChildOutletAddress objects
     */
    public function getOutletAddressesJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletAddressQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getOutletAddresses($query, $con);
    }

    /**
     * Clears out the collOutletOrgDatas collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletOrgDatas()
     */
    public function clearOutletOrgDatas()
    {
        $this->collOutletOrgDatas = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletOrgDatas collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletOrgDatas($v = true): void
    {
        $this->collOutletOrgDatasPartial = $v;
    }

    /**
     * Initializes the collOutletOrgDatas collection.
     *
     * By default this just sets the collOutletOrgDatas collection to an empty array (like clearcollOutletOrgDatas());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletOrgDatas(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletOrgDatas && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletOrgDataTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletOrgDatas = new $collectionClassName;
        $this->collOutletOrgDatas->setModel('\entities\OutletOrgData');
    }

    /**
     * Gets an array of ChildOutletOrgData objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletOrgData[] List of ChildOutletOrgData objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgData> List of ChildOutletOrgData objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletOrgDatas(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletOrgDatasPartial && !$this->isNew();
        if (null === $this->collOutletOrgDatas || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletOrgDatas) {
                    $this->initOutletOrgDatas();
                } else {
                    $collectionClassName = OutletOrgDataTableMap::getTableMap()->getCollectionClassName();

                    $collOutletOrgDatas = new $collectionClassName;
                    $collOutletOrgDatas->setModel('\entities\OutletOrgData');

                    return $collOutletOrgDatas;
                }
            } else {
                $collOutletOrgDatas = ChildOutletOrgDataQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletOrgDatasPartial && count($collOutletOrgDatas)) {
                        $this->initOutletOrgDatas(false);

                        foreach ($collOutletOrgDatas as $obj) {
                            if (false == $this->collOutletOrgDatas->contains($obj)) {
                                $this->collOutletOrgDatas->append($obj);
                            }
                        }

                        $this->collOutletOrgDatasPartial = true;
                    }

                    return $collOutletOrgDatas;
                }

                if ($partial && $this->collOutletOrgDatas) {
                    foreach ($this->collOutletOrgDatas as $obj) {
                        if ($obj->isNew()) {
                            $collOutletOrgDatas[] = $obj;
                        }
                    }
                }

                $this->collOutletOrgDatas = $collOutletOrgDatas;
                $this->collOutletOrgDatasPartial = false;
            }
        }

        return $this->collOutletOrgDatas;
    }

    /**
     * Sets a collection of ChildOutletOrgData objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletOrgDatas A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletOrgDatas(Collection $outletOrgDatas, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletOrgData[] $outletOrgDatasToDelete */
        $outletOrgDatasToDelete = $this->getOutletOrgDatas(new Criteria(), $con)->diff($outletOrgDatas);


        $this->outletOrgDatasScheduledForDeletion = $outletOrgDatasToDelete;

        foreach ($outletOrgDatasToDelete as $outletOrgDataRemoved) {
            $outletOrgDataRemoved->setCompany(null);
        }

        $this->collOutletOrgDatas = null;
        foreach ($outletOrgDatas as $outletOrgData) {
            $this->addOutletOrgData($outletOrgData);
        }

        $this->collOutletOrgDatas = $outletOrgDatas;
        $this->collOutletOrgDatasPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletOrgData objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletOrgData objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletOrgDatas(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletOrgDatasPartial && !$this->isNew();
        if (null === $this->collOutletOrgDatas || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletOrgDatas) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletOrgDatas());
            }

            $query = ChildOutletOrgDataQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletOrgDatas);
    }

    /**
     * Method called to associate a ChildOutletOrgData object to this object
     * through the ChildOutletOrgData foreign key attribute.
     *
     * @param ChildOutletOrgData $l ChildOutletOrgData
     * @return $this The current object (for fluent API support)
     */
    public function addOutletOrgData(ChildOutletOrgData $l)
    {
        if ($this->collOutletOrgDatas === null) {
            $this->initOutletOrgDatas();
            $this->collOutletOrgDatasPartial = true;
        }

        if (!$this->collOutletOrgDatas->contains($l)) {
            $this->doAddOutletOrgData($l);

            if ($this->outletOrgDatasScheduledForDeletion and $this->outletOrgDatasScheduledForDeletion->contains($l)) {
                $this->outletOrgDatasScheduledForDeletion->remove($this->outletOrgDatasScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletOrgData $outletOrgData The ChildOutletOrgData object to add.
     */
    protected function doAddOutletOrgData(ChildOutletOrgData $outletOrgData): void
    {
        $this->collOutletOrgDatas[]= $outletOrgData;
        $outletOrgData->setCompany($this);
    }

    /**
     * @param ChildOutletOrgData $outletOrgData The ChildOutletOrgData object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletOrgData(ChildOutletOrgData $outletOrgData)
    {
        if ($this->getOutletOrgDatas()->contains($outletOrgData)) {
            $pos = $this->collOutletOrgDatas->search($outletOrgData);
            $this->collOutletOrgDatas->remove($pos);
            if (null === $this->outletOrgDatasScheduledForDeletion) {
                $this->outletOrgDatasScheduledForDeletion = clone $this->collOutletOrgDatas;
                $this->outletOrgDatasScheduledForDeletion->clear();
            }
            $this->outletOrgDatasScheduledForDeletion[]= $outletOrgData;
            $outletOrgData->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletOrgDatas from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletOrgData[] List of ChildOutletOrgData objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgData}> List of ChildOutletOrgData objects
     */
    public function getOutletOrgDatasJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletOrgDataQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getOutletOrgDatas($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletOrgDatas from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletOrgData[] List of ChildOutletOrgData objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgData}> List of ChildOutletOrgData objects
     */
    public function getOutletOrgDatasJoinOutletAddress(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletOrgDataQuery::create(null, $criteria);
        $query->joinWith('OutletAddress', $joinBehavior);

        return $this->getOutletOrgDatas($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletOrgDatas from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletOrgData[] List of ChildOutletOrgData objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgData}> List of ChildOutletOrgData objects
     */
    public function getOutletOrgDatasJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletOrgDataQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getOutletOrgDatas($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletOrgDatas from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletOrgData[] List of ChildOutletOrgData objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgData}> List of ChildOutletOrgData objects
     */
    public function getOutletOrgDatasJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletOrgDataQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getOutletOrgDatas($query, $con);
    }

    /**
     * Clears out the collOutletOrgNotess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletOrgNotess()
     */
    public function clearOutletOrgNotess()
    {
        $this->collOutletOrgNotess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletOrgNotess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletOrgNotess($v = true): void
    {
        $this->collOutletOrgNotessPartial = $v;
    }

    /**
     * Initializes the collOutletOrgNotess collection.
     *
     * By default this just sets the collOutletOrgNotess collection to an empty array (like clearcollOutletOrgNotess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletOrgNotess(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletOrgNotess && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletOrgNotesTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletOrgNotess = new $collectionClassName;
        $this->collOutletOrgNotess->setModel('\entities\OutletOrgNotes');
    }

    /**
     * Gets an array of ChildOutletOrgNotes objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletOrgNotes[] List of ChildOutletOrgNotes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgNotes> List of ChildOutletOrgNotes objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletOrgNotess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletOrgNotessPartial && !$this->isNew();
        if (null === $this->collOutletOrgNotess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletOrgNotess) {
                    $this->initOutletOrgNotess();
                } else {
                    $collectionClassName = OutletOrgNotesTableMap::getTableMap()->getCollectionClassName();

                    $collOutletOrgNotess = new $collectionClassName;
                    $collOutletOrgNotess->setModel('\entities\OutletOrgNotes');

                    return $collOutletOrgNotess;
                }
            } else {
                $collOutletOrgNotess = ChildOutletOrgNotesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletOrgNotessPartial && count($collOutletOrgNotess)) {
                        $this->initOutletOrgNotess(false);

                        foreach ($collOutletOrgNotess as $obj) {
                            if (false == $this->collOutletOrgNotess->contains($obj)) {
                                $this->collOutletOrgNotess->append($obj);
                            }
                        }

                        $this->collOutletOrgNotessPartial = true;
                    }

                    return $collOutletOrgNotess;
                }

                if ($partial && $this->collOutletOrgNotess) {
                    foreach ($this->collOutletOrgNotess as $obj) {
                        if ($obj->isNew()) {
                            $collOutletOrgNotess[] = $obj;
                        }
                    }
                }

                $this->collOutletOrgNotess = $collOutletOrgNotess;
                $this->collOutletOrgNotessPartial = false;
            }
        }

        return $this->collOutletOrgNotess;
    }

    /**
     * Sets a collection of ChildOutletOrgNotes objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletOrgNotess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletOrgNotess(Collection $outletOrgNotess, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletOrgNotes[] $outletOrgNotessToDelete */
        $outletOrgNotessToDelete = $this->getOutletOrgNotess(new Criteria(), $con)->diff($outletOrgNotess);


        $this->outletOrgNotessScheduledForDeletion = $outletOrgNotessToDelete;

        foreach ($outletOrgNotessToDelete as $outletOrgNotesRemoved) {
            $outletOrgNotesRemoved->setCompany(null);
        }

        $this->collOutletOrgNotess = null;
        foreach ($outletOrgNotess as $outletOrgNotes) {
            $this->addOutletOrgNotes($outletOrgNotes);
        }

        $this->collOutletOrgNotess = $outletOrgNotess;
        $this->collOutletOrgNotessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletOrgNotes objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletOrgNotes objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletOrgNotess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletOrgNotessPartial && !$this->isNew();
        if (null === $this->collOutletOrgNotess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletOrgNotess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletOrgNotess());
            }

            $query = ChildOutletOrgNotesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletOrgNotess);
    }

    /**
     * Method called to associate a ChildOutletOrgNotes object to this object
     * through the ChildOutletOrgNotes foreign key attribute.
     *
     * @param ChildOutletOrgNotes $l ChildOutletOrgNotes
     * @return $this The current object (for fluent API support)
     */
    public function addOutletOrgNotes(ChildOutletOrgNotes $l)
    {
        if ($this->collOutletOrgNotess === null) {
            $this->initOutletOrgNotess();
            $this->collOutletOrgNotessPartial = true;
        }

        if (!$this->collOutletOrgNotess->contains($l)) {
            $this->doAddOutletOrgNotes($l);

            if ($this->outletOrgNotessScheduledForDeletion and $this->outletOrgNotessScheduledForDeletion->contains($l)) {
                $this->outletOrgNotessScheduledForDeletion->remove($this->outletOrgNotessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletOrgNotes $outletOrgNotes The ChildOutletOrgNotes object to add.
     */
    protected function doAddOutletOrgNotes(ChildOutletOrgNotes $outletOrgNotes): void
    {
        $this->collOutletOrgNotess[]= $outletOrgNotes;
        $outletOrgNotes->setCompany($this);
    }

    /**
     * @param ChildOutletOrgNotes $outletOrgNotes The ChildOutletOrgNotes object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletOrgNotes(ChildOutletOrgNotes $outletOrgNotes)
    {
        if ($this->getOutletOrgNotess()->contains($outletOrgNotes)) {
            $pos = $this->collOutletOrgNotess->search($outletOrgNotes);
            $this->collOutletOrgNotess->remove($pos);
            if (null === $this->outletOrgNotessScheduledForDeletion) {
                $this->outletOrgNotessScheduledForDeletion = clone $this->collOutletOrgNotess;
                $this->outletOrgNotessScheduledForDeletion->clear();
            }
            $this->outletOrgNotessScheduledForDeletion[]= clone $outletOrgNotes;
            $outletOrgNotes->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletOrgNotess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletOrgNotes[] List of ChildOutletOrgNotes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgNotes}> List of ChildOutletOrgNotes objects
     */
    public function getOutletOrgNotessJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletOrgNotesQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getOutletOrgNotess($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletOrgNotess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletOrgNotes[] List of ChildOutletOrgNotes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgNotes}> List of ChildOutletOrgNotes objects
     */
    public function getOutletOrgNotessJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletOrgNotesQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getOutletOrgNotess($query, $con);
    }

    /**
     * Clears out the collOutletOutcomess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletOutcomess()
     */
    public function clearOutletOutcomess()
    {
        $this->collOutletOutcomess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletOutcomess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletOutcomess($v = true): void
    {
        $this->collOutletOutcomessPartial = $v;
    }

    /**
     * Initializes the collOutletOutcomess collection.
     *
     * By default this just sets the collOutletOutcomess collection to an empty array (like clearcollOutletOutcomess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletOutcomess(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletOutcomess && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletOutcomesTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletOutcomess = new $collectionClassName;
        $this->collOutletOutcomess->setModel('\entities\OutletOutcomes');
    }

    /**
     * Gets an array of ChildOutletOutcomes objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletOutcomes[] List of ChildOutletOutcomes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOutcomes> List of ChildOutletOutcomes objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletOutcomess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletOutcomessPartial && !$this->isNew();
        if (null === $this->collOutletOutcomess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletOutcomess) {
                    $this->initOutletOutcomess();
                } else {
                    $collectionClassName = OutletOutcomesTableMap::getTableMap()->getCollectionClassName();

                    $collOutletOutcomess = new $collectionClassName;
                    $collOutletOutcomess->setModel('\entities\OutletOutcomes');

                    return $collOutletOutcomess;
                }
            } else {
                $collOutletOutcomess = ChildOutletOutcomesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletOutcomessPartial && count($collOutletOutcomess)) {
                        $this->initOutletOutcomess(false);

                        foreach ($collOutletOutcomess as $obj) {
                            if (false == $this->collOutletOutcomess->contains($obj)) {
                                $this->collOutletOutcomess->append($obj);
                            }
                        }

                        $this->collOutletOutcomessPartial = true;
                    }

                    return $collOutletOutcomess;
                }

                if ($partial && $this->collOutletOutcomess) {
                    foreach ($this->collOutletOutcomess as $obj) {
                        if ($obj->isNew()) {
                            $collOutletOutcomess[] = $obj;
                        }
                    }
                }

                $this->collOutletOutcomess = $collOutletOutcomess;
                $this->collOutletOutcomessPartial = false;
            }
        }

        return $this->collOutletOutcomess;
    }

    /**
     * Sets a collection of ChildOutletOutcomes objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletOutcomess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletOutcomess(Collection $outletOutcomess, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletOutcomes[] $outletOutcomessToDelete */
        $outletOutcomessToDelete = $this->getOutletOutcomess(new Criteria(), $con)->diff($outletOutcomess);


        $this->outletOutcomessScheduledForDeletion = $outletOutcomessToDelete;

        foreach ($outletOutcomessToDelete as $outletOutcomesRemoved) {
            $outletOutcomesRemoved->setCompany(null);
        }

        $this->collOutletOutcomess = null;
        foreach ($outletOutcomess as $outletOutcomes) {
            $this->addOutletOutcomes($outletOutcomes);
        }

        $this->collOutletOutcomess = $outletOutcomess;
        $this->collOutletOutcomessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletOutcomes objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletOutcomes objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletOutcomess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletOutcomessPartial && !$this->isNew();
        if (null === $this->collOutletOutcomess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletOutcomess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletOutcomess());
            }

            $query = ChildOutletOutcomesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletOutcomess);
    }

    /**
     * Method called to associate a ChildOutletOutcomes object to this object
     * through the ChildOutletOutcomes foreign key attribute.
     *
     * @param ChildOutletOutcomes $l ChildOutletOutcomes
     * @return $this The current object (for fluent API support)
     */
    public function addOutletOutcomes(ChildOutletOutcomes $l)
    {
        if ($this->collOutletOutcomess === null) {
            $this->initOutletOutcomess();
            $this->collOutletOutcomessPartial = true;
        }

        if (!$this->collOutletOutcomess->contains($l)) {
            $this->doAddOutletOutcomes($l);

            if ($this->outletOutcomessScheduledForDeletion and $this->outletOutcomessScheduledForDeletion->contains($l)) {
                $this->outletOutcomessScheduledForDeletion->remove($this->outletOutcomessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletOutcomes $outletOutcomes The ChildOutletOutcomes object to add.
     */
    protected function doAddOutletOutcomes(ChildOutletOutcomes $outletOutcomes): void
    {
        $this->collOutletOutcomess[]= $outletOutcomes;
        $outletOutcomes->setCompany($this);
    }

    /**
     * @param ChildOutletOutcomes $outletOutcomes The ChildOutletOutcomes object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletOutcomes(ChildOutletOutcomes $outletOutcomes)
    {
        if ($this->getOutletOutcomess()->contains($outletOutcomes)) {
            $pos = $this->collOutletOutcomess->search($outletOutcomes);
            $this->collOutletOutcomess->remove($pos);
            if (null === $this->outletOutcomessScheduledForDeletion) {
                $this->outletOutcomessScheduledForDeletion = clone $this->collOutletOutcomess;
                $this->outletOutcomessScheduledForDeletion->clear();
            }
            $this->outletOutcomessScheduledForDeletion[]= $outletOutcomes;
            $outletOutcomes->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletOutcomess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletOutcomes[] List of ChildOutletOutcomes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOutcomes}> List of ChildOutletOutcomes objects
     */
    public function getOutletOutcomessJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletOutcomesQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getOutletOutcomess($query, $con);
    }

    /**
     * Clears out the collOutletStocks collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletStocks()
     */
    public function clearOutletStocks()
    {
        $this->collOutletStocks = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletStocks collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletStocks($v = true): void
    {
        $this->collOutletStocksPartial = $v;
    }

    /**
     * Initializes the collOutletStocks collection.
     *
     * By default this just sets the collOutletStocks collection to an empty array (like clearcollOutletStocks());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletStocks(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletStocks && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletStockTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletStocks = new $collectionClassName;
        $this->collOutletStocks->setModel('\entities\OutletStock');
    }

    /**
     * Gets an array of ChildOutletStock objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletStock[] List of ChildOutletStock objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStock> List of ChildOutletStock objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletStocks(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletStocksPartial && !$this->isNew();
        if (null === $this->collOutletStocks || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletStocks) {
                    $this->initOutletStocks();
                } else {
                    $collectionClassName = OutletStockTableMap::getTableMap()->getCollectionClassName();

                    $collOutletStocks = new $collectionClassName;
                    $collOutletStocks->setModel('\entities\OutletStock');

                    return $collOutletStocks;
                }
            } else {
                $collOutletStocks = ChildOutletStockQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletStocksPartial && count($collOutletStocks)) {
                        $this->initOutletStocks(false);

                        foreach ($collOutletStocks as $obj) {
                            if (false == $this->collOutletStocks->contains($obj)) {
                                $this->collOutletStocks->append($obj);
                            }
                        }

                        $this->collOutletStocksPartial = true;
                    }

                    return $collOutletStocks;
                }

                if ($partial && $this->collOutletStocks) {
                    foreach ($this->collOutletStocks as $obj) {
                        if ($obj->isNew()) {
                            $collOutletStocks[] = $obj;
                        }
                    }
                }

                $this->collOutletStocks = $collOutletStocks;
                $this->collOutletStocksPartial = false;
            }
        }

        return $this->collOutletStocks;
    }

    /**
     * Sets a collection of ChildOutletStock objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletStocks A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletStocks(Collection $outletStocks, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletStock[] $outletStocksToDelete */
        $outletStocksToDelete = $this->getOutletStocks(new Criteria(), $con)->diff($outletStocks);


        $this->outletStocksScheduledForDeletion = $outletStocksToDelete;

        foreach ($outletStocksToDelete as $outletStockRemoved) {
            $outletStockRemoved->setCompany(null);
        }

        $this->collOutletStocks = null;
        foreach ($outletStocks as $outletStock) {
            $this->addOutletStock($outletStock);
        }

        $this->collOutletStocks = $outletStocks;
        $this->collOutletStocksPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletStock objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletStock objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletStocks(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletStocksPartial && !$this->isNew();
        if (null === $this->collOutletStocks || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletStocks) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletStocks());
            }

            $query = ChildOutletStockQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletStocks);
    }

    /**
     * Method called to associate a ChildOutletStock object to this object
     * through the ChildOutletStock foreign key attribute.
     *
     * @param ChildOutletStock $l ChildOutletStock
     * @return $this The current object (for fluent API support)
     */
    public function addOutletStock(ChildOutletStock $l)
    {
        if ($this->collOutletStocks === null) {
            $this->initOutletStocks();
            $this->collOutletStocksPartial = true;
        }

        if (!$this->collOutletStocks->contains($l)) {
            $this->doAddOutletStock($l);

            if ($this->outletStocksScheduledForDeletion and $this->outletStocksScheduledForDeletion->contains($l)) {
                $this->outletStocksScheduledForDeletion->remove($this->outletStocksScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletStock $outletStock The ChildOutletStock object to add.
     */
    protected function doAddOutletStock(ChildOutletStock $outletStock): void
    {
        $this->collOutletStocks[]= $outletStock;
        $outletStock->setCompany($this);
    }

    /**
     * @param ChildOutletStock $outletStock The ChildOutletStock object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletStock(ChildOutletStock $outletStock)
    {
        if ($this->getOutletStocks()->contains($outletStock)) {
            $pos = $this->collOutletStocks->search($outletStock);
            $this->collOutletStocks->remove($pos);
            if (null === $this->outletStocksScheduledForDeletion) {
                $this->outletStocksScheduledForDeletion = clone $this->collOutletStocks;
                $this->outletStocksScheduledForDeletion->clear();
            }
            $this->outletStocksScheduledForDeletion[]= clone $outletStock;
            $outletStock->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStock[] List of ChildOutletStock objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStock}> List of ChildOutletStock objects
     */
    public function getOutletStocksJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getOutletStocks($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStock[] List of ChildOutletStock objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStock}> List of ChildOutletStock objects
     */
    public function getOutletStocksJoinProducts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockQuery::create(null, $criteria);
        $query->joinWith('Products', $joinBehavior);

        return $this->getOutletStocks($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStock[] List of ChildOutletStock objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStock}> List of ChildOutletStock objects
     */
    public function getOutletStocksJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getOutletStocks($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStock[] List of ChildOutletStock objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStock}> List of ChildOutletStock objects
     */
    public function getOutletStocksJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getOutletStocks($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStock[] List of ChildOutletStock objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStock}> List of ChildOutletStock objects
     */
    public function getOutletStocksJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getOutletStocks($query, $con);
    }

    /**
     * Clears out the collOutletStockOtherSummaries collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletStockOtherSummaries()
     */
    public function clearOutletStockOtherSummaries()
    {
        $this->collOutletStockOtherSummaries = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletStockOtherSummaries collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletStockOtherSummaries($v = true): void
    {
        $this->collOutletStockOtherSummariesPartial = $v;
    }

    /**
     * Initializes the collOutletStockOtherSummaries collection.
     *
     * By default this just sets the collOutletStockOtherSummaries collection to an empty array (like clearcollOutletStockOtherSummaries());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletStockOtherSummaries(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletStockOtherSummaries && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletStockOtherSummaryTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletStockOtherSummaries = new $collectionClassName;
        $this->collOutletStockOtherSummaries->setModel('\entities\OutletStockOtherSummary');
    }

    /**
     * Gets an array of ChildOutletStockOtherSummary objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletStockOtherSummary[] List of ChildOutletStockOtherSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockOtherSummary> List of ChildOutletStockOtherSummary objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletStockOtherSummaries(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletStockOtherSummariesPartial && !$this->isNew();
        if (null === $this->collOutletStockOtherSummaries || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletStockOtherSummaries) {
                    $this->initOutletStockOtherSummaries();
                } else {
                    $collectionClassName = OutletStockOtherSummaryTableMap::getTableMap()->getCollectionClassName();

                    $collOutletStockOtherSummaries = new $collectionClassName;
                    $collOutletStockOtherSummaries->setModel('\entities\OutletStockOtherSummary');

                    return $collOutletStockOtherSummaries;
                }
            } else {
                $collOutletStockOtherSummaries = ChildOutletStockOtherSummaryQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletStockOtherSummariesPartial && count($collOutletStockOtherSummaries)) {
                        $this->initOutletStockOtherSummaries(false);

                        foreach ($collOutletStockOtherSummaries as $obj) {
                            if (false == $this->collOutletStockOtherSummaries->contains($obj)) {
                                $this->collOutletStockOtherSummaries->append($obj);
                            }
                        }

                        $this->collOutletStockOtherSummariesPartial = true;
                    }

                    return $collOutletStockOtherSummaries;
                }

                if ($partial && $this->collOutletStockOtherSummaries) {
                    foreach ($this->collOutletStockOtherSummaries as $obj) {
                        if ($obj->isNew()) {
                            $collOutletStockOtherSummaries[] = $obj;
                        }
                    }
                }

                $this->collOutletStockOtherSummaries = $collOutletStockOtherSummaries;
                $this->collOutletStockOtherSummariesPartial = false;
            }
        }

        return $this->collOutletStockOtherSummaries;
    }

    /**
     * Sets a collection of ChildOutletStockOtherSummary objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletStockOtherSummaries A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletStockOtherSummaries(Collection $outletStockOtherSummaries, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletStockOtherSummary[] $outletStockOtherSummariesToDelete */
        $outletStockOtherSummariesToDelete = $this->getOutletStockOtherSummaries(new Criteria(), $con)->diff($outletStockOtherSummaries);


        $this->outletStockOtherSummariesScheduledForDeletion = $outletStockOtherSummariesToDelete;

        foreach ($outletStockOtherSummariesToDelete as $outletStockOtherSummaryRemoved) {
            $outletStockOtherSummaryRemoved->setCompany(null);
        }

        $this->collOutletStockOtherSummaries = null;
        foreach ($outletStockOtherSummaries as $outletStockOtherSummary) {
            $this->addOutletStockOtherSummary($outletStockOtherSummary);
        }

        $this->collOutletStockOtherSummaries = $outletStockOtherSummaries;
        $this->collOutletStockOtherSummariesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletStockOtherSummary objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletStockOtherSummary objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletStockOtherSummaries(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletStockOtherSummariesPartial && !$this->isNew();
        if (null === $this->collOutletStockOtherSummaries || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletStockOtherSummaries) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletStockOtherSummaries());
            }

            $query = ChildOutletStockOtherSummaryQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletStockOtherSummaries);
    }

    /**
     * Method called to associate a ChildOutletStockOtherSummary object to this object
     * through the ChildOutletStockOtherSummary foreign key attribute.
     *
     * @param ChildOutletStockOtherSummary $l ChildOutletStockOtherSummary
     * @return $this The current object (for fluent API support)
     */
    public function addOutletStockOtherSummary(ChildOutletStockOtherSummary $l)
    {
        if ($this->collOutletStockOtherSummaries === null) {
            $this->initOutletStockOtherSummaries();
            $this->collOutletStockOtherSummariesPartial = true;
        }

        if (!$this->collOutletStockOtherSummaries->contains($l)) {
            $this->doAddOutletStockOtherSummary($l);

            if ($this->outletStockOtherSummariesScheduledForDeletion and $this->outletStockOtherSummariesScheduledForDeletion->contains($l)) {
                $this->outletStockOtherSummariesScheduledForDeletion->remove($this->outletStockOtherSummariesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletStockOtherSummary $outletStockOtherSummary The ChildOutletStockOtherSummary object to add.
     */
    protected function doAddOutletStockOtherSummary(ChildOutletStockOtherSummary $outletStockOtherSummary): void
    {
        $this->collOutletStockOtherSummaries[]= $outletStockOtherSummary;
        $outletStockOtherSummary->setCompany($this);
    }

    /**
     * @param ChildOutletStockOtherSummary $outletStockOtherSummary The ChildOutletStockOtherSummary object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletStockOtherSummary(ChildOutletStockOtherSummary $outletStockOtherSummary)
    {
        if ($this->getOutletStockOtherSummaries()->contains($outletStockOtherSummary)) {
            $pos = $this->collOutletStockOtherSummaries->search($outletStockOtherSummary);
            $this->collOutletStockOtherSummaries->remove($pos);
            if (null === $this->outletStockOtherSummariesScheduledForDeletion) {
                $this->outletStockOtherSummariesScheduledForDeletion = clone $this->collOutletStockOtherSummaries;
                $this->outletStockOtherSummariesScheduledForDeletion->clear();
            }
            $this->outletStockOtherSummariesScheduledForDeletion[]= clone $outletStockOtherSummary;
            $outletStockOtherSummary->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockOtherSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockOtherSummary[] List of ChildOutletStockOtherSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockOtherSummary}> List of ChildOutletStockOtherSummary objects
     */
    public function getOutletStockOtherSummariesJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockOtherSummaryQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getOutletStockOtherSummaries($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockOtherSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockOtherSummary[] List of ChildOutletStockOtherSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockOtherSummary}> List of ChildOutletStockOtherSummary objects
     */
    public function getOutletStockOtherSummariesJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockOtherSummaryQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getOutletStockOtherSummaries($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockOtherSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockOtherSummary[] List of ChildOutletStockOtherSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockOtherSummary}> List of ChildOutletStockOtherSummary objects
     */
    public function getOutletStockOtherSummariesJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockOtherSummaryQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getOutletStockOtherSummaries($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockOtherSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockOtherSummary[] List of ChildOutletStockOtherSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockOtherSummary}> List of ChildOutletStockOtherSummary objects
     */
    public function getOutletStockOtherSummariesJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockOtherSummaryQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getOutletStockOtherSummaries($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockOtherSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockOtherSummary[] List of ChildOutletStockOtherSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockOtherSummary}> List of ChildOutletStockOtherSummary objects
     */
    public function getOutletStockOtherSummariesJoinProducts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockOtherSummaryQuery::create(null, $criteria);
        $query->joinWith('Products', $joinBehavior);

        return $this->getOutletStockOtherSummaries($query, $con);
    }

    /**
     * Clears out the collOutletStockSummaries collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletStockSummaries()
     */
    public function clearOutletStockSummaries()
    {
        $this->collOutletStockSummaries = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletStockSummaries collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletStockSummaries($v = true): void
    {
        $this->collOutletStockSummariesPartial = $v;
    }

    /**
     * Initializes the collOutletStockSummaries collection.
     *
     * By default this just sets the collOutletStockSummaries collection to an empty array (like clearcollOutletStockSummaries());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletStockSummaries(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletStockSummaries && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletStockSummaryTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletStockSummaries = new $collectionClassName;
        $this->collOutletStockSummaries->setModel('\entities\OutletStockSummary');
    }

    /**
     * Gets an array of ChildOutletStockSummary objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletStockSummary[] List of ChildOutletStockSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockSummary> List of ChildOutletStockSummary objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletStockSummaries(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletStockSummariesPartial && !$this->isNew();
        if (null === $this->collOutletStockSummaries || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletStockSummaries) {
                    $this->initOutletStockSummaries();
                } else {
                    $collectionClassName = OutletStockSummaryTableMap::getTableMap()->getCollectionClassName();

                    $collOutletStockSummaries = new $collectionClassName;
                    $collOutletStockSummaries->setModel('\entities\OutletStockSummary');

                    return $collOutletStockSummaries;
                }
            } else {
                $collOutletStockSummaries = ChildOutletStockSummaryQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletStockSummariesPartial && count($collOutletStockSummaries)) {
                        $this->initOutletStockSummaries(false);

                        foreach ($collOutletStockSummaries as $obj) {
                            if (false == $this->collOutletStockSummaries->contains($obj)) {
                                $this->collOutletStockSummaries->append($obj);
                            }
                        }

                        $this->collOutletStockSummariesPartial = true;
                    }

                    return $collOutletStockSummaries;
                }

                if ($partial && $this->collOutletStockSummaries) {
                    foreach ($this->collOutletStockSummaries as $obj) {
                        if ($obj->isNew()) {
                            $collOutletStockSummaries[] = $obj;
                        }
                    }
                }

                $this->collOutletStockSummaries = $collOutletStockSummaries;
                $this->collOutletStockSummariesPartial = false;
            }
        }

        return $this->collOutletStockSummaries;
    }

    /**
     * Sets a collection of ChildOutletStockSummary objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletStockSummaries A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletStockSummaries(Collection $outletStockSummaries, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletStockSummary[] $outletStockSummariesToDelete */
        $outletStockSummariesToDelete = $this->getOutletStockSummaries(new Criteria(), $con)->diff($outletStockSummaries);


        $this->outletStockSummariesScheduledForDeletion = $outletStockSummariesToDelete;

        foreach ($outletStockSummariesToDelete as $outletStockSummaryRemoved) {
            $outletStockSummaryRemoved->setCompany(null);
        }

        $this->collOutletStockSummaries = null;
        foreach ($outletStockSummaries as $outletStockSummary) {
            $this->addOutletStockSummary($outletStockSummary);
        }

        $this->collOutletStockSummaries = $outletStockSummaries;
        $this->collOutletStockSummariesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletStockSummary objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletStockSummary objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletStockSummaries(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletStockSummariesPartial && !$this->isNew();
        if (null === $this->collOutletStockSummaries || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletStockSummaries) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletStockSummaries());
            }

            $query = ChildOutletStockSummaryQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletStockSummaries);
    }

    /**
     * Method called to associate a ChildOutletStockSummary object to this object
     * through the ChildOutletStockSummary foreign key attribute.
     *
     * @param ChildOutletStockSummary $l ChildOutletStockSummary
     * @return $this The current object (for fluent API support)
     */
    public function addOutletStockSummary(ChildOutletStockSummary $l)
    {
        if ($this->collOutletStockSummaries === null) {
            $this->initOutletStockSummaries();
            $this->collOutletStockSummariesPartial = true;
        }

        if (!$this->collOutletStockSummaries->contains($l)) {
            $this->doAddOutletStockSummary($l);

            if ($this->outletStockSummariesScheduledForDeletion and $this->outletStockSummariesScheduledForDeletion->contains($l)) {
                $this->outletStockSummariesScheduledForDeletion->remove($this->outletStockSummariesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletStockSummary $outletStockSummary The ChildOutletStockSummary object to add.
     */
    protected function doAddOutletStockSummary(ChildOutletStockSummary $outletStockSummary): void
    {
        $this->collOutletStockSummaries[]= $outletStockSummary;
        $outletStockSummary->setCompany($this);
    }

    /**
     * @param ChildOutletStockSummary $outletStockSummary The ChildOutletStockSummary object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletStockSummary(ChildOutletStockSummary $outletStockSummary)
    {
        if ($this->getOutletStockSummaries()->contains($outletStockSummary)) {
            $pos = $this->collOutletStockSummaries->search($outletStockSummary);
            $this->collOutletStockSummaries->remove($pos);
            if (null === $this->outletStockSummariesScheduledForDeletion) {
                $this->outletStockSummariesScheduledForDeletion = clone $this->collOutletStockSummaries;
                $this->outletStockSummariesScheduledForDeletion->clear();
            }
            $this->outletStockSummariesScheduledForDeletion[]= clone $outletStockSummary;
            $outletStockSummary->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockSummary[] List of ChildOutletStockSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockSummary}> List of ChildOutletStockSummary objects
     */
    public function getOutletStockSummariesJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockSummaryQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getOutletStockSummaries($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockSummary[] List of ChildOutletStockSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockSummary}> List of ChildOutletStockSummary objects
     */
    public function getOutletStockSummariesJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockSummaryQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getOutletStockSummaries($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockSummary[] List of ChildOutletStockSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockSummary}> List of ChildOutletStockSummary objects
     */
    public function getOutletStockSummariesJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockSummaryQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getOutletStockSummaries($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockSummary[] List of ChildOutletStockSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockSummary}> List of ChildOutletStockSummary objects
     */
    public function getOutletStockSummariesJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockSummaryQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getOutletStockSummaries($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletStockSummaries from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletStockSummary[] List of ChildOutletStockSummary objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletStockSummary}> List of ChildOutletStockSummary objects
     */
    public function getOutletStockSummariesJoinProducts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletStockSummaryQuery::create(null, $criteria);
        $query->joinWith('Products', $joinBehavior);

        return $this->getOutletStockSummaries($query, $con);
    }

    /**
     * Clears out the collOutletTagss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletTagss()
     */
    public function clearOutletTagss()
    {
        $this->collOutletTagss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletTagss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletTagss($v = true): void
    {
        $this->collOutletTagssPartial = $v;
    }

    /**
     * Initializes the collOutletTagss collection.
     *
     * By default this just sets the collOutletTagss collection to an empty array (like clearcollOutletTagss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletTagss(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletTagss && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletTagsTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletTagss = new $collectionClassName;
        $this->collOutletTagss->setModel('\entities\OutletTags');
    }

    /**
     * Gets an array of ChildOutletTags objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletTags[] List of ChildOutletTags objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletTags> List of ChildOutletTags objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletTagss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletTagssPartial && !$this->isNew();
        if (null === $this->collOutletTagss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletTagss) {
                    $this->initOutletTagss();
                } else {
                    $collectionClassName = OutletTagsTableMap::getTableMap()->getCollectionClassName();

                    $collOutletTagss = new $collectionClassName;
                    $collOutletTagss->setModel('\entities\OutletTags');

                    return $collOutletTagss;
                }
            } else {
                $collOutletTagss = ChildOutletTagsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletTagssPartial && count($collOutletTagss)) {
                        $this->initOutletTagss(false);

                        foreach ($collOutletTagss as $obj) {
                            if (false == $this->collOutletTagss->contains($obj)) {
                                $this->collOutletTagss->append($obj);
                            }
                        }

                        $this->collOutletTagssPartial = true;
                    }

                    return $collOutletTagss;
                }

                if ($partial && $this->collOutletTagss) {
                    foreach ($this->collOutletTagss as $obj) {
                        if ($obj->isNew()) {
                            $collOutletTagss[] = $obj;
                        }
                    }
                }

                $this->collOutletTagss = $collOutletTagss;
                $this->collOutletTagssPartial = false;
            }
        }

        return $this->collOutletTagss;
    }

    /**
     * Sets a collection of ChildOutletTags objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletTagss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletTagss(Collection $outletTagss, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletTags[] $outletTagssToDelete */
        $outletTagssToDelete = $this->getOutletTagss(new Criteria(), $con)->diff($outletTagss);


        $this->outletTagssScheduledForDeletion = $outletTagssToDelete;

        foreach ($outletTagssToDelete as $outletTagsRemoved) {
            $outletTagsRemoved->setCompany(null);
        }

        $this->collOutletTagss = null;
        foreach ($outletTagss as $outletTags) {
            $this->addOutletTags($outletTags);
        }

        $this->collOutletTagss = $outletTagss;
        $this->collOutletTagssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletTags objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletTags objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletTagss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletTagssPartial && !$this->isNew();
        if (null === $this->collOutletTagss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletTagss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletTagss());
            }

            $query = ChildOutletTagsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletTagss);
    }

    /**
     * Method called to associate a ChildOutletTags object to this object
     * through the ChildOutletTags foreign key attribute.
     *
     * @param ChildOutletTags $l ChildOutletTags
     * @return $this The current object (for fluent API support)
     */
    public function addOutletTags(ChildOutletTags $l)
    {
        if ($this->collOutletTagss === null) {
            $this->initOutletTagss();
            $this->collOutletTagssPartial = true;
        }

        if (!$this->collOutletTagss->contains($l)) {
            $this->doAddOutletTags($l);

            if ($this->outletTagssScheduledForDeletion and $this->outletTagssScheduledForDeletion->contains($l)) {
                $this->outletTagssScheduledForDeletion->remove($this->outletTagssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletTags $outletTags The ChildOutletTags object to add.
     */
    protected function doAddOutletTags(ChildOutletTags $outletTags): void
    {
        $this->collOutletTagss[]= $outletTags;
        $outletTags->setCompany($this);
    }

    /**
     * @param ChildOutletTags $outletTags The ChildOutletTags object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletTags(ChildOutletTags $outletTags)
    {
        if ($this->getOutletTagss()->contains($outletTags)) {
            $pos = $this->collOutletTagss->search($outletTags);
            $this->collOutletTagss->remove($pos);
            if (null === $this->outletTagssScheduledForDeletion) {
                $this->outletTagssScheduledForDeletion = clone $this->collOutletTagss;
                $this->outletTagssScheduledForDeletion->clear();
            }
            $this->outletTagssScheduledForDeletion[]= $outletTags;
            $outletTags->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collOutletTypes collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletTypes()
     */
    public function clearOutletTypes()
    {
        $this->collOutletTypes = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletTypes collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletTypes($v = true): void
    {
        $this->collOutletTypesPartial = $v;
    }

    /**
     * Initializes the collOutletTypes collection.
     *
     * By default this just sets the collOutletTypes collection to an empty array (like clearcollOutletTypes());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletTypes(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletTypes && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletTypeTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletTypes = new $collectionClassName;
        $this->collOutletTypes->setModel('\entities\OutletType');
    }

    /**
     * Gets an array of ChildOutletType objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletType[] List of ChildOutletType objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletType> List of ChildOutletType objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletTypes(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletTypesPartial && !$this->isNew();
        if (null === $this->collOutletTypes || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletTypes) {
                    $this->initOutletTypes();
                } else {
                    $collectionClassName = OutletTypeTableMap::getTableMap()->getCollectionClassName();

                    $collOutletTypes = new $collectionClassName;
                    $collOutletTypes->setModel('\entities\OutletType');

                    return $collOutletTypes;
                }
            } else {
                $collOutletTypes = ChildOutletTypeQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletTypesPartial && count($collOutletTypes)) {
                        $this->initOutletTypes(false);

                        foreach ($collOutletTypes as $obj) {
                            if (false == $this->collOutletTypes->contains($obj)) {
                                $this->collOutletTypes->append($obj);
                            }
                        }

                        $this->collOutletTypesPartial = true;
                    }

                    return $collOutletTypes;
                }

                if ($partial && $this->collOutletTypes) {
                    foreach ($this->collOutletTypes as $obj) {
                        if ($obj->isNew()) {
                            $collOutletTypes[] = $obj;
                        }
                    }
                }

                $this->collOutletTypes = $collOutletTypes;
                $this->collOutletTypesPartial = false;
            }
        }

        return $this->collOutletTypes;
    }

    /**
     * Sets a collection of ChildOutletType objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletTypes A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletTypes(Collection $outletTypes, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletType[] $outletTypesToDelete */
        $outletTypesToDelete = $this->getOutletTypes(new Criteria(), $con)->diff($outletTypes);


        $this->outletTypesScheduledForDeletion = $outletTypesToDelete;

        foreach ($outletTypesToDelete as $outletTypeRemoved) {
            $outletTypeRemoved->setCompany(null);
        }

        $this->collOutletTypes = null;
        foreach ($outletTypes as $outletType) {
            $this->addOutletType($outletType);
        }

        $this->collOutletTypes = $outletTypes;
        $this->collOutletTypesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletType objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletType objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletTypes(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletTypesPartial && !$this->isNew();
        if (null === $this->collOutletTypes || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletTypes) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletTypes());
            }

            $query = ChildOutletTypeQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletTypes);
    }

    /**
     * Method called to associate a ChildOutletType object to this object
     * through the ChildOutletType foreign key attribute.
     *
     * @param ChildOutletType $l ChildOutletType
     * @return $this The current object (for fluent API support)
     */
    public function addOutletType(ChildOutletType $l)
    {
        if ($this->collOutletTypes === null) {
            $this->initOutletTypes();
            $this->collOutletTypesPartial = true;
        }

        if (!$this->collOutletTypes->contains($l)) {
            $this->doAddOutletType($l);

            if ($this->outletTypesScheduledForDeletion and $this->outletTypesScheduledForDeletion->contains($l)) {
                $this->outletTypesScheduledForDeletion->remove($this->outletTypesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletType $outletType The ChildOutletType object to add.
     */
    protected function doAddOutletType(ChildOutletType $outletType): void
    {
        $this->collOutletTypes[]= $outletType;
        $outletType->setCompany($this);
    }

    /**
     * @param ChildOutletType $outletType The ChildOutletType object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletType(ChildOutletType $outletType)
    {
        if ($this->getOutletTypes()->contains($outletType)) {
            $pos = $this->collOutletTypes->search($outletType);
            $this->collOutletTypes->remove($pos);
            if (null === $this->outletTypesScheduledForDeletion) {
                $this->outletTypesScheduledForDeletion = clone $this->collOutletTypes;
                $this->outletTypesScheduledForDeletion->clear();
            }
            $this->outletTypesScheduledForDeletion[]= clone $outletType;
            $outletType->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletTypes from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletType[] List of ChildOutletType objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletType}> List of ChildOutletType objects
     */
    public function getOutletTypesJoinMediaFiles(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletTypeQuery::create(null, $criteria);
        $query->joinWith('MediaFiles', $joinBehavior);

        return $this->getOutletTypes($query, $con);
    }

    /**
     * Clears out the collOutletss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletss()
     */
    public function clearOutletss()
    {
        $this->collOutletss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletss($v = true): void
    {
        $this->collOutletssPartial = $v;
    }

    /**
     * Initializes the collOutletss collection.
     *
     * By default this just sets the collOutletss collection to an empty array (like clearcollOutletss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletss(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletss && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletsTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletss = new $collectionClassName;
        $this->collOutletss->setModel('\entities\Outlets');
    }

    /**
     * Gets an array of ChildOutlets objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutlets[] List of ChildOutlets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutlets> List of ChildOutlets objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletssPartial && !$this->isNew();
        if (null === $this->collOutletss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletss) {
                    $this->initOutletss();
                } else {
                    $collectionClassName = OutletsTableMap::getTableMap()->getCollectionClassName();

                    $collOutletss = new $collectionClassName;
                    $collOutletss->setModel('\entities\Outlets');

                    return $collOutletss;
                }
            } else {
                $collOutletss = ChildOutletsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletssPartial && count($collOutletss)) {
                        $this->initOutletss(false);

                        foreach ($collOutletss as $obj) {
                            if (false == $this->collOutletss->contains($obj)) {
                                $this->collOutletss->append($obj);
                            }
                        }

                        $this->collOutletssPartial = true;
                    }

                    return $collOutletss;
                }

                if ($partial && $this->collOutletss) {
                    foreach ($this->collOutletss as $obj) {
                        if ($obj->isNew()) {
                            $collOutletss[] = $obj;
                        }
                    }
                }

                $this->collOutletss = $collOutletss;
                $this->collOutletssPartial = false;
            }
        }

        return $this->collOutletss;
    }

    /**
     * Sets a collection of ChildOutlets objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletss(Collection $outletss, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutlets[] $outletssToDelete */
        $outletssToDelete = $this->getOutletss(new Criteria(), $con)->diff($outletss);


        $this->outletssScheduledForDeletion = $outletssToDelete;

        foreach ($outletssToDelete as $outletsRemoved) {
            $outletsRemoved->setCompany(null);
        }

        $this->collOutletss = null;
        foreach ($outletss as $outlets) {
            $this->addOutlets($outlets);
        }

        $this->collOutletss = $outletss;
        $this->collOutletssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Outlets objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Outlets objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletssPartial && !$this->isNew();
        if (null === $this->collOutletss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletss());
            }

            $query = ChildOutletsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletss);
    }

    /**
     * Method called to associate a ChildOutlets object to this object
     * through the ChildOutlets foreign key attribute.
     *
     * @param ChildOutlets $l ChildOutlets
     * @return $this The current object (for fluent API support)
     */
    public function addOutlets(ChildOutlets $l)
    {
        if ($this->collOutletss === null) {
            $this->initOutletss();
            $this->collOutletssPartial = true;
        }

        if (!$this->collOutletss->contains($l)) {
            $this->doAddOutlets($l);

            if ($this->outletssScheduledForDeletion and $this->outletssScheduledForDeletion->contains($l)) {
                $this->outletssScheduledForDeletion->remove($this->outletssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutlets $outlets The ChildOutlets object to add.
     */
    protected function doAddOutlets(ChildOutlets $outlets): void
    {
        $this->collOutletss[]= $outlets;
        $outlets->setCompany($this);
    }

    /**
     * @param ChildOutlets $outlets The ChildOutlets object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutlets(ChildOutlets $outlets)
    {
        if ($this->getOutletss()->contains($outlets)) {
            $pos = $this->collOutletss->search($outlets);
            $this->collOutletss->remove($pos);
            if (null === $this->outletssScheduledForDeletion) {
                $this->outletssScheduledForDeletion = clone $this->collOutletss;
                $this->outletssScheduledForDeletion->clear();
            }
            $this->outletssScheduledForDeletion[]= clone $outlets;
            $outlets->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Outletss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutlets[] List of ChildOutlets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutlets}> List of ChildOutlets objects
     */
    public function getOutletssJoinClassification(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletsQuery::create(null, $criteria);
        $query->joinWith('Classification', $joinBehavior);

        return $this->getOutletss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Outletss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutlets[] List of ChildOutlets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutlets}> List of ChildOutlets objects
     */
    public function getOutletssJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletsQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getOutletss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Outletss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutlets[] List of ChildOutlets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutlets}> List of ChildOutlets objects
     */
    public function getOutletssJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletsQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getOutletss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Outletss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutlets[] List of ChildOutlets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutlets}> List of ChildOutlets objects
     */
    public function getOutletssJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletsQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getOutletss($query, $con);
    }

    /**
     * Clears out the collPolicyMasters collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addPolicyMasters()
     */
    public function clearPolicyMasters()
    {
        $this->collPolicyMasters = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collPolicyMasters collection loaded partially.
     *
     * @return void
     */
    public function resetPartialPolicyMasters($v = true): void
    {
        $this->collPolicyMastersPartial = $v;
    }

    /**
     * Initializes the collPolicyMasters collection.
     *
     * By default this just sets the collPolicyMasters collection to an empty array (like clearcollPolicyMasters());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPolicyMasters(bool $overrideExisting = true): void
    {
        if (null !== $this->collPolicyMasters && !$overrideExisting) {
            return;
        }

        $collectionClassName = PolicyMasterTableMap::getTableMap()->getCollectionClassName();

        $this->collPolicyMasters = new $collectionClassName;
        $this->collPolicyMasters->setModel('\entities\PolicyMaster');
    }

    /**
     * Gets an array of ChildPolicyMaster objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildPolicyMaster[] List of ChildPolicyMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPolicyMaster> List of ChildPolicyMaster objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getPolicyMasters(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collPolicyMastersPartial && !$this->isNew();
        if (null === $this->collPolicyMasters || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collPolicyMasters) {
                    $this->initPolicyMasters();
                } else {
                    $collectionClassName = PolicyMasterTableMap::getTableMap()->getCollectionClassName();

                    $collPolicyMasters = new $collectionClassName;
                    $collPolicyMasters->setModel('\entities\PolicyMaster');

                    return $collPolicyMasters;
                }
            } else {
                $collPolicyMasters = ChildPolicyMasterQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collPolicyMastersPartial && count($collPolicyMasters)) {
                        $this->initPolicyMasters(false);

                        foreach ($collPolicyMasters as $obj) {
                            if (false == $this->collPolicyMasters->contains($obj)) {
                                $this->collPolicyMasters->append($obj);
                            }
                        }

                        $this->collPolicyMastersPartial = true;
                    }

                    return $collPolicyMasters;
                }

                if ($partial && $this->collPolicyMasters) {
                    foreach ($this->collPolicyMasters as $obj) {
                        if ($obj->isNew()) {
                            $collPolicyMasters[] = $obj;
                        }
                    }
                }

                $this->collPolicyMasters = $collPolicyMasters;
                $this->collPolicyMastersPartial = false;
            }
        }

        return $this->collPolicyMasters;
    }

    /**
     * Sets a collection of ChildPolicyMaster objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $policyMasters A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setPolicyMasters(Collection $policyMasters, ?ConnectionInterface $con = null)
    {
        /** @var ChildPolicyMaster[] $policyMastersToDelete */
        $policyMastersToDelete = $this->getPolicyMasters(new Criteria(), $con)->diff($policyMasters);


        $this->policyMastersScheduledForDeletion = $policyMastersToDelete;

        foreach ($policyMastersToDelete as $policyMasterRemoved) {
            $policyMasterRemoved->setCompany(null);
        }

        $this->collPolicyMasters = null;
        foreach ($policyMasters as $policyMaster) {
            $this->addPolicyMaster($policyMaster);
        }

        $this->collPolicyMasters = $policyMasters;
        $this->collPolicyMastersPartial = false;

        return $this;
    }

    /**
     * Returns the number of related PolicyMaster objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related PolicyMaster objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countPolicyMasters(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collPolicyMastersPartial && !$this->isNew();
        if (null === $this->collPolicyMasters || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPolicyMasters) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getPolicyMasters());
            }

            $query = ChildPolicyMasterQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collPolicyMasters);
    }

    /**
     * Method called to associate a ChildPolicyMaster object to this object
     * through the ChildPolicyMaster foreign key attribute.
     *
     * @param ChildPolicyMaster $l ChildPolicyMaster
     * @return $this The current object (for fluent API support)
     */
    public function addPolicyMaster(ChildPolicyMaster $l)
    {
        if ($this->collPolicyMasters === null) {
            $this->initPolicyMasters();
            $this->collPolicyMastersPartial = true;
        }

        if (!$this->collPolicyMasters->contains($l)) {
            $this->doAddPolicyMaster($l);

            if ($this->policyMastersScheduledForDeletion and $this->policyMastersScheduledForDeletion->contains($l)) {
                $this->policyMastersScheduledForDeletion->remove($this->policyMastersScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildPolicyMaster $policyMaster The ChildPolicyMaster object to add.
     */
    protected function doAddPolicyMaster(ChildPolicyMaster $policyMaster): void
    {
        $this->collPolicyMasters[]= $policyMaster;
        $policyMaster->setCompany($this);
    }

    /**
     * @param ChildPolicyMaster $policyMaster The ChildPolicyMaster object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removePolicyMaster(ChildPolicyMaster $policyMaster)
    {
        if ($this->getPolicyMasters()->contains($policyMaster)) {
            $pos = $this->collPolicyMasters->search($policyMaster);
            $this->collPolicyMasters->remove($pos);
            if (null === $this->policyMastersScheduledForDeletion) {
                $this->policyMastersScheduledForDeletion = clone $this->collPolicyMasters;
                $this->policyMastersScheduledForDeletion->clear();
            }
            $this->policyMastersScheduledForDeletion[]= clone $policyMaster;
            $policyMaster->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related PolicyMasters from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildPolicyMaster[] List of ChildPolicyMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPolicyMaster}> List of ChildPolicyMaster objects
     */
    public function getPolicyMastersJoinCurrencies(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildPolicyMasterQuery::create(null, $criteria);
        $query->joinWith('Currencies', $joinBehavior);

        return $this->getPolicyMasters($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related PolicyMasters from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildPolicyMaster[] List of ChildPolicyMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPolicyMaster}> List of ChildPolicyMaster objects
     */
    public function getPolicyMastersJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildPolicyMasterQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getPolicyMasters($query, $con);
    }

    /**
     * Clears out the collPolicykeyss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addPolicykeyss()
     */
    public function clearPolicykeyss()
    {
        $this->collPolicykeyss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collPolicykeyss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialPolicykeyss($v = true): void
    {
        $this->collPolicykeyssPartial = $v;
    }

    /**
     * Initializes the collPolicykeyss collection.
     *
     * By default this just sets the collPolicykeyss collection to an empty array (like clearcollPolicykeyss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPolicykeyss(bool $overrideExisting = true): void
    {
        if (null !== $this->collPolicykeyss && !$overrideExisting) {
            return;
        }

        $collectionClassName = PolicykeysTableMap::getTableMap()->getCollectionClassName();

        $this->collPolicykeyss = new $collectionClassName;
        $this->collPolicykeyss->setModel('\entities\Policykeys');
    }

    /**
     * Gets an array of ChildPolicykeys objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildPolicykeys[] List of ChildPolicykeys objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPolicykeys> List of ChildPolicykeys objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getPolicykeyss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collPolicykeyssPartial && !$this->isNew();
        if (null === $this->collPolicykeyss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collPolicykeyss) {
                    $this->initPolicykeyss();
                } else {
                    $collectionClassName = PolicykeysTableMap::getTableMap()->getCollectionClassName();

                    $collPolicykeyss = new $collectionClassName;
                    $collPolicykeyss->setModel('\entities\Policykeys');

                    return $collPolicykeyss;
                }
            } else {
                $collPolicykeyss = ChildPolicykeysQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collPolicykeyssPartial && count($collPolicykeyss)) {
                        $this->initPolicykeyss(false);

                        foreach ($collPolicykeyss as $obj) {
                            if (false == $this->collPolicykeyss->contains($obj)) {
                                $this->collPolicykeyss->append($obj);
                            }
                        }

                        $this->collPolicykeyssPartial = true;
                    }

                    return $collPolicykeyss;
                }

                if ($partial && $this->collPolicykeyss) {
                    foreach ($this->collPolicykeyss as $obj) {
                        if ($obj->isNew()) {
                            $collPolicykeyss[] = $obj;
                        }
                    }
                }

                $this->collPolicykeyss = $collPolicykeyss;
                $this->collPolicykeyssPartial = false;
            }
        }

        return $this->collPolicykeyss;
    }

    /**
     * Sets a collection of ChildPolicykeys objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $policykeyss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setPolicykeyss(Collection $policykeyss, ?ConnectionInterface $con = null)
    {
        /** @var ChildPolicykeys[] $policykeyssToDelete */
        $policykeyssToDelete = $this->getPolicykeyss(new Criteria(), $con)->diff($policykeyss);


        //since at least one column in the foreign key is at the same time a PK
        //we can not just set a PK to NULL in the lines below. We have to store
        //a backup of all values, so we are able to manipulate these items based on the onDelete value later.
        $this->policykeyssScheduledForDeletion = clone $policykeyssToDelete;

        foreach ($policykeyssToDelete as $policykeysRemoved) {
            $policykeysRemoved->setCompany(null);
        }

        $this->collPolicykeyss = null;
        foreach ($policykeyss as $policykeys) {
            $this->addPolicykeys($policykeys);
        }

        $this->collPolicykeyss = $policykeyss;
        $this->collPolicykeyssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Policykeys objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Policykeys objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countPolicykeyss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collPolicykeyssPartial && !$this->isNew();
        if (null === $this->collPolicykeyss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPolicykeyss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getPolicykeyss());
            }

            $query = ChildPolicykeysQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collPolicykeyss);
    }

    /**
     * Method called to associate a ChildPolicykeys object to this object
     * through the ChildPolicykeys foreign key attribute.
     *
     * @param ChildPolicykeys $l ChildPolicykeys
     * @return $this The current object (for fluent API support)
     */
    public function addPolicykeys(ChildPolicykeys $l)
    {
        if ($this->collPolicykeyss === null) {
            $this->initPolicykeyss();
            $this->collPolicykeyssPartial = true;
        }

        if (!$this->collPolicykeyss->contains($l)) {
            $this->doAddPolicykeys($l);

            if ($this->policykeyssScheduledForDeletion and $this->policykeyssScheduledForDeletion->contains($l)) {
                $this->policykeyssScheduledForDeletion->remove($this->policykeyssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildPolicykeys $policykeys The ChildPolicykeys object to add.
     */
    protected function doAddPolicykeys(ChildPolicykeys $policykeys): void
    {
        $this->collPolicykeyss[]= $policykeys;
        $policykeys->setCompany($this);
    }

    /**
     * @param ChildPolicykeys $policykeys The ChildPolicykeys object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removePolicykeys(ChildPolicykeys $policykeys)
    {
        if ($this->getPolicykeyss()->contains($policykeys)) {
            $pos = $this->collPolicykeyss->search($policykeys);
            $this->collPolicykeyss->remove($pos);
            if (null === $this->policykeyssScheduledForDeletion) {
                $this->policykeyssScheduledForDeletion = clone $this->collPolicykeyss;
                $this->policykeyssScheduledForDeletion->clear();
            }
            $this->policykeyssScheduledForDeletion[]= clone $policykeys;
            $policykeys->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collPositionss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addPositionss()
     */
    public function clearPositionss()
    {
        $this->collPositionss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collPositionss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialPositionss($v = true): void
    {
        $this->collPositionssPartial = $v;
    }

    /**
     * Initializes the collPositionss collection.
     *
     * By default this just sets the collPositionss collection to an empty array (like clearcollPositionss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPositionss(bool $overrideExisting = true): void
    {
        if (null !== $this->collPositionss && !$overrideExisting) {
            return;
        }

        $collectionClassName = PositionsTableMap::getTableMap()->getCollectionClassName();

        $this->collPositionss = new $collectionClassName;
        $this->collPositionss->setModel('\entities\Positions');
    }

    /**
     * Gets an array of ChildPositions objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildPositions[] List of ChildPositions objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPositions> List of ChildPositions objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getPositionss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collPositionssPartial && !$this->isNew();
        if (null === $this->collPositionss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collPositionss) {
                    $this->initPositionss();
                } else {
                    $collectionClassName = PositionsTableMap::getTableMap()->getCollectionClassName();

                    $collPositionss = new $collectionClassName;
                    $collPositionss->setModel('\entities\Positions');

                    return $collPositionss;
                }
            } else {
                $collPositionss = ChildPositionsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collPositionssPartial && count($collPositionss)) {
                        $this->initPositionss(false);

                        foreach ($collPositionss as $obj) {
                            if (false == $this->collPositionss->contains($obj)) {
                                $this->collPositionss->append($obj);
                            }
                        }

                        $this->collPositionssPartial = true;
                    }

                    return $collPositionss;
                }

                if ($partial && $this->collPositionss) {
                    foreach ($this->collPositionss as $obj) {
                        if ($obj->isNew()) {
                            $collPositionss[] = $obj;
                        }
                    }
                }

                $this->collPositionss = $collPositionss;
                $this->collPositionssPartial = false;
            }
        }

        return $this->collPositionss;
    }

    /**
     * Sets a collection of ChildPositions objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $positionss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setPositionss(Collection $positionss, ?ConnectionInterface $con = null)
    {
        /** @var ChildPositions[] $positionssToDelete */
        $positionssToDelete = $this->getPositionss(new Criteria(), $con)->diff($positionss);


        $this->positionssScheduledForDeletion = $positionssToDelete;

        foreach ($positionssToDelete as $positionsRemoved) {
            $positionsRemoved->setCompany(null);
        }

        $this->collPositionss = null;
        foreach ($positionss as $positions) {
            $this->addPositions($positions);
        }

        $this->collPositionss = $positionss;
        $this->collPositionssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Positions objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Positions objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countPositionss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collPositionssPartial && !$this->isNew();
        if (null === $this->collPositionss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPositionss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getPositionss());
            }

            $query = ChildPositionsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collPositionss);
    }

    /**
     * Method called to associate a ChildPositions object to this object
     * through the ChildPositions foreign key attribute.
     *
     * @param ChildPositions $l ChildPositions
     * @return $this The current object (for fluent API support)
     */
    public function addPositions(ChildPositions $l)
    {
        if ($this->collPositionss === null) {
            $this->initPositionss();
            $this->collPositionssPartial = true;
        }

        if (!$this->collPositionss->contains($l)) {
            $this->doAddPositions($l);

            if ($this->positionssScheduledForDeletion and $this->positionssScheduledForDeletion->contains($l)) {
                $this->positionssScheduledForDeletion->remove($this->positionssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildPositions $positions The ChildPositions object to add.
     */
    protected function doAddPositions(ChildPositions $positions): void
    {
        $this->collPositionss[]= $positions;
        $positions->setCompany($this);
    }

    /**
     * @param ChildPositions $positions The ChildPositions object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removePositions(ChildPositions $positions)
    {
        if ($this->getPositionss()->contains($positions)) {
            $pos = $this->collPositionss->search($positions);
            $this->collPositionss->remove($pos);
            if (null === $this->positionssScheduledForDeletion) {
                $this->positionssScheduledForDeletion = clone $this->collPositionss;
                $this->positionssScheduledForDeletion->clear();
            }
            $this->positionssScheduledForDeletion[]= clone $positions;
            $positions->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Positionss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildPositions[] List of ChildPositions objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPositions}> List of ChildPositions objects
     */
    public function getPositionssJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildPositionsQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getPositionss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Positionss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildPositions[] List of ChildPositions objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPositions}> List of ChildPositions objects
     */
    public function getPositionssJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildPositionsQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getPositionss($query, $con);
    }

    /**
     * Clears out the collPricebookliness collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addPricebookliness()
     */
    public function clearPricebookliness()
    {
        $this->collPricebookliness = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collPricebookliness collection loaded partially.
     *
     * @return void
     */
    public function resetPartialPricebookliness($v = true): void
    {
        $this->collPricebooklinessPartial = $v;
    }

    /**
     * Initializes the collPricebookliness collection.
     *
     * By default this just sets the collPricebookliness collection to an empty array (like clearcollPricebookliness());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPricebookliness(bool $overrideExisting = true): void
    {
        if (null !== $this->collPricebookliness && !$overrideExisting) {
            return;
        }

        $collectionClassName = PricebooklinesTableMap::getTableMap()->getCollectionClassName();

        $this->collPricebookliness = new $collectionClassName;
        $this->collPricebookliness->setModel('\entities\Pricebooklines');
    }

    /**
     * Gets an array of ChildPricebooklines objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildPricebooklines[] List of ChildPricebooklines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPricebooklines> List of ChildPricebooklines objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getPricebookliness(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collPricebooklinessPartial && !$this->isNew();
        if (null === $this->collPricebookliness || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collPricebookliness) {
                    $this->initPricebookliness();
                } else {
                    $collectionClassName = PricebooklinesTableMap::getTableMap()->getCollectionClassName();

                    $collPricebookliness = new $collectionClassName;
                    $collPricebookliness->setModel('\entities\Pricebooklines');

                    return $collPricebookliness;
                }
            } else {
                $collPricebookliness = ChildPricebooklinesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collPricebooklinessPartial && count($collPricebookliness)) {
                        $this->initPricebookliness(false);

                        foreach ($collPricebookliness as $obj) {
                            if (false == $this->collPricebookliness->contains($obj)) {
                                $this->collPricebookliness->append($obj);
                            }
                        }

                        $this->collPricebooklinessPartial = true;
                    }

                    return $collPricebookliness;
                }

                if ($partial && $this->collPricebookliness) {
                    foreach ($this->collPricebookliness as $obj) {
                        if ($obj->isNew()) {
                            $collPricebookliness[] = $obj;
                        }
                    }
                }

                $this->collPricebookliness = $collPricebookliness;
                $this->collPricebooklinessPartial = false;
            }
        }

        return $this->collPricebookliness;
    }

    /**
     * Sets a collection of ChildPricebooklines objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $pricebookliness A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setPricebookliness(Collection $pricebookliness, ?ConnectionInterface $con = null)
    {
        /** @var ChildPricebooklines[] $pricebooklinessToDelete */
        $pricebooklinessToDelete = $this->getPricebookliness(new Criteria(), $con)->diff($pricebookliness);


        $this->pricebooklinessScheduledForDeletion = $pricebooklinessToDelete;

        foreach ($pricebooklinessToDelete as $pricebooklinesRemoved) {
            $pricebooklinesRemoved->setCompany(null);
        }

        $this->collPricebookliness = null;
        foreach ($pricebookliness as $pricebooklines) {
            $this->addPricebooklines($pricebooklines);
        }

        $this->collPricebookliness = $pricebookliness;
        $this->collPricebooklinessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Pricebooklines objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Pricebooklines objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countPricebookliness(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collPricebooklinessPartial && !$this->isNew();
        if (null === $this->collPricebookliness || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPricebookliness) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getPricebookliness());
            }

            $query = ChildPricebooklinesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collPricebookliness);
    }

    /**
     * Method called to associate a ChildPricebooklines object to this object
     * through the ChildPricebooklines foreign key attribute.
     *
     * @param ChildPricebooklines $l ChildPricebooklines
     * @return $this The current object (for fluent API support)
     */
    public function addPricebooklines(ChildPricebooklines $l)
    {
        if ($this->collPricebookliness === null) {
            $this->initPricebookliness();
            $this->collPricebooklinessPartial = true;
        }

        if (!$this->collPricebookliness->contains($l)) {
            $this->doAddPricebooklines($l);

            if ($this->pricebooklinessScheduledForDeletion and $this->pricebooklinessScheduledForDeletion->contains($l)) {
                $this->pricebooklinessScheduledForDeletion->remove($this->pricebooklinessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildPricebooklines $pricebooklines The ChildPricebooklines object to add.
     */
    protected function doAddPricebooklines(ChildPricebooklines $pricebooklines): void
    {
        $this->collPricebookliness[]= $pricebooklines;
        $pricebooklines->setCompany($this);
    }

    /**
     * @param ChildPricebooklines $pricebooklines The ChildPricebooklines object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removePricebooklines(ChildPricebooklines $pricebooklines)
    {
        if ($this->getPricebookliness()->contains($pricebooklines)) {
            $pos = $this->collPricebookliness->search($pricebooklines);
            $this->collPricebookliness->remove($pos);
            if (null === $this->pricebooklinessScheduledForDeletion) {
                $this->pricebooklinessScheduledForDeletion = clone $this->collPricebookliness;
                $this->pricebooklinessScheduledForDeletion->clear();
            }
            $this->pricebooklinessScheduledForDeletion[]= clone $pricebooklines;
            $pricebooklines->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Pricebookliness from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildPricebooklines[] List of ChildPricebooklines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPricebooklines}> List of ChildPricebooklines objects
     */
    public function getPricebooklinessJoinProducts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildPricebooklinesQuery::create(null, $criteria);
        $query->joinWith('Products', $joinBehavior);

        return $this->getPricebookliness($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Pricebookliness from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildPricebooklines[] List of ChildPricebooklines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPricebooklines}> List of ChildPricebooklines objects
     */
    public function getPricebooklinessJoinPricebooks(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildPricebooklinesQuery::create(null, $criteria);
        $query->joinWith('Pricebooks', $joinBehavior);

        return $this->getPricebookliness($query, $con);
    }

    /**
     * Clears out the collPricebookss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addPricebookss()
     */
    public function clearPricebookss()
    {
        $this->collPricebookss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collPricebookss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialPricebookss($v = true): void
    {
        $this->collPricebookssPartial = $v;
    }

    /**
     * Initializes the collPricebookss collection.
     *
     * By default this just sets the collPricebookss collection to an empty array (like clearcollPricebookss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initPricebookss(bool $overrideExisting = true): void
    {
        if (null !== $this->collPricebookss && !$overrideExisting) {
            return;
        }

        $collectionClassName = PricebooksTableMap::getTableMap()->getCollectionClassName();

        $this->collPricebookss = new $collectionClassName;
        $this->collPricebookss->setModel('\entities\Pricebooks');
    }

    /**
     * Gets an array of ChildPricebooks objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildPricebooks[] List of ChildPricebooks objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPricebooks> List of ChildPricebooks objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getPricebookss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collPricebookssPartial && !$this->isNew();
        if (null === $this->collPricebookss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collPricebookss) {
                    $this->initPricebookss();
                } else {
                    $collectionClassName = PricebooksTableMap::getTableMap()->getCollectionClassName();

                    $collPricebookss = new $collectionClassName;
                    $collPricebookss->setModel('\entities\Pricebooks');

                    return $collPricebookss;
                }
            } else {
                $collPricebookss = ChildPricebooksQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collPricebookssPartial && count($collPricebookss)) {
                        $this->initPricebookss(false);

                        foreach ($collPricebookss as $obj) {
                            if (false == $this->collPricebookss->contains($obj)) {
                                $this->collPricebookss->append($obj);
                            }
                        }

                        $this->collPricebookssPartial = true;
                    }

                    return $collPricebookss;
                }

                if ($partial && $this->collPricebookss) {
                    foreach ($this->collPricebookss as $obj) {
                        if ($obj->isNew()) {
                            $collPricebookss[] = $obj;
                        }
                    }
                }

                $this->collPricebookss = $collPricebookss;
                $this->collPricebookssPartial = false;
            }
        }

        return $this->collPricebookss;
    }

    /**
     * Sets a collection of ChildPricebooks objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $pricebookss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setPricebookss(Collection $pricebookss, ?ConnectionInterface $con = null)
    {
        /** @var ChildPricebooks[] $pricebookssToDelete */
        $pricebookssToDelete = $this->getPricebookss(new Criteria(), $con)->diff($pricebookss);


        $this->pricebookssScheduledForDeletion = $pricebookssToDelete;

        foreach ($pricebookssToDelete as $pricebooksRemoved) {
            $pricebooksRemoved->setCompany(null);
        }

        $this->collPricebookss = null;
        foreach ($pricebookss as $pricebooks) {
            $this->addPricebooks($pricebooks);
        }

        $this->collPricebookss = $pricebookss;
        $this->collPricebookssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Pricebooks objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Pricebooks objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countPricebookss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collPricebookssPartial && !$this->isNew();
        if (null === $this->collPricebookss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collPricebookss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getPricebookss());
            }

            $query = ChildPricebooksQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collPricebookss);
    }

    /**
     * Method called to associate a ChildPricebooks object to this object
     * through the ChildPricebooks foreign key attribute.
     *
     * @param ChildPricebooks $l ChildPricebooks
     * @return $this The current object (for fluent API support)
     */
    public function addPricebooks(ChildPricebooks $l)
    {
        if ($this->collPricebookss === null) {
            $this->initPricebookss();
            $this->collPricebookssPartial = true;
        }

        if (!$this->collPricebookss->contains($l)) {
            $this->doAddPricebooks($l);

            if ($this->pricebookssScheduledForDeletion and $this->pricebookssScheduledForDeletion->contains($l)) {
                $this->pricebookssScheduledForDeletion->remove($this->pricebookssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildPricebooks $pricebooks The ChildPricebooks object to add.
     */
    protected function doAddPricebooks(ChildPricebooks $pricebooks): void
    {
        $this->collPricebookss[]= $pricebooks;
        $pricebooks->setCompany($this);
    }

    /**
     * @param ChildPricebooks $pricebooks The ChildPricebooks object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removePricebooks(ChildPricebooks $pricebooks)
    {
        if ($this->getPricebookss()->contains($pricebooks)) {
            $pos = $this->collPricebookss->search($pricebooks);
            $this->collPricebookss->remove($pos);
            if (null === $this->pricebookssScheduledForDeletion) {
                $this->pricebookssScheduledForDeletion = clone $this->collPricebookss;
                $this->pricebookssScheduledForDeletion->clear();
            }
            $this->pricebookssScheduledForDeletion[]= $pricebooks;
            $pricebooks->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Pricebookss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildPricebooks[] List of ChildPricebooks objects
     * @phpstan-return ObjectCollection&\Traversable<ChildPricebooks}> List of ChildPricebooks objects
     */
    public function getPricebookssJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildPricebooksQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getPricebookss($query, $con);
    }

    /**
     * Clears out the collProductss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addProductss()
     */
    public function clearProductss()
    {
        $this->collProductss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collProductss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialProductss($v = true): void
    {
        $this->collProductssPartial = $v;
    }

    /**
     * Initializes the collProductss collection.
     *
     * By default this just sets the collProductss collection to an empty array (like clearcollProductss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initProductss(bool $overrideExisting = true): void
    {
        if (null !== $this->collProductss && !$overrideExisting) {
            return;
        }

        $collectionClassName = ProductsTableMap::getTableMap()->getCollectionClassName();

        $this->collProductss = new $collectionClassName;
        $this->collProductss->setModel('\entities\Products');
    }

    /**
     * Gets an array of ChildProducts objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildProducts[] List of ChildProducts objects
     * @phpstan-return ObjectCollection&\Traversable<ChildProducts> List of ChildProducts objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getProductss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collProductssPartial && !$this->isNew();
        if (null === $this->collProductss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collProductss) {
                    $this->initProductss();
                } else {
                    $collectionClassName = ProductsTableMap::getTableMap()->getCollectionClassName();

                    $collProductss = new $collectionClassName;
                    $collProductss->setModel('\entities\Products');

                    return $collProductss;
                }
            } else {
                $collProductss = ChildProductsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collProductssPartial && count($collProductss)) {
                        $this->initProductss(false);

                        foreach ($collProductss as $obj) {
                            if (false == $this->collProductss->contains($obj)) {
                                $this->collProductss->append($obj);
                            }
                        }

                        $this->collProductssPartial = true;
                    }

                    return $collProductss;
                }

                if ($partial && $this->collProductss) {
                    foreach ($this->collProductss as $obj) {
                        if ($obj->isNew()) {
                            $collProductss[] = $obj;
                        }
                    }
                }

                $this->collProductss = $collProductss;
                $this->collProductssPartial = false;
            }
        }

        return $this->collProductss;
    }

    /**
     * Sets a collection of ChildProducts objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $productss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setProductss(Collection $productss, ?ConnectionInterface $con = null)
    {
        /** @var ChildProducts[] $productssToDelete */
        $productssToDelete = $this->getProductss(new Criteria(), $con)->diff($productss);


        $this->productssScheduledForDeletion = $productssToDelete;

        foreach ($productssToDelete as $productsRemoved) {
            $productsRemoved->setCompany(null);
        }

        $this->collProductss = null;
        foreach ($productss as $products) {
            $this->addProducts($products);
        }

        $this->collProductss = $productss;
        $this->collProductssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Products objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Products objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countProductss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collProductssPartial && !$this->isNew();
        if (null === $this->collProductss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collProductss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getProductss());
            }

            $query = ChildProductsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collProductss);
    }

    /**
     * Method called to associate a ChildProducts object to this object
     * through the ChildProducts foreign key attribute.
     *
     * @param ChildProducts $l ChildProducts
     * @return $this The current object (for fluent API support)
     */
    public function addProducts(ChildProducts $l)
    {
        if ($this->collProductss === null) {
            $this->initProductss();
            $this->collProductssPartial = true;
        }

        if (!$this->collProductss->contains($l)) {
            $this->doAddProducts($l);

            if ($this->productssScheduledForDeletion and $this->productssScheduledForDeletion->contains($l)) {
                $this->productssScheduledForDeletion->remove($this->productssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildProducts $products The ChildProducts object to add.
     */
    protected function doAddProducts(ChildProducts $products): void
    {
        $this->collProductss[]= $products;
        $products->setCompany($this);
    }

    /**
     * @param ChildProducts $products The ChildProducts object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeProducts(ChildProducts $products)
    {
        if ($this->getProductss()->contains($products)) {
            $pos = $this->collProductss->search($products);
            $this->collProductss->remove($pos);
            if (null === $this->productssScheduledForDeletion) {
                $this->productssScheduledForDeletion = clone $this->collProductss;
                $this->productssScheduledForDeletion->clear();
            }
            $this->productssScheduledForDeletion[]= clone $products;
            $products->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Productss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildProducts[] List of ChildProducts objects
     * @phpstan-return ObjectCollection&\Traversable<ChildProducts}> List of ChildProducts objects
     */
    public function getProductssJoinCategories(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildProductsQuery::create(null, $criteria);
        $query->joinWith('Categories', $joinBehavior);

        return $this->getProductss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Productss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildProducts[] List of ChildProducts objects
     * @phpstan-return ObjectCollection&\Traversable<ChildProducts}> List of ChildProducts objects
     */
    public function getProductssJoinTags(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildProductsQuery::create(null, $criteria);
        $query->joinWith('Tags', $joinBehavior);

        return $this->getProductss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Productss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildProducts[] List of ChildProducts objects
     * @phpstan-return ObjectCollection&\Traversable<ChildProducts}> List of ChildProducts objects
     */
    public function getProductssJoinUnitmaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildProductsQuery::create(null, $criteria);
        $query->joinWith('Unitmaster', $joinBehavior);

        return $this->getProductss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Productss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildProducts[] List of ChildProducts objects
     * @phpstan-return ObjectCollection&\Traversable<ChildProducts}> List of ChildProducts objects
     */
    public function getProductssJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildProductsQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getProductss($query, $con);
    }

    /**
     * Clears out the collReminderss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addReminderss()
     */
    public function clearReminderss()
    {
        $this->collReminderss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collReminderss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialReminderss($v = true): void
    {
        $this->collReminderssPartial = $v;
    }

    /**
     * Initializes the collReminderss collection.
     *
     * By default this just sets the collReminderss collection to an empty array (like clearcollReminderss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initReminderss(bool $overrideExisting = true): void
    {
        if (null !== $this->collReminderss && !$overrideExisting) {
            return;
        }

        $collectionClassName = RemindersTableMap::getTableMap()->getCollectionClassName();

        $this->collReminderss = new $collectionClassName;
        $this->collReminderss->setModel('\entities\Reminders');
    }

    /**
     * Gets an array of ChildReminders objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildReminders[] List of ChildReminders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildReminders> List of ChildReminders objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getReminderss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collReminderssPartial && !$this->isNew();
        if (null === $this->collReminderss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collReminderss) {
                    $this->initReminderss();
                } else {
                    $collectionClassName = RemindersTableMap::getTableMap()->getCollectionClassName();

                    $collReminderss = new $collectionClassName;
                    $collReminderss->setModel('\entities\Reminders');

                    return $collReminderss;
                }
            } else {
                $collReminderss = ChildRemindersQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collReminderssPartial && count($collReminderss)) {
                        $this->initReminderss(false);

                        foreach ($collReminderss as $obj) {
                            if (false == $this->collReminderss->contains($obj)) {
                                $this->collReminderss->append($obj);
                            }
                        }

                        $this->collReminderssPartial = true;
                    }

                    return $collReminderss;
                }

                if ($partial && $this->collReminderss) {
                    foreach ($this->collReminderss as $obj) {
                        if ($obj->isNew()) {
                            $collReminderss[] = $obj;
                        }
                    }
                }

                $this->collReminderss = $collReminderss;
                $this->collReminderssPartial = false;
            }
        }

        return $this->collReminderss;
    }

    /**
     * Sets a collection of ChildReminders objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $reminderss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setReminderss(Collection $reminderss, ?ConnectionInterface $con = null)
    {
        /** @var ChildReminders[] $reminderssToDelete */
        $reminderssToDelete = $this->getReminderss(new Criteria(), $con)->diff($reminderss);


        $this->reminderssScheduledForDeletion = $reminderssToDelete;

        foreach ($reminderssToDelete as $remindersRemoved) {
            $remindersRemoved->setCompany(null);
        }

        $this->collReminderss = null;
        foreach ($reminderss as $reminders) {
            $this->addReminders($reminders);
        }

        $this->collReminderss = $reminderss;
        $this->collReminderssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Reminders objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Reminders objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countReminderss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collReminderssPartial && !$this->isNew();
        if (null === $this->collReminderss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collReminderss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getReminderss());
            }

            $query = ChildRemindersQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collReminderss);
    }

    /**
     * Method called to associate a ChildReminders object to this object
     * through the ChildReminders foreign key attribute.
     *
     * @param ChildReminders $l ChildReminders
     * @return $this The current object (for fluent API support)
     */
    public function addReminders(ChildReminders $l)
    {
        if ($this->collReminderss === null) {
            $this->initReminderss();
            $this->collReminderssPartial = true;
        }

        if (!$this->collReminderss->contains($l)) {
            $this->doAddReminders($l);

            if ($this->reminderssScheduledForDeletion and $this->reminderssScheduledForDeletion->contains($l)) {
                $this->reminderssScheduledForDeletion->remove($this->reminderssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildReminders $reminders The ChildReminders object to add.
     */
    protected function doAddReminders(ChildReminders $reminders): void
    {
        $this->collReminderss[]= $reminders;
        $reminders->setCompany($this);
    }

    /**
     * @param ChildReminders $reminders The ChildReminders object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeReminders(ChildReminders $reminders)
    {
        if ($this->getReminderss()->contains($reminders)) {
            $pos = $this->collReminderss->search($reminders);
            $this->collReminderss->remove($pos);
            if (null === $this->reminderssScheduledForDeletion) {
                $this->reminderssScheduledForDeletion = clone $this->collReminderss;
                $this->reminderssScheduledForDeletion->clear();
            }
            $this->reminderssScheduledForDeletion[]= $reminders;
            $reminders->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Reminderss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildReminders[] List of ChildReminders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildReminders}> List of ChildReminders objects
     */
    public function getReminderssJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildRemindersQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getReminderss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Reminderss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildReminders[] List of ChildReminders objects
     * @phpstan-return ObjectCollection&\Traversable<ChildReminders}> List of ChildReminders objects
     */
    public function getReminderssJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildRemindersQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getReminderss($query, $con);
    }

    /**
     * Clears out the collSgpiAccountss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addSgpiAccountss()
     */
    public function clearSgpiAccountss()
    {
        $this->collSgpiAccountss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collSgpiAccountss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialSgpiAccountss($v = true): void
    {
        $this->collSgpiAccountssPartial = $v;
    }

    /**
     * Initializes the collSgpiAccountss collection.
     *
     * By default this just sets the collSgpiAccountss collection to an empty array (like clearcollSgpiAccountss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSgpiAccountss(bool $overrideExisting = true): void
    {
        if (null !== $this->collSgpiAccountss && !$overrideExisting) {
            return;
        }

        $collectionClassName = SgpiAccountsTableMap::getTableMap()->getCollectionClassName();

        $this->collSgpiAccountss = new $collectionClassName;
        $this->collSgpiAccountss->setModel('\entities\SgpiAccounts');
    }

    /**
     * Gets an array of ChildSgpiAccounts objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildSgpiAccounts[] List of ChildSgpiAccounts objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSgpiAccounts> List of ChildSgpiAccounts objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getSgpiAccountss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collSgpiAccountssPartial && !$this->isNew();
        if (null === $this->collSgpiAccountss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collSgpiAccountss) {
                    $this->initSgpiAccountss();
                } else {
                    $collectionClassName = SgpiAccountsTableMap::getTableMap()->getCollectionClassName();

                    $collSgpiAccountss = new $collectionClassName;
                    $collSgpiAccountss->setModel('\entities\SgpiAccounts');

                    return $collSgpiAccountss;
                }
            } else {
                $collSgpiAccountss = ChildSgpiAccountsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collSgpiAccountssPartial && count($collSgpiAccountss)) {
                        $this->initSgpiAccountss(false);

                        foreach ($collSgpiAccountss as $obj) {
                            if (false == $this->collSgpiAccountss->contains($obj)) {
                                $this->collSgpiAccountss->append($obj);
                            }
                        }

                        $this->collSgpiAccountssPartial = true;
                    }

                    return $collSgpiAccountss;
                }

                if ($partial && $this->collSgpiAccountss) {
                    foreach ($this->collSgpiAccountss as $obj) {
                        if ($obj->isNew()) {
                            $collSgpiAccountss[] = $obj;
                        }
                    }
                }

                $this->collSgpiAccountss = $collSgpiAccountss;
                $this->collSgpiAccountssPartial = false;
            }
        }

        return $this->collSgpiAccountss;
    }

    /**
     * Sets a collection of ChildSgpiAccounts objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $sgpiAccountss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setSgpiAccountss(Collection $sgpiAccountss, ?ConnectionInterface $con = null)
    {
        /** @var ChildSgpiAccounts[] $sgpiAccountssToDelete */
        $sgpiAccountssToDelete = $this->getSgpiAccountss(new Criteria(), $con)->diff($sgpiAccountss);


        $this->sgpiAccountssScheduledForDeletion = $sgpiAccountssToDelete;

        foreach ($sgpiAccountssToDelete as $sgpiAccountsRemoved) {
            $sgpiAccountsRemoved->setCompany(null);
        }

        $this->collSgpiAccountss = null;
        foreach ($sgpiAccountss as $sgpiAccounts) {
            $this->addSgpiAccounts($sgpiAccounts);
        }

        $this->collSgpiAccountss = $sgpiAccountss;
        $this->collSgpiAccountssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related SgpiAccounts objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related SgpiAccounts objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countSgpiAccountss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collSgpiAccountssPartial && !$this->isNew();
        if (null === $this->collSgpiAccountss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSgpiAccountss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getSgpiAccountss());
            }

            $query = ChildSgpiAccountsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collSgpiAccountss);
    }

    /**
     * Method called to associate a ChildSgpiAccounts object to this object
     * through the ChildSgpiAccounts foreign key attribute.
     *
     * @param ChildSgpiAccounts $l ChildSgpiAccounts
     * @return $this The current object (for fluent API support)
     */
    public function addSgpiAccounts(ChildSgpiAccounts $l)
    {
        if ($this->collSgpiAccountss === null) {
            $this->initSgpiAccountss();
            $this->collSgpiAccountssPartial = true;
        }

        if (!$this->collSgpiAccountss->contains($l)) {
            $this->doAddSgpiAccounts($l);

            if ($this->sgpiAccountssScheduledForDeletion and $this->sgpiAccountssScheduledForDeletion->contains($l)) {
                $this->sgpiAccountssScheduledForDeletion->remove($this->sgpiAccountssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildSgpiAccounts $sgpiAccounts The ChildSgpiAccounts object to add.
     */
    protected function doAddSgpiAccounts(ChildSgpiAccounts $sgpiAccounts): void
    {
        $this->collSgpiAccountss[]= $sgpiAccounts;
        $sgpiAccounts->setCompany($this);
    }

    /**
     * @param ChildSgpiAccounts $sgpiAccounts The ChildSgpiAccounts object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeSgpiAccounts(ChildSgpiAccounts $sgpiAccounts)
    {
        if ($this->getSgpiAccountss()->contains($sgpiAccounts)) {
            $pos = $this->collSgpiAccountss->search($sgpiAccounts);
            $this->collSgpiAccountss->remove($pos);
            if (null === $this->sgpiAccountssScheduledForDeletion) {
                $this->sgpiAccountssScheduledForDeletion = clone $this->collSgpiAccountss;
                $this->sgpiAccountssScheduledForDeletion->clear();
            }
            $this->sgpiAccountssScheduledForDeletion[]= clone $sgpiAccounts;
            $sgpiAccounts->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collSgpiMasters collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addSgpiMasters()
     */
    public function clearSgpiMasters()
    {
        $this->collSgpiMasters = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collSgpiMasters collection loaded partially.
     *
     * @return void
     */
    public function resetPartialSgpiMasters($v = true): void
    {
        $this->collSgpiMastersPartial = $v;
    }

    /**
     * Initializes the collSgpiMasters collection.
     *
     * By default this just sets the collSgpiMasters collection to an empty array (like clearcollSgpiMasters());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSgpiMasters(bool $overrideExisting = true): void
    {
        if (null !== $this->collSgpiMasters && !$overrideExisting) {
            return;
        }

        $collectionClassName = SgpiMasterTableMap::getTableMap()->getCollectionClassName();

        $this->collSgpiMasters = new $collectionClassName;
        $this->collSgpiMasters->setModel('\entities\SgpiMaster');
    }

    /**
     * Gets an array of ChildSgpiMaster objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildSgpiMaster[] List of ChildSgpiMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSgpiMaster> List of ChildSgpiMaster objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getSgpiMasters(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collSgpiMastersPartial && !$this->isNew();
        if (null === $this->collSgpiMasters || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collSgpiMasters) {
                    $this->initSgpiMasters();
                } else {
                    $collectionClassName = SgpiMasterTableMap::getTableMap()->getCollectionClassName();

                    $collSgpiMasters = new $collectionClassName;
                    $collSgpiMasters->setModel('\entities\SgpiMaster');

                    return $collSgpiMasters;
                }
            } else {
                $collSgpiMasters = ChildSgpiMasterQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collSgpiMastersPartial && count($collSgpiMasters)) {
                        $this->initSgpiMasters(false);

                        foreach ($collSgpiMasters as $obj) {
                            if (false == $this->collSgpiMasters->contains($obj)) {
                                $this->collSgpiMasters->append($obj);
                            }
                        }

                        $this->collSgpiMastersPartial = true;
                    }

                    return $collSgpiMasters;
                }

                if ($partial && $this->collSgpiMasters) {
                    foreach ($this->collSgpiMasters as $obj) {
                        if ($obj->isNew()) {
                            $collSgpiMasters[] = $obj;
                        }
                    }
                }

                $this->collSgpiMasters = $collSgpiMasters;
                $this->collSgpiMastersPartial = false;
            }
        }

        return $this->collSgpiMasters;
    }

    /**
     * Sets a collection of ChildSgpiMaster objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $sgpiMasters A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setSgpiMasters(Collection $sgpiMasters, ?ConnectionInterface $con = null)
    {
        /** @var ChildSgpiMaster[] $sgpiMastersToDelete */
        $sgpiMastersToDelete = $this->getSgpiMasters(new Criteria(), $con)->diff($sgpiMasters);


        $this->sgpiMastersScheduledForDeletion = $sgpiMastersToDelete;

        foreach ($sgpiMastersToDelete as $sgpiMasterRemoved) {
            $sgpiMasterRemoved->setCompany(null);
        }

        $this->collSgpiMasters = null;
        foreach ($sgpiMasters as $sgpiMaster) {
            $this->addSgpiMaster($sgpiMaster);
        }

        $this->collSgpiMasters = $sgpiMasters;
        $this->collSgpiMastersPartial = false;

        return $this;
    }

    /**
     * Returns the number of related SgpiMaster objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related SgpiMaster objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countSgpiMasters(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collSgpiMastersPartial && !$this->isNew();
        if (null === $this->collSgpiMasters || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSgpiMasters) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getSgpiMasters());
            }

            $query = ChildSgpiMasterQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collSgpiMasters);
    }

    /**
     * Method called to associate a ChildSgpiMaster object to this object
     * through the ChildSgpiMaster foreign key attribute.
     *
     * @param ChildSgpiMaster $l ChildSgpiMaster
     * @return $this The current object (for fluent API support)
     */
    public function addSgpiMaster(ChildSgpiMaster $l)
    {
        if ($this->collSgpiMasters === null) {
            $this->initSgpiMasters();
            $this->collSgpiMastersPartial = true;
        }

        if (!$this->collSgpiMasters->contains($l)) {
            $this->doAddSgpiMaster($l);

            if ($this->sgpiMastersScheduledForDeletion and $this->sgpiMastersScheduledForDeletion->contains($l)) {
                $this->sgpiMastersScheduledForDeletion->remove($this->sgpiMastersScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildSgpiMaster $sgpiMaster The ChildSgpiMaster object to add.
     */
    protected function doAddSgpiMaster(ChildSgpiMaster $sgpiMaster): void
    {
        $this->collSgpiMasters[]= $sgpiMaster;
        $sgpiMaster->setCompany($this);
    }

    /**
     * @param ChildSgpiMaster $sgpiMaster The ChildSgpiMaster object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeSgpiMaster(ChildSgpiMaster $sgpiMaster)
    {
        if ($this->getSgpiMasters()->contains($sgpiMaster)) {
            $pos = $this->collSgpiMasters->search($sgpiMaster);
            $this->collSgpiMasters->remove($pos);
            if (null === $this->sgpiMastersScheduledForDeletion) {
                $this->sgpiMastersScheduledForDeletion = clone $this->collSgpiMasters;
                $this->sgpiMastersScheduledForDeletion->clear();
            }
            $this->sgpiMastersScheduledForDeletion[]= $sgpiMaster;
            $sgpiMaster->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SgpiMasters from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSgpiMaster[] List of ChildSgpiMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSgpiMaster}> List of ChildSgpiMaster objects
     */
    public function getSgpiMastersJoinBrands(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSgpiMasterQuery::create(null, $criteria);
        $query->joinWith('Brands', $joinBehavior);

        return $this->getSgpiMasters($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SgpiMasters from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSgpiMaster[] List of ChildSgpiMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSgpiMaster}> List of ChildSgpiMaster objects
     */
    public function getSgpiMastersJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSgpiMasterQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getSgpiMasters($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SgpiMasters from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSgpiMaster[] List of ChildSgpiMaster objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSgpiMaster}> List of ChildSgpiMaster objects
     */
    public function getSgpiMastersJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSgpiMasterQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getSgpiMasters($query, $con);
    }

    /**
     * Clears out the collSgpiTranss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addSgpiTranss()
     */
    public function clearSgpiTranss()
    {
        $this->collSgpiTranss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collSgpiTranss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialSgpiTranss($v = true): void
    {
        $this->collSgpiTranssPartial = $v;
    }

    /**
     * Initializes the collSgpiTranss collection.
     *
     * By default this just sets the collSgpiTranss collection to an empty array (like clearcollSgpiTranss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSgpiTranss(bool $overrideExisting = true): void
    {
        if (null !== $this->collSgpiTranss && !$overrideExisting) {
            return;
        }

        $collectionClassName = SgpiTransTableMap::getTableMap()->getCollectionClassName();

        $this->collSgpiTranss = new $collectionClassName;
        $this->collSgpiTranss->setModel('\entities\SgpiTrans');
    }

    /**
     * Gets an array of ChildSgpiTrans objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildSgpiTrans[] List of ChildSgpiTrans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSgpiTrans> List of ChildSgpiTrans objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getSgpiTranss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collSgpiTranssPartial && !$this->isNew();
        if (null === $this->collSgpiTranss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collSgpiTranss) {
                    $this->initSgpiTranss();
                } else {
                    $collectionClassName = SgpiTransTableMap::getTableMap()->getCollectionClassName();

                    $collSgpiTranss = new $collectionClassName;
                    $collSgpiTranss->setModel('\entities\SgpiTrans');

                    return $collSgpiTranss;
                }
            } else {
                $collSgpiTranss = ChildSgpiTransQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collSgpiTranssPartial && count($collSgpiTranss)) {
                        $this->initSgpiTranss(false);

                        foreach ($collSgpiTranss as $obj) {
                            if (false == $this->collSgpiTranss->contains($obj)) {
                                $this->collSgpiTranss->append($obj);
                            }
                        }

                        $this->collSgpiTranssPartial = true;
                    }

                    return $collSgpiTranss;
                }

                if ($partial && $this->collSgpiTranss) {
                    foreach ($this->collSgpiTranss as $obj) {
                        if ($obj->isNew()) {
                            $collSgpiTranss[] = $obj;
                        }
                    }
                }

                $this->collSgpiTranss = $collSgpiTranss;
                $this->collSgpiTranssPartial = false;
            }
        }

        return $this->collSgpiTranss;
    }

    /**
     * Sets a collection of ChildSgpiTrans objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $sgpiTranss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setSgpiTranss(Collection $sgpiTranss, ?ConnectionInterface $con = null)
    {
        /** @var ChildSgpiTrans[] $sgpiTranssToDelete */
        $sgpiTranssToDelete = $this->getSgpiTranss(new Criteria(), $con)->diff($sgpiTranss);


        $this->sgpiTranssScheduledForDeletion = $sgpiTranssToDelete;

        foreach ($sgpiTranssToDelete as $sgpiTransRemoved) {
            $sgpiTransRemoved->setCompany(null);
        }

        $this->collSgpiTranss = null;
        foreach ($sgpiTranss as $sgpiTrans) {
            $this->addSgpiTrans($sgpiTrans);
        }

        $this->collSgpiTranss = $sgpiTranss;
        $this->collSgpiTranssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related SgpiTrans objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related SgpiTrans objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countSgpiTranss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collSgpiTranssPartial && !$this->isNew();
        if (null === $this->collSgpiTranss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSgpiTranss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getSgpiTranss());
            }

            $query = ChildSgpiTransQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collSgpiTranss);
    }

    /**
     * Method called to associate a ChildSgpiTrans object to this object
     * through the ChildSgpiTrans foreign key attribute.
     *
     * @param ChildSgpiTrans $l ChildSgpiTrans
     * @return $this The current object (for fluent API support)
     */
    public function addSgpiTrans(ChildSgpiTrans $l)
    {
        if ($this->collSgpiTranss === null) {
            $this->initSgpiTranss();
            $this->collSgpiTranssPartial = true;
        }

        if (!$this->collSgpiTranss->contains($l)) {
            $this->doAddSgpiTrans($l);

            if ($this->sgpiTranssScheduledForDeletion and $this->sgpiTranssScheduledForDeletion->contains($l)) {
                $this->sgpiTranssScheduledForDeletion->remove($this->sgpiTranssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildSgpiTrans $sgpiTrans The ChildSgpiTrans object to add.
     */
    protected function doAddSgpiTrans(ChildSgpiTrans $sgpiTrans): void
    {
        $this->collSgpiTranss[]= $sgpiTrans;
        $sgpiTrans->setCompany($this);
    }

    /**
     * @param ChildSgpiTrans $sgpiTrans The ChildSgpiTrans object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeSgpiTrans(ChildSgpiTrans $sgpiTrans)
    {
        if ($this->getSgpiTranss()->contains($sgpiTrans)) {
            $pos = $this->collSgpiTranss->search($sgpiTrans);
            $this->collSgpiTranss->remove($pos);
            if (null === $this->sgpiTranssScheduledForDeletion) {
                $this->sgpiTranssScheduledForDeletion = clone $this->collSgpiTranss;
                $this->sgpiTranssScheduledForDeletion->clear();
            }
            $this->sgpiTranssScheduledForDeletion[]= $sgpiTrans;
            $sgpiTrans->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SgpiTranss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSgpiTrans[] List of ChildSgpiTrans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSgpiTrans}> List of ChildSgpiTrans objects
     */
    public function getSgpiTranssJoinSgpiAccounts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSgpiTransQuery::create(null, $criteria);
        $query->joinWith('SgpiAccounts', $joinBehavior);

        return $this->getSgpiTranss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SgpiTranss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSgpiTrans[] List of ChildSgpiTrans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSgpiTrans}> List of ChildSgpiTrans objects
     */
    public function getSgpiTranssJoinSgpiMaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSgpiTransQuery::create(null, $criteria);
        $query->joinWith('SgpiMaster', $joinBehavior);

        return $this->getSgpiTranss($query, $con);
    }

    /**
     * Clears out the collShiftTypess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addShiftTypess()
     */
    public function clearShiftTypess()
    {
        $this->collShiftTypess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collShiftTypess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialShiftTypess($v = true): void
    {
        $this->collShiftTypessPartial = $v;
    }

    /**
     * Initializes the collShiftTypess collection.
     *
     * By default this just sets the collShiftTypess collection to an empty array (like clearcollShiftTypess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initShiftTypess(bool $overrideExisting = true): void
    {
        if (null !== $this->collShiftTypess && !$overrideExisting) {
            return;
        }

        $collectionClassName = ShiftTypesTableMap::getTableMap()->getCollectionClassName();

        $this->collShiftTypess = new $collectionClassName;
        $this->collShiftTypess->setModel('\entities\ShiftTypes');
    }

    /**
     * Gets an array of ChildShiftTypes objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildShiftTypes[] List of ChildShiftTypes objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShiftTypes> List of ChildShiftTypes objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getShiftTypess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collShiftTypessPartial && !$this->isNew();
        if (null === $this->collShiftTypess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collShiftTypess) {
                    $this->initShiftTypess();
                } else {
                    $collectionClassName = ShiftTypesTableMap::getTableMap()->getCollectionClassName();

                    $collShiftTypess = new $collectionClassName;
                    $collShiftTypess->setModel('\entities\ShiftTypes');

                    return $collShiftTypess;
                }
            } else {
                $collShiftTypess = ChildShiftTypesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collShiftTypessPartial && count($collShiftTypess)) {
                        $this->initShiftTypess(false);

                        foreach ($collShiftTypess as $obj) {
                            if (false == $this->collShiftTypess->contains($obj)) {
                                $this->collShiftTypess->append($obj);
                            }
                        }

                        $this->collShiftTypessPartial = true;
                    }

                    return $collShiftTypess;
                }

                if ($partial && $this->collShiftTypess) {
                    foreach ($this->collShiftTypess as $obj) {
                        if ($obj->isNew()) {
                            $collShiftTypess[] = $obj;
                        }
                    }
                }

                $this->collShiftTypess = $collShiftTypess;
                $this->collShiftTypessPartial = false;
            }
        }

        return $this->collShiftTypess;
    }

    /**
     * Sets a collection of ChildShiftTypes objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $shiftTypess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setShiftTypess(Collection $shiftTypess, ?ConnectionInterface $con = null)
    {
        /** @var ChildShiftTypes[] $shiftTypessToDelete */
        $shiftTypessToDelete = $this->getShiftTypess(new Criteria(), $con)->diff($shiftTypess);


        $this->shiftTypessScheduledForDeletion = $shiftTypessToDelete;

        foreach ($shiftTypessToDelete as $shiftTypesRemoved) {
            $shiftTypesRemoved->setCompany(null);
        }

        $this->collShiftTypess = null;
        foreach ($shiftTypess as $shiftTypes) {
            $this->addShiftTypes($shiftTypes);
        }

        $this->collShiftTypess = $shiftTypess;
        $this->collShiftTypessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related ShiftTypes objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related ShiftTypes objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countShiftTypess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collShiftTypessPartial && !$this->isNew();
        if (null === $this->collShiftTypess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collShiftTypess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getShiftTypess());
            }

            $query = ChildShiftTypesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collShiftTypess);
    }

    /**
     * Method called to associate a ChildShiftTypes object to this object
     * through the ChildShiftTypes foreign key attribute.
     *
     * @param ChildShiftTypes $l ChildShiftTypes
     * @return $this The current object (for fluent API support)
     */
    public function addShiftTypes(ChildShiftTypes $l)
    {
        if ($this->collShiftTypess === null) {
            $this->initShiftTypess();
            $this->collShiftTypessPartial = true;
        }

        if (!$this->collShiftTypess->contains($l)) {
            $this->doAddShiftTypes($l);

            if ($this->shiftTypessScheduledForDeletion and $this->shiftTypessScheduledForDeletion->contains($l)) {
                $this->shiftTypessScheduledForDeletion->remove($this->shiftTypessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildShiftTypes $shiftTypes The ChildShiftTypes object to add.
     */
    protected function doAddShiftTypes(ChildShiftTypes $shiftTypes): void
    {
        $this->collShiftTypess[]= $shiftTypes;
        $shiftTypes->setCompany($this);
    }

    /**
     * @param ChildShiftTypes $shiftTypes The ChildShiftTypes object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeShiftTypes(ChildShiftTypes $shiftTypes)
    {
        if ($this->getShiftTypess()->contains($shiftTypes)) {
            $pos = $this->collShiftTypess->search($shiftTypes);
            $this->collShiftTypess->remove($pos);
            if (null === $this->shiftTypessScheduledForDeletion) {
                $this->shiftTypessScheduledForDeletion = clone $this->collShiftTypess;
                $this->shiftTypessScheduledForDeletion->clear();
            }
            $this->shiftTypessScheduledForDeletion[]= clone $shiftTypes;
            $shiftTypes->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collShippingliness collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addShippingliness()
     */
    public function clearShippingliness()
    {
        $this->collShippingliness = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collShippingliness collection loaded partially.
     *
     * @return void
     */
    public function resetPartialShippingliness($v = true): void
    {
        $this->collShippinglinessPartial = $v;
    }

    /**
     * Initializes the collShippingliness collection.
     *
     * By default this just sets the collShippingliness collection to an empty array (like clearcollShippingliness());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initShippingliness(bool $overrideExisting = true): void
    {
        if (null !== $this->collShippingliness && !$overrideExisting) {
            return;
        }

        $collectionClassName = ShippinglinesTableMap::getTableMap()->getCollectionClassName();

        $this->collShippingliness = new $collectionClassName;
        $this->collShippingliness->setModel('\entities\Shippinglines');
    }

    /**
     * Gets an array of ChildShippinglines objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildShippinglines[] List of ChildShippinglines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShippinglines> List of ChildShippinglines objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getShippingliness(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collShippinglinessPartial && !$this->isNew();
        if (null === $this->collShippingliness || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collShippingliness) {
                    $this->initShippingliness();
                } else {
                    $collectionClassName = ShippinglinesTableMap::getTableMap()->getCollectionClassName();

                    $collShippingliness = new $collectionClassName;
                    $collShippingliness->setModel('\entities\Shippinglines');

                    return $collShippingliness;
                }
            } else {
                $collShippingliness = ChildShippinglinesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collShippinglinessPartial && count($collShippingliness)) {
                        $this->initShippingliness(false);

                        foreach ($collShippingliness as $obj) {
                            if (false == $this->collShippingliness->contains($obj)) {
                                $this->collShippingliness->append($obj);
                            }
                        }

                        $this->collShippinglinessPartial = true;
                    }

                    return $collShippingliness;
                }

                if ($partial && $this->collShippingliness) {
                    foreach ($this->collShippingliness as $obj) {
                        if ($obj->isNew()) {
                            $collShippingliness[] = $obj;
                        }
                    }
                }

                $this->collShippingliness = $collShippingliness;
                $this->collShippinglinessPartial = false;
            }
        }

        return $this->collShippingliness;
    }

    /**
     * Sets a collection of ChildShippinglines objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $shippingliness A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setShippingliness(Collection $shippingliness, ?ConnectionInterface $con = null)
    {
        /** @var ChildShippinglines[] $shippinglinessToDelete */
        $shippinglinessToDelete = $this->getShippingliness(new Criteria(), $con)->diff($shippingliness);


        $this->shippinglinessScheduledForDeletion = $shippinglinessToDelete;

        foreach ($shippinglinessToDelete as $shippinglinesRemoved) {
            $shippinglinesRemoved->setCompany(null);
        }

        $this->collShippingliness = null;
        foreach ($shippingliness as $shippinglines) {
            $this->addShippinglines($shippinglines);
        }

        $this->collShippingliness = $shippingliness;
        $this->collShippinglinessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Shippinglines objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Shippinglines objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countShippingliness(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collShippinglinessPartial && !$this->isNew();
        if (null === $this->collShippingliness || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collShippingliness) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getShippingliness());
            }

            $query = ChildShippinglinesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collShippingliness);
    }

    /**
     * Method called to associate a ChildShippinglines object to this object
     * through the ChildShippinglines foreign key attribute.
     *
     * @param ChildShippinglines $l ChildShippinglines
     * @return $this The current object (for fluent API support)
     */
    public function addShippinglines(ChildShippinglines $l)
    {
        if ($this->collShippingliness === null) {
            $this->initShippingliness();
            $this->collShippinglinessPartial = true;
        }

        if (!$this->collShippingliness->contains($l)) {
            $this->doAddShippinglines($l);

            if ($this->shippinglinessScheduledForDeletion and $this->shippinglinessScheduledForDeletion->contains($l)) {
                $this->shippinglinessScheduledForDeletion->remove($this->shippinglinessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildShippinglines $shippinglines The ChildShippinglines object to add.
     */
    protected function doAddShippinglines(ChildShippinglines $shippinglines): void
    {
        $this->collShippingliness[]= $shippinglines;
        $shippinglines->setCompany($this);
    }

    /**
     * @param ChildShippinglines $shippinglines The ChildShippinglines object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeShippinglines(ChildShippinglines $shippinglines)
    {
        if ($this->getShippingliness()->contains($shippinglines)) {
            $pos = $this->collShippingliness->search($shippinglines);
            $this->collShippingliness->remove($pos);
            if (null === $this->shippinglinessScheduledForDeletion) {
                $this->shippinglinessScheduledForDeletion = clone $this->collShippingliness;
                $this->shippinglinessScheduledForDeletion->clear();
            }
            $this->shippinglinessScheduledForDeletion[]= clone $shippinglines;
            $shippinglines->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Shippingliness from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildShippinglines[] List of ChildShippinglines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShippinglines}> List of ChildShippinglines objects
     */
    public function getShippinglinessJoinOrderlines(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildShippinglinesQuery::create(null, $criteria);
        $query->joinWith('Orderlines', $joinBehavior);

        return $this->getShippingliness($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Shippingliness from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildShippinglines[] List of ChildShippinglines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShippinglines}> List of ChildShippinglines objects
     */
    public function getShippinglinessJoinProducts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildShippinglinesQuery::create(null, $criteria);
        $query->joinWith('Products', $joinBehavior);

        return $this->getShippingliness($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Shippingliness from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildShippinglines[] List of ChildShippinglines objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShippinglines}> List of ChildShippinglines objects
     */
    public function getShippinglinessJoinShippingorder(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildShippinglinesQuery::create(null, $criteria);
        $query->joinWith('Shippingorder', $joinBehavior);

        return $this->getShippingliness($query, $con);
    }

    /**
     * Clears out the collShippingorders collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addShippingorders()
     */
    public function clearShippingorders()
    {
        $this->collShippingorders = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collShippingorders collection loaded partially.
     *
     * @return void
     */
    public function resetPartialShippingorders($v = true): void
    {
        $this->collShippingordersPartial = $v;
    }

    /**
     * Initializes the collShippingorders collection.
     *
     * By default this just sets the collShippingorders collection to an empty array (like clearcollShippingorders());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initShippingorders(bool $overrideExisting = true): void
    {
        if (null !== $this->collShippingorders && !$overrideExisting) {
            return;
        }

        $collectionClassName = ShippingorderTableMap::getTableMap()->getCollectionClassName();

        $this->collShippingorders = new $collectionClassName;
        $this->collShippingorders->setModel('\entities\Shippingorder');
    }

    /**
     * Gets an array of ChildShippingorder objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildShippingorder[] List of ChildShippingorder objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShippingorder> List of ChildShippingorder objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getShippingorders(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collShippingordersPartial && !$this->isNew();
        if (null === $this->collShippingorders || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collShippingorders) {
                    $this->initShippingorders();
                } else {
                    $collectionClassName = ShippingorderTableMap::getTableMap()->getCollectionClassName();

                    $collShippingorders = new $collectionClassName;
                    $collShippingorders->setModel('\entities\Shippingorder');

                    return $collShippingorders;
                }
            } else {
                $collShippingorders = ChildShippingorderQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collShippingordersPartial && count($collShippingorders)) {
                        $this->initShippingorders(false);

                        foreach ($collShippingorders as $obj) {
                            if (false == $this->collShippingorders->contains($obj)) {
                                $this->collShippingorders->append($obj);
                            }
                        }

                        $this->collShippingordersPartial = true;
                    }

                    return $collShippingorders;
                }

                if ($partial && $this->collShippingorders) {
                    foreach ($this->collShippingorders as $obj) {
                        if ($obj->isNew()) {
                            $collShippingorders[] = $obj;
                        }
                    }
                }

                $this->collShippingorders = $collShippingorders;
                $this->collShippingordersPartial = false;
            }
        }

        return $this->collShippingorders;
    }

    /**
     * Sets a collection of ChildShippingorder objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $shippingorders A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setShippingorders(Collection $shippingorders, ?ConnectionInterface $con = null)
    {
        /** @var ChildShippingorder[] $shippingordersToDelete */
        $shippingordersToDelete = $this->getShippingorders(new Criteria(), $con)->diff($shippingorders);


        $this->shippingordersScheduledForDeletion = $shippingordersToDelete;

        foreach ($shippingordersToDelete as $shippingorderRemoved) {
            $shippingorderRemoved->setCompany(null);
        }

        $this->collShippingorders = null;
        foreach ($shippingorders as $shippingorder) {
            $this->addShippingorder($shippingorder);
        }

        $this->collShippingorders = $shippingorders;
        $this->collShippingordersPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Shippingorder objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Shippingorder objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countShippingorders(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collShippingordersPartial && !$this->isNew();
        if (null === $this->collShippingorders || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collShippingorders) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getShippingorders());
            }

            $query = ChildShippingorderQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collShippingorders);
    }

    /**
     * Method called to associate a ChildShippingorder object to this object
     * through the ChildShippingorder foreign key attribute.
     *
     * @param ChildShippingorder $l ChildShippingorder
     * @return $this The current object (for fluent API support)
     */
    public function addShippingorder(ChildShippingorder $l)
    {
        if ($this->collShippingorders === null) {
            $this->initShippingorders();
            $this->collShippingordersPartial = true;
        }

        if (!$this->collShippingorders->contains($l)) {
            $this->doAddShippingorder($l);

            if ($this->shippingordersScheduledForDeletion and $this->shippingordersScheduledForDeletion->contains($l)) {
                $this->shippingordersScheduledForDeletion->remove($this->shippingordersScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildShippingorder $shippingorder The ChildShippingorder object to add.
     */
    protected function doAddShippingorder(ChildShippingorder $shippingorder): void
    {
        $this->collShippingorders[]= $shippingorder;
        $shippingorder->setCompany($this);
    }

    /**
     * @param ChildShippingorder $shippingorder The ChildShippingorder object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeShippingorder(ChildShippingorder $shippingorder)
    {
        if ($this->getShippingorders()->contains($shippingorder)) {
            $pos = $this->collShippingorders->search($shippingorder);
            $this->collShippingorders->remove($pos);
            if (null === $this->shippingordersScheduledForDeletion) {
                $this->shippingordersScheduledForDeletion = clone $this->collShippingorders;
                $this->shippingordersScheduledForDeletion->clear();
            }
            $this->shippingordersScheduledForDeletion[]= clone $shippingorder;
            $shippingorder->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Shippingorders from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildShippingorder[] List of ChildShippingorder objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShippingorder}> List of ChildShippingorder objects
     */
    public function getShippingordersJoinOrders(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildShippingorderQuery::create(null, $criteria);
        $query->joinWith('Orders', $joinBehavior);

        return $this->getShippingorders($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Shippingorders from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildShippingorder[] List of ChildShippingorder objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShippingorder}> List of ChildShippingorder objects
     */
    public function getShippingordersJoinStockVoucher(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildShippingorderQuery::create(null, $criteria);
        $query->joinWith('StockVoucher', $joinBehavior);

        return $this->getShippingorders($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Shippingorders from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildShippingorder[] List of ChildShippingorder objects
     * @phpstan-return ObjectCollection&\Traversable<ChildShippingorder}> List of ChildShippingorder objects
     */
    public function getShippingordersJoinUsers(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildShippingorderQuery::create(null, $criteria);
        $query->joinWith('Users', $joinBehavior);

        return $this->getShippingorders($query, $con);
    }

    /**
     * Clears out the collStockTransactions collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addStockTransactions()
     */
    public function clearStockTransactions()
    {
        $this->collStockTransactions = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collStockTransactions collection loaded partially.
     *
     * @return void
     */
    public function resetPartialStockTransactions($v = true): void
    {
        $this->collStockTransactionsPartial = $v;
    }

    /**
     * Initializes the collStockTransactions collection.
     *
     * By default this just sets the collStockTransactions collection to an empty array (like clearcollStockTransactions());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initStockTransactions(bool $overrideExisting = true): void
    {
        if (null !== $this->collStockTransactions && !$overrideExisting) {
            return;
        }

        $collectionClassName = StockTransactionTableMap::getTableMap()->getCollectionClassName();

        $this->collStockTransactions = new $collectionClassName;
        $this->collStockTransactions->setModel('\entities\StockTransaction');
    }

    /**
     * Gets an array of ChildStockTransaction objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildStockTransaction[] List of ChildStockTransaction objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStockTransaction> List of ChildStockTransaction objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getStockTransactions(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collStockTransactionsPartial && !$this->isNew();
        if (null === $this->collStockTransactions || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collStockTransactions) {
                    $this->initStockTransactions();
                } else {
                    $collectionClassName = StockTransactionTableMap::getTableMap()->getCollectionClassName();

                    $collStockTransactions = new $collectionClassName;
                    $collStockTransactions->setModel('\entities\StockTransaction');

                    return $collStockTransactions;
                }
            } else {
                $collStockTransactions = ChildStockTransactionQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collStockTransactionsPartial && count($collStockTransactions)) {
                        $this->initStockTransactions(false);

                        foreach ($collStockTransactions as $obj) {
                            if (false == $this->collStockTransactions->contains($obj)) {
                                $this->collStockTransactions->append($obj);
                            }
                        }

                        $this->collStockTransactionsPartial = true;
                    }

                    return $collStockTransactions;
                }

                if ($partial && $this->collStockTransactions) {
                    foreach ($this->collStockTransactions as $obj) {
                        if ($obj->isNew()) {
                            $collStockTransactions[] = $obj;
                        }
                    }
                }

                $this->collStockTransactions = $collStockTransactions;
                $this->collStockTransactionsPartial = false;
            }
        }

        return $this->collStockTransactions;
    }

    /**
     * Sets a collection of ChildStockTransaction objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $stockTransactions A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setStockTransactions(Collection $stockTransactions, ?ConnectionInterface $con = null)
    {
        /** @var ChildStockTransaction[] $stockTransactionsToDelete */
        $stockTransactionsToDelete = $this->getStockTransactions(new Criteria(), $con)->diff($stockTransactions);


        $this->stockTransactionsScheduledForDeletion = $stockTransactionsToDelete;

        foreach ($stockTransactionsToDelete as $stockTransactionRemoved) {
            $stockTransactionRemoved->setCompany(null);
        }

        $this->collStockTransactions = null;
        foreach ($stockTransactions as $stockTransaction) {
            $this->addStockTransaction($stockTransaction);
        }

        $this->collStockTransactions = $stockTransactions;
        $this->collStockTransactionsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related StockTransaction objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related StockTransaction objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countStockTransactions(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collStockTransactionsPartial && !$this->isNew();
        if (null === $this->collStockTransactions || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collStockTransactions) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getStockTransactions());
            }

            $query = ChildStockTransactionQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collStockTransactions);
    }

    /**
     * Method called to associate a ChildStockTransaction object to this object
     * through the ChildStockTransaction foreign key attribute.
     *
     * @param ChildStockTransaction $l ChildStockTransaction
     * @return $this The current object (for fluent API support)
     */
    public function addStockTransaction(ChildStockTransaction $l)
    {
        if ($this->collStockTransactions === null) {
            $this->initStockTransactions();
            $this->collStockTransactionsPartial = true;
        }

        if (!$this->collStockTransactions->contains($l)) {
            $this->doAddStockTransaction($l);

            if ($this->stockTransactionsScheduledForDeletion and $this->stockTransactionsScheduledForDeletion->contains($l)) {
                $this->stockTransactionsScheduledForDeletion->remove($this->stockTransactionsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildStockTransaction $stockTransaction The ChildStockTransaction object to add.
     */
    protected function doAddStockTransaction(ChildStockTransaction $stockTransaction): void
    {
        $this->collStockTransactions[]= $stockTransaction;
        $stockTransaction->setCompany($this);
    }

    /**
     * @param ChildStockTransaction $stockTransaction The ChildStockTransaction object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeStockTransaction(ChildStockTransaction $stockTransaction)
    {
        if ($this->getStockTransactions()->contains($stockTransaction)) {
            $pos = $this->collStockTransactions->search($stockTransaction);
            $this->collStockTransactions->remove($pos);
            if (null === $this->stockTransactionsScheduledForDeletion) {
                $this->stockTransactionsScheduledForDeletion = clone $this->collStockTransactions;
                $this->stockTransactionsScheduledForDeletion->clear();
            }
            $this->stockTransactionsScheduledForDeletion[]= clone $stockTransaction;
            $stockTransaction->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related StockTransactions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStockTransaction[] List of ChildStockTransaction objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStockTransaction}> List of ChildStockTransaction objects
     */
    public function getStockTransactionsJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStockTransactionQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getStockTransactions($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related StockTransactions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStockTransaction[] List of ChildStockTransaction objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStockTransaction}> List of ChildStockTransaction objects
     */
    public function getStockTransactionsJoinProducts(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStockTransactionQuery::create(null, $criteria);
        $query->joinWith('Products', $joinBehavior);

        return $this->getStockTransactions($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related StockTransactions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStockTransaction[] List of ChildStockTransaction objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStockTransaction}> List of ChildStockTransaction objects
     */
    public function getStockTransactionsJoinStockVoucher(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStockTransactionQuery::create(null, $criteria);
        $query->joinWith('StockVoucher', $joinBehavior);

        return $this->getStockTransactions($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related StockTransactions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStockTransaction[] List of ChildStockTransaction objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStockTransaction}> List of ChildStockTransaction objects
     */
    public function getStockTransactionsJoinUsers(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStockTransactionQuery::create(null, $criteria);
        $query->joinWith('Users', $joinBehavior);

        return $this->getStockTransactions($query, $con);
    }

    /**
     * Clears out the collStockVouchers collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addStockVouchers()
     */
    public function clearStockVouchers()
    {
        $this->collStockVouchers = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collStockVouchers collection loaded partially.
     *
     * @return void
     */
    public function resetPartialStockVouchers($v = true): void
    {
        $this->collStockVouchersPartial = $v;
    }

    /**
     * Initializes the collStockVouchers collection.
     *
     * By default this just sets the collStockVouchers collection to an empty array (like clearcollStockVouchers());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initStockVouchers(bool $overrideExisting = true): void
    {
        if (null !== $this->collStockVouchers && !$overrideExisting) {
            return;
        }

        $collectionClassName = StockVoucherTableMap::getTableMap()->getCollectionClassName();

        $this->collStockVouchers = new $collectionClassName;
        $this->collStockVouchers->setModel('\entities\StockVoucher');
    }

    /**
     * Gets an array of ChildStockVoucher objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildStockVoucher[] List of ChildStockVoucher objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStockVoucher> List of ChildStockVoucher objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getStockVouchers(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collStockVouchersPartial && !$this->isNew();
        if (null === $this->collStockVouchers || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collStockVouchers) {
                    $this->initStockVouchers();
                } else {
                    $collectionClassName = StockVoucherTableMap::getTableMap()->getCollectionClassName();

                    $collStockVouchers = new $collectionClassName;
                    $collStockVouchers->setModel('\entities\StockVoucher');

                    return $collStockVouchers;
                }
            } else {
                $collStockVouchers = ChildStockVoucherQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collStockVouchersPartial && count($collStockVouchers)) {
                        $this->initStockVouchers(false);

                        foreach ($collStockVouchers as $obj) {
                            if (false == $this->collStockVouchers->contains($obj)) {
                                $this->collStockVouchers->append($obj);
                            }
                        }

                        $this->collStockVouchersPartial = true;
                    }

                    return $collStockVouchers;
                }

                if ($partial && $this->collStockVouchers) {
                    foreach ($this->collStockVouchers as $obj) {
                        if ($obj->isNew()) {
                            $collStockVouchers[] = $obj;
                        }
                    }
                }

                $this->collStockVouchers = $collStockVouchers;
                $this->collStockVouchersPartial = false;
            }
        }

        return $this->collStockVouchers;
    }

    /**
     * Sets a collection of ChildStockVoucher objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $stockVouchers A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setStockVouchers(Collection $stockVouchers, ?ConnectionInterface $con = null)
    {
        /** @var ChildStockVoucher[] $stockVouchersToDelete */
        $stockVouchersToDelete = $this->getStockVouchers(new Criteria(), $con)->diff($stockVouchers);


        $this->stockVouchersScheduledForDeletion = $stockVouchersToDelete;

        foreach ($stockVouchersToDelete as $stockVoucherRemoved) {
            $stockVoucherRemoved->setCompany(null);
        }

        $this->collStockVouchers = null;
        foreach ($stockVouchers as $stockVoucher) {
            $this->addStockVoucher($stockVoucher);
        }

        $this->collStockVouchers = $stockVouchers;
        $this->collStockVouchersPartial = false;

        return $this;
    }

    /**
     * Returns the number of related StockVoucher objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related StockVoucher objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countStockVouchers(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collStockVouchersPartial && !$this->isNew();
        if (null === $this->collStockVouchers || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collStockVouchers) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getStockVouchers());
            }

            $query = ChildStockVoucherQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collStockVouchers);
    }

    /**
     * Method called to associate a ChildStockVoucher object to this object
     * through the ChildStockVoucher foreign key attribute.
     *
     * @param ChildStockVoucher $l ChildStockVoucher
     * @return $this The current object (for fluent API support)
     */
    public function addStockVoucher(ChildStockVoucher $l)
    {
        if ($this->collStockVouchers === null) {
            $this->initStockVouchers();
            $this->collStockVouchersPartial = true;
        }

        if (!$this->collStockVouchers->contains($l)) {
            $this->doAddStockVoucher($l);

            if ($this->stockVouchersScheduledForDeletion and $this->stockVouchersScheduledForDeletion->contains($l)) {
                $this->stockVouchersScheduledForDeletion->remove($this->stockVouchersScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildStockVoucher $stockVoucher The ChildStockVoucher object to add.
     */
    protected function doAddStockVoucher(ChildStockVoucher $stockVoucher): void
    {
        $this->collStockVouchers[]= $stockVoucher;
        $stockVoucher->setCompany($this);
    }

    /**
     * @param ChildStockVoucher $stockVoucher The ChildStockVoucher object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeStockVoucher(ChildStockVoucher $stockVoucher)
    {
        if ($this->getStockVouchers()->contains($stockVoucher)) {
            $pos = $this->collStockVouchers->search($stockVoucher);
            $this->collStockVouchers->remove($pos);
            if (null === $this->stockVouchersScheduledForDeletion) {
                $this->stockVouchersScheduledForDeletion = clone $this->collStockVouchers;
                $this->stockVouchersScheduledForDeletion->clear();
            }
            $this->stockVouchersScheduledForDeletion[]= clone $stockVoucher;
            $stockVoucher->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related StockVouchers from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStockVoucher[] List of ChildStockVoucher objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStockVoucher}> List of ChildStockVoucher objects
     */
    public function getStockVouchersJoinUsers(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStockVoucherQuery::create(null, $criteria);
        $query->joinWith('Users', $joinBehavior);

        return $this->getStockVouchers($query, $con);
    }

    /**
     * Clears out the collSurveys collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addSurveys()
     */
    public function clearSurveys()
    {
        $this->collSurveys = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collSurveys collection loaded partially.
     *
     * @return void
     */
    public function resetPartialSurveys($v = true): void
    {
        $this->collSurveysPartial = $v;
    }

    /**
     * Initializes the collSurveys collection.
     *
     * By default this just sets the collSurveys collection to an empty array (like clearcollSurveys());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSurveys(bool $overrideExisting = true): void
    {
        if (null !== $this->collSurveys && !$overrideExisting) {
            return;
        }

        $collectionClassName = SurveyTableMap::getTableMap()->getCollectionClassName();

        $this->collSurveys = new $collectionClassName;
        $this->collSurveys->setModel('\entities\Survey');
    }

    /**
     * Gets an array of ChildSurvey objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildSurvey[] List of ChildSurvey objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurvey> List of ChildSurvey objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getSurveys(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collSurveysPartial && !$this->isNew();
        if (null === $this->collSurveys || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collSurveys) {
                    $this->initSurveys();
                } else {
                    $collectionClassName = SurveyTableMap::getTableMap()->getCollectionClassName();

                    $collSurveys = new $collectionClassName;
                    $collSurveys->setModel('\entities\Survey');

                    return $collSurveys;
                }
            } else {
                $collSurveys = ChildSurveyQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collSurveysPartial && count($collSurveys)) {
                        $this->initSurveys(false);

                        foreach ($collSurveys as $obj) {
                            if (false == $this->collSurveys->contains($obj)) {
                                $this->collSurveys->append($obj);
                            }
                        }

                        $this->collSurveysPartial = true;
                    }

                    return $collSurveys;
                }

                if ($partial && $this->collSurveys) {
                    foreach ($this->collSurveys as $obj) {
                        if ($obj->isNew()) {
                            $collSurveys[] = $obj;
                        }
                    }
                }

                $this->collSurveys = $collSurveys;
                $this->collSurveysPartial = false;
            }
        }

        return $this->collSurveys;
    }

    /**
     * Sets a collection of ChildSurvey objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $surveys A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setSurveys(Collection $surveys, ?ConnectionInterface $con = null)
    {
        /** @var ChildSurvey[] $surveysToDelete */
        $surveysToDelete = $this->getSurveys(new Criteria(), $con)->diff($surveys);


        $this->surveysScheduledForDeletion = $surveysToDelete;

        foreach ($surveysToDelete as $surveyRemoved) {
            $surveyRemoved->setCompany(null);
        }

        $this->collSurveys = null;
        foreach ($surveys as $survey) {
            $this->addSurvey($survey);
        }

        $this->collSurveys = $surveys;
        $this->collSurveysPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Survey objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Survey objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countSurveys(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collSurveysPartial && !$this->isNew();
        if (null === $this->collSurveys || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSurveys) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getSurveys());
            }

            $query = ChildSurveyQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collSurveys);
    }

    /**
     * Method called to associate a ChildSurvey object to this object
     * through the ChildSurvey foreign key attribute.
     *
     * @param ChildSurvey $l ChildSurvey
     * @return $this The current object (for fluent API support)
     */
    public function addSurvey(ChildSurvey $l)
    {
        if ($this->collSurveys === null) {
            $this->initSurveys();
            $this->collSurveysPartial = true;
        }

        if (!$this->collSurveys->contains($l)) {
            $this->doAddSurvey($l);

            if ($this->surveysScheduledForDeletion and $this->surveysScheduledForDeletion->contains($l)) {
                $this->surveysScheduledForDeletion->remove($this->surveysScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildSurvey $survey The ChildSurvey object to add.
     */
    protected function doAddSurvey(ChildSurvey $survey): void
    {
        $this->collSurveys[]= $survey;
        $survey->setCompany($this);
    }

    /**
     * @param ChildSurvey $survey The ChildSurvey object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeSurvey(ChildSurvey $survey)
    {
        if ($this->getSurveys()->contains($survey)) {
            $pos = $this->collSurveys->search($survey);
            $this->collSurveys->remove($pos);
            if (null === $this->surveysScheduledForDeletion) {
                $this->surveysScheduledForDeletion = clone $this->collSurveys;
                $this->surveysScheduledForDeletion->clear();
            }
            $this->surveysScheduledForDeletion[]= $survey;
            $survey->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Surveys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSurvey[] List of ChildSurvey objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurvey}> List of ChildSurvey objects
     */
    public function getSurveysJoinSurveyCategory(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSurveyQuery::create(null, $criteria);
        $query->joinWith('SurveyCategory', $joinBehavior);

        return $this->getSurveys($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Surveys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSurvey[] List of ChildSurvey objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurvey}> List of ChildSurvey objects
     */
    public function getSurveysJoinOutletType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSurveyQuery::create(null, $criteria);
        $query->joinWith('OutletType', $joinBehavior);

        return $this->getSurveys($query, $con);
    }

    /**
     * Clears out the collSurveyCategories collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addSurveyCategories()
     */
    public function clearSurveyCategories()
    {
        $this->collSurveyCategories = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collSurveyCategories collection loaded partially.
     *
     * @return void
     */
    public function resetPartialSurveyCategories($v = true): void
    {
        $this->collSurveyCategoriesPartial = $v;
    }

    /**
     * Initializes the collSurveyCategories collection.
     *
     * By default this just sets the collSurveyCategories collection to an empty array (like clearcollSurveyCategories());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSurveyCategories(bool $overrideExisting = true): void
    {
        if (null !== $this->collSurveyCategories && !$overrideExisting) {
            return;
        }

        $collectionClassName = SurveyCategoryTableMap::getTableMap()->getCollectionClassName();

        $this->collSurveyCategories = new $collectionClassName;
        $this->collSurveyCategories->setModel('\entities\SurveyCategory');
    }

    /**
     * Gets an array of ChildSurveyCategory objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildSurveyCategory[] List of ChildSurveyCategory objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurveyCategory> List of ChildSurveyCategory objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getSurveyCategories(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collSurveyCategoriesPartial && !$this->isNew();
        if (null === $this->collSurveyCategories || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collSurveyCategories) {
                    $this->initSurveyCategories();
                } else {
                    $collectionClassName = SurveyCategoryTableMap::getTableMap()->getCollectionClassName();

                    $collSurveyCategories = new $collectionClassName;
                    $collSurveyCategories->setModel('\entities\SurveyCategory');

                    return $collSurveyCategories;
                }
            } else {
                $collSurveyCategories = ChildSurveyCategoryQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collSurveyCategoriesPartial && count($collSurveyCategories)) {
                        $this->initSurveyCategories(false);

                        foreach ($collSurveyCategories as $obj) {
                            if (false == $this->collSurveyCategories->contains($obj)) {
                                $this->collSurveyCategories->append($obj);
                            }
                        }

                        $this->collSurveyCategoriesPartial = true;
                    }

                    return $collSurveyCategories;
                }

                if ($partial && $this->collSurveyCategories) {
                    foreach ($this->collSurveyCategories as $obj) {
                        if ($obj->isNew()) {
                            $collSurveyCategories[] = $obj;
                        }
                    }
                }

                $this->collSurveyCategories = $collSurveyCategories;
                $this->collSurveyCategoriesPartial = false;
            }
        }

        return $this->collSurveyCategories;
    }

    /**
     * Sets a collection of ChildSurveyCategory objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $surveyCategories A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setSurveyCategories(Collection $surveyCategories, ?ConnectionInterface $con = null)
    {
        /** @var ChildSurveyCategory[] $surveyCategoriesToDelete */
        $surveyCategoriesToDelete = $this->getSurveyCategories(new Criteria(), $con)->diff($surveyCategories);


        $this->surveyCategoriesScheduledForDeletion = $surveyCategoriesToDelete;

        foreach ($surveyCategoriesToDelete as $surveyCategoryRemoved) {
            $surveyCategoryRemoved->setCompany(null);
        }

        $this->collSurveyCategories = null;
        foreach ($surveyCategories as $surveyCategory) {
            $this->addSurveyCategory($surveyCategory);
        }

        $this->collSurveyCategories = $surveyCategories;
        $this->collSurveyCategoriesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related SurveyCategory objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related SurveyCategory objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countSurveyCategories(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collSurveyCategoriesPartial && !$this->isNew();
        if (null === $this->collSurveyCategories || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSurveyCategories) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getSurveyCategories());
            }

            $query = ChildSurveyCategoryQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collSurveyCategories);
    }

    /**
     * Method called to associate a ChildSurveyCategory object to this object
     * through the ChildSurveyCategory foreign key attribute.
     *
     * @param ChildSurveyCategory $l ChildSurveyCategory
     * @return $this The current object (for fluent API support)
     */
    public function addSurveyCategory(ChildSurveyCategory $l)
    {
        if ($this->collSurveyCategories === null) {
            $this->initSurveyCategories();
            $this->collSurveyCategoriesPartial = true;
        }

        if (!$this->collSurveyCategories->contains($l)) {
            $this->doAddSurveyCategory($l);

            if ($this->surveyCategoriesScheduledForDeletion and $this->surveyCategoriesScheduledForDeletion->contains($l)) {
                $this->surveyCategoriesScheduledForDeletion->remove($this->surveyCategoriesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildSurveyCategory $surveyCategory The ChildSurveyCategory object to add.
     */
    protected function doAddSurveyCategory(ChildSurveyCategory $surveyCategory): void
    {
        $this->collSurveyCategories[]= $surveyCategory;
        $surveyCategory->setCompany($this);
    }

    /**
     * @param ChildSurveyCategory $surveyCategory The ChildSurveyCategory object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeSurveyCategory(ChildSurveyCategory $surveyCategory)
    {
        if ($this->getSurveyCategories()->contains($surveyCategory)) {
            $pos = $this->collSurveyCategories->search($surveyCategory);
            $this->collSurveyCategories->remove($pos);
            if (null === $this->surveyCategoriesScheduledForDeletion) {
                $this->surveyCategoriesScheduledForDeletion = clone $this->collSurveyCategories;
                $this->surveyCategoriesScheduledForDeletion->clear();
            }
            $this->surveyCategoriesScheduledForDeletion[]= $surveyCategory;
            $surveyCategory->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collSurveyQuestions collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addSurveyQuestions()
     */
    public function clearSurveyQuestions()
    {
        $this->collSurveyQuestions = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collSurveyQuestions collection loaded partially.
     *
     * @return void
     */
    public function resetPartialSurveyQuestions($v = true): void
    {
        $this->collSurveyQuestionsPartial = $v;
    }

    /**
     * Initializes the collSurveyQuestions collection.
     *
     * By default this just sets the collSurveyQuestions collection to an empty array (like clearcollSurveyQuestions());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSurveyQuestions(bool $overrideExisting = true): void
    {
        if (null !== $this->collSurveyQuestions && !$overrideExisting) {
            return;
        }

        $collectionClassName = SurveyQuestionTableMap::getTableMap()->getCollectionClassName();

        $this->collSurveyQuestions = new $collectionClassName;
        $this->collSurveyQuestions->setModel('\entities\SurveyQuestion');
    }

    /**
     * Gets an array of ChildSurveyQuestion objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildSurveyQuestion[] List of ChildSurveyQuestion objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurveyQuestion> List of ChildSurveyQuestion objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getSurveyQuestions(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collSurveyQuestionsPartial && !$this->isNew();
        if (null === $this->collSurveyQuestions || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collSurveyQuestions) {
                    $this->initSurveyQuestions();
                } else {
                    $collectionClassName = SurveyQuestionTableMap::getTableMap()->getCollectionClassName();

                    $collSurveyQuestions = new $collectionClassName;
                    $collSurveyQuestions->setModel('\entities\SurveyQuestion');

                    return $collSurveyQuestions;
                }
            } else {
                $collSurveyQuestions = ChildSurveyQuestionQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collSurveyQuestionsPartial && count($collSurveyQuestions)) {
                        $this->initSurveyQuestions(false);

                        foreach ($collSurveyQuestions as $obj) {
                            if (false == $this->collSurveyQuestions->contains($obj)) {
                                $this->collSurveyQuestions->append($obj);
                            }
                        }

                        $this->collSurveyQuestionsPartial = true;
                    }

                    return $collSurveyQuestions;
                }

                if ($partial && $this->collSurveyQuestions) {
                    foreach ($this->collSurveyQuestions as $obj) {
                        if ($obj->isNew()) {
                            $collSurveyQuestions[] = $obj;
                        }
                    }
                }

                $this->collSurveyQuestions = $collSurveyQuestions;
                $this->collSurveyQuestionsPartial = false;
            }
        }

        return $this->collSurveyQuestions;
    }

    /**
     * Sets a collection of ChildSurveyQuestion objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $surveyQuestions A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setSurveyQuestions(Collection $surveyQuestions, ?ConnectionInterface $con = null)
    {
        /** @var ChildSurveyQuestion[] $surveyQuestionsToDelete */
        $surveyQuestionsToDelete = $this->getSurveyQuestions(new Criteria(), $con)->diff($surveyQuestions);


        $this->surveyQuestionsScheduledForDeletion = $surveyQuestionsToDelete;

        foreach ($surveyQuestionsToDelete as $surveyQuestionRemoved) {
            $surveyQuestionRemoved->setCompany(null);
        }

        $this->collSurveyQuestions = null;
        foreach ($surveyQuestions as $surveyQuestion) {
            $this->addSurveyQuestion($surveyQuestion);
        }

        $this->collSurveyQuestions = $surveyQuestions;
        $this->collSurveyQuestionsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related SurveyQuestion objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related SurveyQuestion objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countSurveyQuestions(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collSurveyQuestionsPartial && !$this->isNew();
        if (null === $this->collSurveyQuestions || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSurveyQuestions) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getSurveyQuestions());
            }

            $query = ChildSurveyQuestionQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collSurveyQuestions);
    }

    /**
     * Method called to associate a ChildSurveyQuestion object to this object
     * through the ChildSurveyQuestion foreign key attribute.
     *
     * @param ChildSurveyQuestion $l ChildSurveyQuestion
     * @return $this The current object (for fluent API support)
     */
    public function addSurveyQuestion(ChildSurveyQuestion $l)
    {
        if ($this->collSurveyQuestions === null) {
            $this->initSurveyQuestions();
            $this->collSurveyQuestionsPartial = true;
        }

        if (!$this->collSurveyQuestions->contains($l)) {
            $this->doAddSurveyQuestion($l);

            if ($this->surveyQuestionsScheduledForDeletion and $this->surveyQuestionsScheduledForDeletion->contains($l)) {
                $this->surveyQuestionsScheduledForDeletion->remove($this->surveyQuestionsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildSurveyQuestion $surveyQuestion The ChildSurveyQuestion object to add.
     */
    protected function doAddSurveyQuestion(ChildSurveyQuestion $surveyQuestion): void
    {
        $this->collSurveyQuestions[]= $surveyQuestion;
        $surveyQuestion->setCompany($this);
    }

    /**
     * @param ChildSurveyQuestion $surveyQuestion The ChildSurveyQuestion object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeSurveyQuestion(ChildSurveyQuestion $surveyQuestion)
    {
        if ($this->getSurveyQuestions()->contains($surveyQuestion)) {
            $pos = $this->collSurveyQuestions->search($surveyQuestion);
            $this->collSurveyQuestions->remove($pos);
            if (null === $this->surveyQuestionsScheduledForDeletion) {
                $this->surveyQuestionsScheduledForDeletion = clone $this->collSurveyQuestions;
                $this->surveyQuestionsScheduledForDeletion->clear();
            }
            $this->surveyQuestionsScheduledForDeletion[]= $surveyQuestion;
            $surveyQuestion->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SurveyQuestions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSurveyQuestion[] List of ChildSurveyQuestion objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurveyQuestion}> List of ChildSurveyQuestion objects
     */
    public function getSurveyQuestionsJoinSurvey(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSurveyQuestionQuery::create(null, $criteria);
        $query->joinWith('Survey', $joinBehavior);

        return $this->getSurveyQuestions($query, $con);
    }

    /**
     * Clears out the collSurveySubmiteds collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addSurveySubmiteds()
     */
    public function clearSurveySubmiteds()
    {
        $this->collSurveySubmiteds = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collSurveySubmiteds collection loaded partially.
     *
     * @return void
     */
    public function resetPartialSurveySubmiteds($v = true): void
    {
        $this->collSurveySubmitedsPartial = $v;
    }

    /**
     * Initializes the collSurveySubmiteds collection.
     *
     * By default this just sets the collSurveySubmiteds collection to an empty array (like clearcollSurveySubmiteds());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initSurveySubmiteds(bool $overrideExisting = true): void
    {
        if (null !== $this->collSurveySubmiteds && !$overrideExisting) {
            return;
        }

        $collectionClassName = SurveySubmitedTableMap::getTableMap()->getCollectionClassName();

        $this->collSurveySubmiteds = new $collectionClassName;
        $this->collSurveySubmiteds->setModel('\entities\SurveySubmited');
    }

    /**
     * Gets an array of ChildSurveySubmited objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildSurveySubmited[] List of ChildSurveySubmited objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurveySubmited> List of ChildSurveySubmited objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getSurveySubmiteds(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collSurveySubmitedsPartial && !$this->isNew();
        if (null === $this->collSurveySubmiteds || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collSurveySubmiteds) {
                    $this->initSurveySubmiteds();
                } else {
                    $collectionClassName = SurveySubmitedTableMap::getTableMap()->getCollectionClassName();

                    $collSurveySubmiteds = new $collectionClassName;
                    $collSurveySubmiteds->setModel('\entities\SurveySubmited');

                    return $collSurveySubmiteds;
                }
            } else {
                $collSurveySubmiteds = ChildSurveySubmitedQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collSurveySubmitedsPartial && count($collSurveySubmiteds)) {
                        $this->initSurveySubmiteds(false);

                        foreach ($collSurveySubmiteds as $obj) {
                            if (false == $this->collSurveySubmiteds->contains($obj)) {
                                $this->collSurveySubmiteds->append($obj);
                            }
                        }

                        $this->collSurveySubmitedsPartial = true;
                    }

                    return $collSurveySubmiteds;
                }

                if ($partial && $this->collSurveySubmiteds) {
                    foreach ($this->collSurveySubmiteds as $obj) {
                        if ($obj->isNew()) {
                            $collSurveySubmiteds[] = $obj;
                        }
                    }
                }

                $this->collSurveySubmiteds = $collSurveySubmiteds;
                $this->collSurveySubmitedsPartial = false;
            }
        }

        return $this->collSurveySubmiteds;
    }

    /**
     * Sets a collection of ChildSurveySubmited objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $surveySubmiteds A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setSurveySubmiteds(Collection $surveySubmiteds, ?ConnectionInterface $con = null)
    {
        /** @var ChildSurveySubmited[] $surveySubmitedsToDelete */
        $surveySubmitedsToDelete = $this->getSurveySubmiteds(new Criteria(), $con)->diff($surveySubmiteds);


        $this->surveySubmitedsScheduledForDeletion = $surveySubmitedsToDelete;

        foreach ($surveySubmitedsToDelete as $surveySubmitedRemoved) {
            $surveySubmitedRemoved->setCompany(null);
        }

        $this->collSurveySubmiteds = null;
        foreach ($surveySubmiteds as $surveySubmited) {
            $this->addSurveySubmited($surveySubmited);
        }

        $this->collSurveySubmiteds = $surveySubmiteds;
        $this->collSurveySubmitedsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related SurveySubmited objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related SurveySubmited objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countSurveySubmiteds(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collSurveySubmitedsPartial && !$this->isNew();
        if (null === $this->collSurveySubmiteds || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collSurveySubmiteds) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getSurveySubmiteds());
            }

            $query = ChildSurveySubmitedQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collSurveySubmiteds);
    }

    /**
     * Method called to associate a ChildSurveySubmited object to this object
     * through the ChildSurveySubmited foreign key attribute.
     *
     * @param ChildSurveySubmited $l ChildSurveySubmited
     * @return $this The current object (for fluent API support)
     */
    public function addSurveySubmited(ChildSurveySubmited $l)
    {
        if ($this->collSurveySubmiteds === null) {
            $this->initSurveySubmiteds();
            $this->collSurveySubmitedsPartial = true;
        }

        if (!$this->collSurveySubmiteds->contains($l)) {
            $this->doAddSurveySubmited($l);

            if ($this->surveySubmitedsScheduledForDeletion and $this->surveySubmitedsScheduledForDeletion->contains($l)) {
                $this->surveySubmitedsScheduledForDeletion->remove($this->surveySubmitedsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildSurveySubmited $surveySubmited The ChildSurveySubmited object to add.
     */
    protected function doAddSurveySubmited(ChildSurveySubmited $surveySubmited): void
    {
        $this->collSurveySubmiteds[]= $surveySubmited;
        $surveySubmited->setCompany($this);
    }

    /**
     * @param ChildSurveySubmited $surveySubmited The ChildSurveySubmited object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeSurveySubmited(ChildSurveySubmited $surveySubmited)
    {
        if ($this->getSurveySubmiteds()->contains($surveySubmited)) {
            $pos = $this->collSurveySubmiteds->search($surveySubmited);
            $this->collSurveySubmiteds->remove($pos);
            if (null === $this->surveySubmitedsScheduledForDeletion) {
                $this->surveySubmitedsScheduledForDeletion = clone $this->collSurveySubmiteds;
                $this->surveySubmitedsScheduledForDeletion->clear();
            }
            $this->surveySubmitedsScheduledForDeletion[]= $surveySubmited;
            $surveySubmited->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SurveySubmiteds from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSurveySubmited[] List of ChildSurveySubmited objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurveySubmited}> List of ChildSurveySubmited objects
     */
    public function getSurveySubmitedsJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSurveySubmitedQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getSurveySubmiteds($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SurveySubmiteds from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSurveySubmited[] List of ChildSurveySubmited objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurveySubmited}> List of ChildSurveySubmited objects
     */
    public function getSurveySubmitedsJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSurveySubmitedQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getSurveySubmiteds($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SurveySubmiteds from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSurveySubmited[] List of ChildSurveySubmited objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurveySubmited}> List of ChildSurveySubmited objects
     */
    public function getSurveySubmitedsJoinDailycalls(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSurveySubmitedQuery::create(null, $criteria);
        $query->joinWith('Dailycalls', $joinBehavior);

        return $this->getSurveySubmiteds($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related SurveySubmiteds from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildSurveySubmited[] List of ChildSurveySubmited objects
     * @phpstan-return ObjectCollection&\Traversable<ChildSurveySubmited}> List of ChildSurveySubmited objects
     */
    public function getSurveySubmitedsJoinBrandCampiagnVisitPlan(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildSurveySubmitedQuery::create(null, $criteria);
        $query->joinWith('BrandCampiagnVisitPlan', $joinBehavior);

        return $this->getSurveySubmiteds($query, $con);
    }

    /**
     * Clears out the collTaConfigurations collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTaConfigurations()
     */
    public function clearTaConfigurations()
    {
        $this->collTaConfigurations = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTaConfigurations collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTaConfigurations($v = true): void
    {
        $this->collTaConfigurationsPartial = $v;
    }

    /**
     * Initializes the collTaConfigurations collection.
     *
     * By default this just sets the collTaConfigurations collection to an empty array (like clearcollTaConfigurations());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTaConfigurations(bool $overrideExisting = true): void
    {
        if (null !== $this->collTaConfigurations && !$overrideExisting) {
            return;
        }

        $collectionClassName = TaConfigurationTableMap::getTableMap()->getCollectionClassName();

        $this->collTaConfigurations = new $collectionClassName;
        $this->collTaConfigurations->setModel('\entities\TaConfiguration');
    }

    /**
     * Gets an array of ChildTaConfiguration objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTaConfiguration[] List of ChildTaConfiguration objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTaConfiguration> List of ChildTaConfiguration objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTaConfigurations(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTaConfigurationsPartial && !$this->isNew();
        if (null === $this->collTaConfigurations || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTaConfigurations) {
                    $this->initTaConfigurations();
                } else {
                    $collectionClassName = TaConfigurationTableMap::getTableMap()->getCollectionClassName();

                    $collTaConfigurations = new $collectionClassName;
                    $collTaConfigurations->setModel('\entities\TaConfiguration');

                    return $collTaConfigurations;
                }
            } else {
                $collTaConfigurations = ChildTaConfigurationQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTaConfigurationsPartial && count($collTaConfigurations)) {
                        $this->initTaConfigurations(false);

                        foreach ($collTaConfigurations as $obj) {
                            if (false == $this->collTaConfigurations->contains($obj)) {
                                $this->collTaConfigurations->append($obj);
                            }
                        }

                        $this->collTaConfigurationsPartial = true;
                    }

                    return $collTaConfigurations;
                }

                if ($partial && $this->collTaConfigurations) {
                    foreach ($this->collTaConfigurations as $obj) {
                        if ($obj->isNew()) {
                            $collTaConfigurations[] = $obj;
                        }
                    }
                }

                $this->collTaConfigurations = $collTaConfigurations;
                $this->collTaConfigurationsPartial = false;
            }
        }

        return $this->collTaConfigurations;
    }

    /**
     * Sets a collection of ChildTaConfiguration objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $taConfigurations A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTaConfigurations(Collection $taConfigurations, ?ConnectionInterface $con = null)
    {
        /** @var ChildTaConfiguration[] $taConfigurationsToDelete */
        $taConfigurationsToDelete = $this->getTaConfigurations(new Criteria(), $con)->diff($taConfigurations);


        $this->taConfigurationsScheduledForDeletion = $taConfigurationsToDelete;

        foreach ($taConfigurationsToDelete as $taConfigurationRemoved) {
            $taConfigurationRemoved->setCompany(null);
        }

        $this->collTaConfigurations = null;
        foreach ($taConfigurations as $taConfiguration) {
            $this->addTaConfiguration($taConfiguration);
        }

        $this->collTaConfigurations = $taConfigurations;
        $this->collTaConfigurationsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related TaConfiguration objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related TaConfiguration objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTaConfigurations(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTaConfigurationsPartial && !$this->isNew();
        if (null === $this->collTaConfigurations || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTaConfigurations) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTaConfigurations());
            }

            $query = ChildTaConfigurationQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTaConfigurations);
    }

    /**
     * Method called to associate a ChildTaConfiguration object to this object
     * through the ChildTaConfiguration foreign key attribute.
     *
     * @param ChildTaConfiguration $l ChildTaConfiguration
     * @return $this The current object (for fluent API support)
     */
    public function addTaConfiguration(ChildTaConfiguration $l)
    {
        if ($this->collTaConfigurations === null) {
            $this->initTaConfigurations();
            $this->collTaConfigurationsPartial = true;
        }

        if (!$this->collTaConfigurations->contains($l)) {
            $this->doAddTaConfiguration($l);

            if ($this->taConfigurationsScheduledForDeletion and $this->taConfigurationsScheduledForDeletion->contains($l)) {
                $this->taConfigurationsScheduledForDeletion->remove($this->taConfigurationsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTaConfiguration $taConfiguration The ChildTaConfiguration object to add.
     */
    protected function doAddTaConfiguration(ChildTaConfiguration $taConfiguration): void
    {
        $this->collTaConfigurations[]= $taConfiguration;
        $taConfiguration->setCompany($this);
    }

    /**
     * @param ChildTaConfiguration $taConfiguration The ChildTaConfiguration object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTaConfiguration(ChildTaConfiguration $taConfiguration)
    {
        if ($this->getTaConfigurations()->contains($taConfiguration)) {
            $pos = $this->collTaConfigurations->search($taConfiguration);
            $this->collTaConfigurations->remove($pos);
            if (null === $this->taConfigurationsScheduledForDeletion) {
                $this->taConfigurationsScheduledForDeletion = clone $this->collTaConfigurations;
                $this->taConfigurationsScheduledForDeletion->clear();
            }
            $this->taConfigurationsScheduledForDeletion[]= $taConfiguration;
            $taConfiguration->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collTagss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTagss()
     */
    public function clearTagss()
    {
        $this->collTagss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTagss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTagss($v = true): void
    {
        $this->collTagssPartial = $v;
    }

    /**
     * Initializes the collTagss collection.
     *
     * By default this just sets the collTagss collection to an empty array (like clearcollTagss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTagss(bool $overrideExisting = true): void
    {
        if (null !== $this->collTagss && !$overrideExisting) {
            return;
        }

        $collectionClassName = TagsTableMap::getTableMap()->getCollectionClassName();

        $this->collTagss = new $collectionClassName;
        $this->collTagss->setModel('\entities\Tags');
    }

    /**
     * Gets an array of ChildTags objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTags[] List of ChildTags objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTags> List of ChildTags objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTagss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTagssPartial && !$this->isNew();
        if (null === $this->collTagss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTagss) {
                    $this->initTagss();
                } else {
                    $collectionClassName = TagsTableMap::getTableMap()->getCollectionClassName();

                    $collTagss = new $collectionClassName;
                    $collTagss->setModel('\entities\Tags');

                    return $collTagss;
                }
            } else {
                $collTagss = ChildTagsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTagssPartial && count($collTagss)) {
                        $this->initTagss(false);

                        foreach ($collTagss as $obj) {
                            if (false == $this->collTagss->contains($obj)) {
                                $this->collTagss->append($obj);
                            }
                        }

                        $this->collTagssPartial = true;
                    }

                    return $collTagss;
                }

                if ($partial && $this->collTagss) {
                    foreach ($this->collTagss as $obj) {
                        if ($obj->isNew()) {
                            $collTagss[] = $obj;
                        }
                    }
                }

                $this->collTagss = $collTagss;
                $this->collTagssPartial = false;
            }
        }

        return $this->collTagss;
    }

    /**
     * Sets a collection of ChildTags objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $tagss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTagss(Collection $tagss, ?ConnectionInterface $con = null)
    {
        /** @var ChildTags[] $tagssToDelete */
        $tagssToDelete = $this->getTagss(new Criteria(), $con)->diff($tagss);


        $this->tagssScheduledForDeletion = $tagssToDelete;

        foreach ($tagssToDelete as $tagsRemoved) {
            $tagsRemoved->setCompany(null);
        }

        $this->collTagss = null;
        foreach ($tagss as $tags) {
            $this->addTags($tags);
        }

        $this->collTagss = $tagss;
        $this->collTagssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Tags objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Tags objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTagss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTagssPartial && !$this->isNew();
        if (null === $this->collTagss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTagss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTagss());
            }

            $query = ChildTagsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTagss);
    }

    /**
     * Method called to associate a ChildTags object to this object
     * through the ChildTags foreign key attribute.
     *
     * @param ChildTags $l ChildTags
     * @return $this The current object (for fluent API support)
     */
    public function addTags(ChildTags $l)
    {
        if ($this->collTagss === null) {
            $this->initTagss();
            $this->collTagssPartial = true;
        }

        if (!$this->collTagss->contains($l)) {
            $this->doAddTags($l);

            if ($this->tagssScheduledForDeletion and $this->tagssScheduledForDeletion->contains($l)) {
                $this->tagssScheduledForDeletion->remove($this->tagssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTags $tags The ChildTags object to add.
     */
    protected function doAddTags(ChildTags $tags): void
    {
        $this->collTagss[]= $tags;
        $tags->setCompany($this);
    }

    /**
     * @param ChildTags $tags The ChildTags object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTags(ChildTags $tags)
    {
        if ($this->getTagss()->contains($tags)) {
            $pos = $this->collTagss->search($tags);
            $this->collTagss->remove($pos);
            if (null === $this->tagssScheduledForDeletion) {
                $this->tagssScheduledForDeletion = clone $this->collTagss;
                $this->tagssScheduledForDeletion->clear();
            }
            $this->tagssScheduledForDeletion[]= clone $tags;
            $tags->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collTerritoriess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTerritoriess()
     */
    public function clearTerritoriess()
    {
        $this->collTerritoriess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTerritoriess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTerritoriess($v = true): void
    {
        $this->collTerritoriessPartial = $v;
    }

    /**
     * Initializes the collTerritoriess collection.
     *
     * By default this just sets the collTerritoriess collection to an empty array (like clearcollTerritoriess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTerritoriess(bool $overrideExisting = true): void
    {
        if (null !== $this->collTerritoriess && !$overrideExisting) {
            return;
        }

        $collectionClassName = TerritoriesTableMap::getTableMap()->getCollectionClassName();

        $this->collTerritoriess = new $collectionClassName;
        $this->collTerritoriess->setModel('\entities\Territories');
    }

    /**
     * Gets an array of ChildTerritories objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTerritories[] List of ChildTerritories objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTerritories> List of ChildTerritories objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTerritoriess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTerritoriessPartial && !$this->isNew();
        if (null === $this->collTerritoriess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTerritoriess) {
                    $this->initTerritoriess();
                } else {
                    $collectionClassName = TerritoriesTableMap::getTableMap()->getCollectionClassName();

                    $collTerritoriess = new $collectionClassName;
                    $collTerritoriess->setModel('\entities\Territories');

                    return $collTerritoriess;
                }
            } else {
                $collTerritoriess = ChildTerritoriesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTerritoriessPartial && count($collTerritoriess)) {
                        $this->initTerritoriess(false);

                        foreach ($collTerritoriess as $obj) {
                            if (false == $this->collTerritoriess->contains($obj)) {
                                $this->collTerritoriess->append($obj);
                            }
                        }

                        $this->collTerritoriessPartial = true;
                    }

                    return $collTerritoriess;
                }

                if ($partial && $this->collTerritoriess) {
                    foreach ($this->collTerritoriess as $obj) {
                        if ($obj->isNew()) {
                            $collTerritoriess[] = $obj;
                        }
                    }
                }

                $this->collTerritoriess = $collTerritoriess;
                $this->collTerritoriessPartial = false;
            }
        }

        return $this->collTerritoriess;
    }

    /**
     * Sets a collection of ChildTerritories objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $territoriess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTerritoriess(Collection $territoriess, ?ConnectionInterface $con = null)
    {
        /** @var ChildTerritories[] $territoriessToDelete */
        $territoriessToDelete = $this->getTerritoriess(new Criteria(), $con)->diff($territoriess);


        $this->territoriessScheduledForDeletion = $territoriessToDelete;

        foreach ($territoriessToDelete as $territoriesRemoved) {
            $territoriesRemoved->setCompany(null);
        }

        $this->collTerritoriess = null;
        foreach ($territoriess as $territories) {
            $this->addTerritories($territories);
        }

        $this->collTerritoriess = $territoriess;
        $this->collTerritoriessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Territories objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Territories objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTerritoriess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTerritoriessPartial && !$this->isNew();
        if (null === $this->collTerritoriess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTerritoriess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTerritoriess());
            }

            $query = ChildTerritoriesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTerritoriess);
    }

    /**
     * Method called to associate a ChildTerritories object to this object
     * through the ChildTerritories foreign key attribute.
     *
     * @param ChildTerritories $l ChildTerritories
     * @return $this The current object (for fluent API support)
     */
    public function addTerritories(ChildTerritories $l)
    {
        if ($this->collTerritoriess === null) {
            $this->initTerritoriess();
            $this->collTerritoriessPartial = true;
        }

        if (!$this->collTerritoriess->contains($l)) {
            $this->doAddTerritories($l);

            if ($this->territoriessScheduledForDeletion and $this->territoriessScheduledForDeletion->contains($l)) {
                $this->territoriessScheduledForDeletion->remove($this->territoriessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTerritories $territories The ChildTerritories object to add.
     */
    protected function doAddTerritories(ChildTerritories $territories): void
    {
        $this->collTerritoriess[]= $territories;
        $territories->setCompany($this);
    }

    /**
     * @param ChildTerritories $territories The ChildTerritories object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTerritories(ChildTerritories $territories)
    {
        if ($this->getTerritoriess()->contains($territories)) {
            $pos = $this->collTerritoriess->search($territories);
            $this->collTerritoriess->remove($pos);
            if (null === $this->territoriessScheduledForDeletion) {
                $this->territoriessScheduledForDeletion = clone $this->collTerritoriess;
                $this->territoriessScheduledForDeletion->clear();
            }
            $this->territoriessScheduledForDeletion[]= clone $territories;
            $territories->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Territoriess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTerritories[] List of ChildTerritories objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTerritories}> List of ChildTerritories objects
     */
    public function getTerritoriessJoinOrgUnit(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTerritoriesQuery::create(null, $criteria);
        $query->joinWith('OrgUnit', $joinBehavior);

        return $this->getTerritoriess($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Territoriess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTerritories[] List of ChildTerritories objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTerritories}> List of ChildTerritories objects
     */
    public function getTerritoriessJoinPositions(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTerritoriesQuery::create(null, $criteria);
        $query->joinWith('Positions', $joinBehavior);

        return $this->getTerritoriess($query, $con);
    }

    /**
     * Clears out the collTerritoryTownss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTerritoryTownss()
     */
    public function clearTerritoryTownss()
    {
        $this->collTerritoryTownss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTerritoryTownss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTerritoryTownss($v = true): void
    {
        $this->collTerritoryTownssPartial = $v;
    }

    /**
     * Initializes the collTerritoryTownss collection.
     *
     * By default this just sets the collTerritoryTownss collection to an empty array (like clearcollTerritoryTownss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTerritoryTownss(bool $overrideExisting = true): void
    {
        if (null !== $this->collTerritoryTownss && !$overrideExisting) {
            return;
        }

        $collectionClassName = TerritoryTownsTableMap::getTableMap()->getCollectionClassName();

        $this->collTerritoryTownss = new $collectionClassName;
        $this->collTerritoryTownss->setModel('\entities\TerritoryTowns');
    }

    /**
     * Gets an array of ChildTerritoryTowns objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTerritoryTowns[] List of ChildTerritoryTowns objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTerritoryTowns> List of ChildTerritoryTowns objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTerritoryTownss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTerritoryTownssPartial && !$this->isNew();
        if (null === $this->collTerritoryTownss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTerritoryTownss) {
                    $this->initTerritoryTownss();
                } else {
                    $collectionClassName = TerritoryTownsTableMap::getTableMap()->getCollectionClassName();

                    $collTerritoryTownss = new $collectionClassName;
                    $collTerritoryTownss->setModel('\entities\TerritoryTowns');

                    return $collTerritoryTownss;
                }
            } else {
                $collTerritoryTownss = ChildTerritoryTownsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTerritoryTownssPartial && count($collTerritoryTownss)) {
                        $this->initTerritoryTownss(false);

                        foreach ($collTerritoryTownss as $obj) {
                            if (false == $this->collTerritoryTownss->contains($obj)) {
                                $this->collTerritoryTownss->append($obj);
                            }
                        }

                        $this->collTerritoryTownssPartial = true;
                    }

                    return $collTerritoryTownss;
                }

                if ($partial && $this->collTerritoryTownss) {
                    foreach ($this->collTerritoryTownss as $obj) {
                        if ($obj->isNew()) {
                            $collTerritoryTownss[] = $obj;
                        }
                    }
                }

                $this->collTerritoryTownss = $collTerritoryTownss;
                $this->collTerritoryTownssPartial = false;
            }
        }

        return $this->collTerritoryTownss;
    }

    /**
     * Sets a collection of ChildTerritoryTowns objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $territoryTownss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTerritoryTownss(Collection $territoryTownss, ?ConnectionInterface $con = null)
    {
        /** @var ChildTerritoryTowns[] $territoryTownssToDelete */
        $territoryTownssToDelete = $this->getTerritoryTownss(new Criteria(), $con)->diff($territoryTownss);


        $this->territoryTownssScheduledForDeletion = $territoryTownssToDelete;

        foreach ($territoryTownssToDelete as $territoryTownsRemoved) {
            $territoryTownsRemoved->setCompany(null);
        }

        $this->collTerritoryTownss = null;
        foreach ($territoryTownss as $territoryTowns) {
            $this->addTerritoryTowns($territoryTowns);
        }

        $this->collTerritoryTownss = $territoryTownss;
        $this->collTerritoryTownssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related TerritoryTowns objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related TerritoryTowns objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTerritoryTownss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTerritoryTownssPartial && !$this->isNew();
        if (null === $this->collTerritoryTownss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTerritoryTownss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTerritoryTownss());
            }

            $query = ChildTerritoryTownsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTerritoryTownss);
    }

    /**
     * Method called to associate a ChildTerritoryTowns object to this object
     * through the ChildTerritoryTowns foreign key attribute.
     *
     * @param ChildTerritoryTowns $l ChildTerritoryTowns
     * @return $this The current object (for fluent API support)
     */
    public function addTerritoryTowns(ChildTerritoryTowns $l)
    {
        if ($this->collTerritoryTownss === null) {
            $this->initTerritoryTownss();
            $this->collTerritoryTownssPartial = true;
        }

        if (!$this->collTerritoryTownss->contains($l)) {
            $this->doAddTerritoryTowns($l);

            if ($this->territoryTownssScheduledForDeletion and $this->territoryTownssScheduledForDeletion->contains($l)) {
                $this->territoryTownssScheduledForDeletion->remove($this->territoryTownssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTerritoryTowns $territoryTowns The ChildTerritoryTowns object to add.
     */
    protected function doAddTerritoryTowns(ChildTerritoryTowns $territoryTowns): void
    {
        $this->collTerritoryTownss[]= $territoryTowns;
        $territoryTowns->setCompany($this);
    }

    /**
     * @param ChildTerritoryTowns $territoryTowns The ChildTerritoryTowns object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTerritoryTowns(ChildTerritoryTowns $territoryTowns)
    {
        if ($this->getTerritoryTownss()->contains($territoryTowns)) {
            $pos = $this->collTerritoryTownss->search($territoryTowns);
            $this->collTerritoryTownss->remove($pos);
            if (null === $this->territoryTownssScheduledForDeletion) {
                $this->territoryTownssScheduledForDeletion = clone $this->collTerritoryTownss;
                $this->territoryTownssScheduledForDeletion->clear();
            }
            $this->territoryTownssScheduledForDeletion[]= clone $territoryTowns;
            $territoryTowns->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related TerritoryTownss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTerritoryTowns[] List of ChildTerritoryTowns objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTerritoryTowns}> List of ChildTerritoryTowns objects
     */
    public function getTerritoryTownssJoinTerritories(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTerritoryTownsQuery::create(null, $criteria);
        $query->joinWith('Territories', $joinBehavior);

        return $this->getTerritoryTownss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related TerritoryTownss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTerritoryTowns[] List of ChildTerritoryTowns objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTerritoryTowns}> List of ChildTerritoryTowns objects
     */
    public function getTerritoryTownssJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTerritoryTownsQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getTerritoryTownss($query, $con);
    }

    /**
     * Clears out the collTicketRepliess collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTicketRepliess()
     */
    public function clearTicketRepliess()
    {
        $this->collTicketRepliess = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTicketRepliess collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTicketRepliess($v = true): void
    {
        $this->collTicketRepliessPartial = $v;
    }

    /**
     * Initializes the collTicketRepliess collection.
     *
     * By default this just sets the collTicketRepliess collection to an empty array (like clearcollTicketRepliess());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTicketRepliess(bool $overrideExisting = true): void
    {
        if (null !== $this->collTicketRepliess && !$overrideExisting) {
            return;
        }

        $collectionClassName = TicketRepliesTableMap::getTableMap()->getCollectionClassName();

        $this->collTicketRepliess = new $collectionClassName;
        $this->collTicketRepliess->setModel('\entities\TicketReplies');
    }

    /**
     * Gets an array of ChildTicketReplies objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTicketReplies[] List of ChildTicketReplies objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTicketReplies> List of ChildTicketReplies objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTicketRepliess(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTicketRepliessPartial && !$this->isNew();
        if (null === $this->collTicketRepliess || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTicketRepliess) {
                    $this->initTicketRepliess();
                } else {
                    $collectionClassName = TicketRepliesTableMap::getTableMap()->getCollectionClassName();

                    $collTicketRepliess = new $collectionClassName;
                    $collTicketRepliess->setModel('\entities\TicketReplies');

                    return $collTicketRepliess;
                }
            } else {
                $collTicketRepliess = ChildTicketRepliesQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTicketRepliessPartial && count($collTicketRepliess)) {
                        $this->initTicketRepliess(false);

                        foreach ($collTicketRepliess as $obj) {
                            if (false == $this->collTicketRepliess->contains($obj)) {
                                $this->collTicketRepliess->append($obj);
                            }
                        }

                        $this->collTicketRepliessPartial = true;
                    }

                    return $collTicketRepliess;
                }

                if ($partial && $this->collTicketRepliess) {
                    foreach ($this->collTicketRepliess as $obj) {
                        if ($obj->isNew()) {
                            $collTicketRepliess[] = $obj;
                        }
                    }
                }

                $this->collTicketRepliess = $collTicketRepliess;
                $this->collTicketRepliessPartial = false;
            }
        }

        return $this->collTicketRepliess;
    }

    /**
     * Sets a collection of ChildTicketReplies objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $ticketRepliess A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTicketRepliess(Collection $ticketRepliess, ?ConnectionInterface $con = null)
    {
        /** @var ChildTicketReplies[] $ticketRepliessToDelete */
        $ticketRepliessToDelete = $this->getTicketRepliess(new Criteria(), $con)->diff($ticketRepliess);


        $this->ticketRepliessScheduledForDeletion = $ticketRepliessToDelete;

        foreach ($ticketRepliessToDelete as $ticketRepliesRemoved) {
            $ticketRepliesRemoved->setCompany(null);
        }

        $this->collTicketRepliess = null;
        foreach ($ticketRepliess as $ticketReplies) {
            $this->addTicketReplies($ticketReplies);
        }

        $this->collTicketRepliess = $ticketRepliess;
        $this->collTicketRepliessPartial = false;

        return $this;
    }

    /**
     * Returns the number of related TicketReplies objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related TicketReplies objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTicketRepliess(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTicketRepliessPartial && !$this->isNew();
        if (null === $this->collTicketRepliess || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTicketRepliess) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTicketRepliess());
            }

            $query = ChildTicketRepliesQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTicketRepliess);
    }

    /**
     * Method called to associate a ChildTicketReplies object to this object
     * through the ChildTicketReplies foreign key attribute.
     *
     * @param ChildTicketReplies $l ChildTicketReplies
     * @return $this The current object (for fluent API support)
     */
    public function addTicketReplies(ChildTicketReplies $l)
    {
        if ($this->collTicketRepliess === null) {
            $this->initTicketRepliess();
            $this->collTicketRepliessPartial = true;
        }

        if (!$this->collTicketRepliess->contains($l)) {
            $this->doAddTicketReplies($l);

            if ($this->ticketRepliessScheduledForDeletion and $this->ticketRepliessScheduledForDeletion->contains($l)) {
                $this->ticketRepliessScheduledForDeletion->remove($this->ticketRepliessScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTicketReplies $ticketReplies The ChildTicketReplies object to add.
     */
    protected function doAddTicketReplies(ChildTicketReplies $ticketReplies): void
    {
        $this->collTicketRepliess[]= $ticketReplies;
        $ticketReplies->setCompany($this);
    }

    /**
     * @param ChildTicketReplies $ticketReplies The ChildTicketReplies object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTicketReplies(ChildTicketReplies $ticketReplies)
    {
        if ($this->getTicketRepliess()->contains($ticketReplies)) {
            $pos = $this->collTicketRepliess->search($ticketReplies);
            $this->collTicketRepliess->remove($pos);
            if (null === $this->ticketRepliessScheduledForDeletion) {
                $this->ticketRepliessScheduledForDeletion = clone $this->collTicketRepliess;
                $this->ticketRepliessScheduledForDeletion->clear();
            }
            $this->ticketRepliessScheduledForDeletion[]= $ticketReplies;
            $ticketReplies->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related TicketRepliess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTicketReplies[] List of ChildTicketReplies objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTicketReplies}> List of ChildTicketReplies objects
     */
    public function getTicketRepliessJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTicketRepliesQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getTicketRepliess($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related TicketRepliess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTicketReplies[] List of ChildTicketReplies objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTicketReplies}> List of ChildTicketReplies objects
     */
    public function getTicketRepliessJoinTickets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTicketRepliesQuery::create(null, $criteria);
        $query->joinWith('Tickets', $joinBehavior);

        return $this->getTicketRepliess($query, $con);
    }

    /**
     * Clears out the collTicketTypes collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTicketTypes()
     */
    public function clearTicketTypes()
    {
        $this->collTicketTypes = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTicketTypes collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTicketTypes($v = true): void
    {
        $this->collTicketTypesPartial = $v;
    }

    /**
     * Initializes the collTicketTypes collection.
     *
     * By default this just sets the collTicketTypes collection to an empty array (like clearcollTicketTypes());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTicketTypes(bool $overrideExisting = true): void
    {
        if (null !== $this->collTicketTypes && !$overrideExisting) {
            return;
        }

        $collectionClassName = TicketTypeTableMap::getTableMap()->getCollectionClassName();

        $this->collTicketTypes = new $collectionClassName;
        $this->collTicketTypes->setModel('\entities\TicketType');
    }

    /**
     * Gets an array of ChildTicketType objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTicketType[] List of ChildTicketType objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTicketType> List of ChildTicketType objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTicketTypes(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTicketTypesPartial && !$this->isNew();
        if (null === $this->collTicketTypes || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTicketTypes) {
                    $this->initTicketTypes();
                } else {
                    $collectionClassName = TicketTypeTableMap::getTableMap()->getCollectionClassName();

                    $collTicketTypes = new $collectionClassName;
                    $collTicketTypes->setModel('\entities\TicketType');

                    return $collTicketTypes;
                }
            } else {
                $collTicketTypes = ChildTicketTypeQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTicketTypesPartial && count($collTicketTypes)) {
                        $this->initTicketTypes(false);

                        foreach ($collTicketTypes as $obj) {
                            if (false == $this->collTicketTypes->contains($obj)) {
                                $this->collTicketTypes->append($obj);
                            }
                        }

                        $this->collTicketTypesPartial = true;
                    }

                    return $collTicketTypes;
                }

                if ($partial && $this->collTicketTypes) {
                    foreach ($this->collTicketTypes as $obj) {
                        if ($obj->isNew()) {
                            $collTicketTypes[] = $obj;
                        }
                    }
                }

                $this->collTicketTypes = $collTicketTypes;
                $this->collTicketTypesPartial = false;
            }
        }

        return $this->collTicketTypes;
    }

    /**
     * Sets a collection of ChildTicketType objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $ticketTypes A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTicketTypes(Collection $ticketTypes, ?ConnectionInterface $con = null)
    {
        /** @var ChildTicketType[] $ticketTypesToDelete */
        $ticketTypesToDelete = $this->getTicketTypes(new Criteria(), $con)->diff($ticketTypes);


        $this->ticketTypesScheduledForDeletion = $ticketTypesToDelete;

        foreach ($ticketTypesToDelete as $ticketTypeRemoved) {
            $ticketTypeRemoved->setCompany(null);
        }

        $this->collTicketTypes = null;
        foreach ($ticketTypes as $ticketType) {
            $this->addTicketType($ticketType);
        }

        $this->collTicketTypes = $ticketTypes;
        $this->collTicketTypesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related TicketType objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related TicketType objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTicketTypes(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTicketTypesPartial && !$this->isNew();
        if (null === $this->collTicketTypes || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTicketTypes) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTicketTypes());
            }

            $query = ChildTicketTypeQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTicketTypes);
    }

    /**
     * Method called to associate a ChildTicketType object to this object
     * through the ChildTicketType foreign key attribute.
     *
     * @param ChildTicketType $l ChildTicketType
     * @return $this The current object (for fluent API support)
     */
    public function addTicketType(ChildTicketType $l)
    {
        if ($this->collTicketTypes === null) {
            $this->initTicketTypes();
            $this->collTicketTypesPartial = true;
        }

        if (!$this->collTicketTypes->contains($l)) {
            $this->doAddTicketType($l);

            if ($this->ticketTypesScheduledForDeletion and $this->ticketTypesScheduledForDeletion->contains($l)) {
                $this->ticketTypesScheduledForDeletion->remove($this->ticketTypesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTicketType $ticketType The ChildTicketType object to add.
     */
    protected function doAddTicketType(ChildTicketType $ticketType): void
    {
        $this->collTicketTypes[]= $ticketType;
        $ticketType->setCompany($this);
    }

    /**
     * @param ChildTicketType $ticketType The ChildTicketType object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTicketType(ChildTicketType $ticketType)
    {
        if ($this->getTicketTypes()->contains($ticketType)) {
            $pos = $this->collTicketTypes->search($ticketType);
            $this->collTicketTypes->remove($pos);
            if (null === $this->ticketTypesScheduledForDeletion) {
                $this->ticketTypesScheduledForDeletion = clone $this->collTicketTypes;
                $this->ticketTypesScheduledForDeletion->clear();
            }
            $this->ticketTypesScheduledForDeletion[]= $ticketType;
            $ticketType->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related TicketTypes from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTicketType[] List of ChildTicketType objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTicketType}> List of ChildTicketType objects
     */
    public function getTicketTypesJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTicketTypeQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getTicketTypes($query, $con);
    }

    /**
     * Clears out the collTicketss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTicketss()
     */
    public function clearTicketss()
    {
        $this->collTicketss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTicketss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTicketss($v = true): void
    {
        $this->collTicketssPartial = $v;
    }

    /**
     * Initializes the collTicketss collection.
     *
     * By default this just sets the collTicketss collection to an empty array (like clearcollTicketss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTicketss(bool $overrideExisting = true): void
    {
        if (null !== $this->collTicketss && !$overrideExisting) {
            return;
        }

        $collectionClassName = TicketsTableMap::getTableMap()->getCollectionClassName();

        $this->collTicketss = new $collectionClassName;
        $this->collTicketss->setModel('\entities\Tickets');
    }

    /**
     * Gets an array of ChildTickets objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTickets[] List of ChildTickets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTickets> List of ChildTickets objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTicketss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTicketssPartial && !$this->isNew();
        if (null === $this->collTicketss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTicketss) {
                    $this->initTicketss();
                } else {
                    $collectionClassName = TicketsTableMap::getTableMap()->getCollectionClassName();

                    $collTicketss = new $collectionClassName;
                    $collTicketss->setModel('\entities\Tickets');

                    return $collTicketss;
                }
            } else {
                $collTicketss = ChildTicketsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTicketssPartial && count($collTicketss)) {
                        $this->initTicketss(false);

                        foreach ($collTicketss as $obj) {
                            if (false == $this->collTicketss->contains($obj)) {
                                $this->collTicketss->append($obj);
                            }
                        }

                        $this->collTicketssPartial = true;
                    }

                    return $collTicketss;
                }

                if ($partial && $this->collTicketss) {
                    foreach ($this->collTicketss as $obj) {
                        if ($obj->isNew()) {
                            $collTicketss[] = $obj;
                        }
                    }
                }

                $this->collTicketss = $collTicketss;
                $this->collTicketssPartial = false;
            }
        }

        return $this->collTicketss;
    }

    /**
     * Sets a collection of ChildTickets objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $ticketss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTicketss(Collection $ticketss, ?ConnectionInterface $con = null)
    {
        /** @var ChildTickets[] $ticketssToDelete */
        $ticketssToDelete = $this->getTicketss(new Criteria(), $con)->diff($ticketss);


        $this->ticketssScheduledForDeletion = $ticketssToDelete;

        foreach ($ticketssToDelete as $ticketsRemoved) {
            $ticketsRemoved->setCompany(null);
        }

        $this->collTicketss = null;
        foreach ($ticketss as $tickets) {
            $this->addTickets($tickets);
        }

        $this->collTicketss = $ticketss;
        $this->collTicketssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Tickets objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Tickets objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTicketss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTicketssPartial && !$this->isNew();
        if (null === $this->collTicketss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTicketss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTicketss());
            }

            $query = ChildTicketsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTicketss);
    }

    /**
     * Method called to associate a ChildTickets object to this object
     * through the ChildTickets foreign key attribute.
     *
     * @param ChildTickets $l ChildTickets
     * @return $this The current object (for fluent API support)
     */
    public function addTickets(ChildTickets $l)
    {
        if ($this->collTicketss === null) {
            $this->initTicketss();
            $this->collTicketssPartial = true;
        }

        if (!$this->collTicketss->contains($l)) {
            $this->doAddTickets($l);

            if ($this->ticketssScheduledForDeletion and $this->ticketssScheduledForDeletion->contains($l)) {
                $this->ticketssScheduledForDeletion->remove($this->ticketssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTickets $tickets The ChildTickets object to add.
     */
    protected function doAddTickets(ChildTickets $tickets): void
    {
        $this->collTicketss[]= $tickets;
        $tickets->setCompany($this);
    }

    /**
     * @param ChildTickets $tickets The ChildTickets object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTickets(ChildTickets $tickets)
    {
        if ($this->getTicketss()->contains($tickets)) {
            $pos = $this->collTicketss->search($tickets);
            $this->collTicketss->remove($pos);
            if (null === $this->ticketssScheduledForDeletion) {
                $this->ticketssScheduledForDeletion = clone $this->collTicketss;
                $this->ticketssScheduledForDeletion->clear();
            }
            $this->ticketssScheduledForDeletion[]= clone $tickets;
            $tickets->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Ticketss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTickets[] List of ChildTickets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTickets}> List of ChildTickets objects
     */
    public function getTicketssJoinTicketType(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTicketsQuery::create(null, $criteria);
        $query->joinWith('TicketType', $joinBehavior);

        return $this->getTicketss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Ticketss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTickets[] List of ChildTickets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTickets}> List of ChildTickets objects
     */
    public function getTicketssJoinOutlets(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTicketsQuery::create(null, $criteria);
        $query->joinWith('Outlets', $joinBehavior);

        return $this->getTicketss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Ticketss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTickets[] List of ChildTickets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTickets}> List of ChildTickets objects
     */
    public function getTicketssJoinEmployeeRelatedByEmployeeId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTicketsQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByEmployeeId', $joinBehavior);

        return $this->getTicketss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Ticketss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTickets[] List of ChildTickets objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTickets}> List of ChildTickets objects
     */
    public function getTicketssJoinEmployeeRelatedByAllocatedTo(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTicketsQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByAllocatedTo', $joinBehavior);

        return $this->getTicketss($query, $con);
    }

    /**
     * Clears out the collTourplanss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTourplanss()
     */
    public function clearTourplanss()
    {
        $this->collTourplanss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTourplanss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTourplanss($v = true): void
    {
        $this->collTourplanssPartial = $v;
    }

    /**
     * Initializes the collTourplanss collection.
     *
     * By default this just sets the collTourplanss collection to an empty array (like clearcollTourplanss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTourplanss(bool $overrideExisting = true): void
    {
        if (null !== $this->collTourplanss && !$overrideExisting) {
            return;
        }

        $collectionClassName = TourplansTableMap::getTableMap()->getCollectionClassName();

        $this->collTourplanss = new $collectionClassName;
        $this->collTourplanss->setModel('\entities\Tourplans');
    }

    /**
     * Gets an array of ChildTourplans objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans> List of ChildTourplans objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTourplanss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTourplanssPartial && !$this->isNew();
        if (null === $this->collTourplanss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTourplanss) {
                    $this->initTourplanss();
                } else {
                    $collectionClassName = TourplansTableMap::getTableMap()->getCollectionClassName();

                    $collTourplanss = new $collectionClassName;
                    $collTourplanss->setModel('\entities\Tourplans');

                    return $collTourplanss;
                }
            } else {
                $collTourplanss = ChildTourplansQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTourplanssPartial && count($collTourplanss)) {
                        $this->initTourplanss(false);

                        foreach ($collTourplanss as $obj) {
                            if (false == $this->collTourplanss->contains($obj)) {
                                $this->collTourplanss->append($obj);
                            }
                        }

                        $this->collTourplanssPartial = true;
                    }

                    return $collTourplanss;
                }

                if ($partial && $this->collTourplanss) {
                    foreach ($this->collTourplanss as $obj) {
                        if ($obj->isNew()) {
                            $collTourplanss[] = $obj;
                        }
                    }
                }

                $this->collTourplanss = $collTourplanss;
                $this->collTourplanssPartial = false;
            }
        }

        return $this->collTourplanss;
    }

    /**
     * Sets a collection of ChildTourplans objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $tourplanss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTourplanss(Collection $tourplanss, ?ConnectionInterface $con = null)
    {
        /** @var ChildTourplans[] $tourplanssToDelete */
        $tourplanssToDelete = $this->getTourplanss(new Criteria(), $con)->diff($tourplanss);


        $this->tourplanssScheduledForDeletion = $tourplanssToDelete;

        foreach ($tourplanssToDelete as $tourplansRemoved) {
            $tourplansRemoved->setCompany(null);
        }

        $this->collTourplanss = null;
        foreach ($tourplanss as $tourplans) {
            $this->addTourplans($tourplans);
        }

        $this->collTourplanss = $tourplanss;
        $this->collTourplanssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Tourplans objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Tourplans objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTourplanss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTourplanssPartial && !$this->isNew();
        if (null === $this->collTourplanss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTourplanss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTourplanss());
            }

            $query = ChildTourplansQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTourplanss);
    }

    /**
     * Method called to associate a ChildTourplans object to this object
     * through the ChildTourplans foreign key attribute.
     *
     * @param ChildTourplans $l ChildTourplans
     * @return $this The current object (for fluent API support)
     */
    public function addTourplans(ChildTourplans $l)
    {
        if ($this->collTourplanss === null) {
            $this->initTourplanss();
            $this->collTourplanssPartial = true;
        }

        if (!$this->collTourplanss->contains($l)) {
            $this->doAddTourplans($l);

            if ($this->tourplanssScheduledForDeletion and $this->tourplanssScheduledForDeletion->contains($l)) {
                $this->tourplanssScheduledForDeletion->remove($this->tourplanssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTourplans $tourplans The ChildTourplans object to add.
     */
    protected function doAddTourplans(ChildTourplans $tourplans): void
    {
        $this->collTourplanss[]= $tourplans;
        $tourplans->setCompany($this);
    }

    /**
     * @param ChildTourplans $tourplans The ChildTourplans object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTourplans(ChildTourplans $tourplans)
    {
        if ($this->getTourplanss()->contains($tourplans)) {
            $pos = $this->collTourplanss->search($tourplans);
            $this->collTourplanss->remove($pos);
            if (null === $this->tourplanssScheduledForDeletion) {
                $this->tourplanssScheduledForDeletion = clone $this->collTourplanss;
                $this->tourplanssScheduledForDeletion->clear();
            }
            $this->tourplanssScheduledForDeletion[]= $tourplans;
            $tourplans->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Tourplanss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans}> List of ChildTourplans objects
     */
    public function getTourplanssJoinAgendatypes(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTourplansQuery::create(null, $criteria);
        $query->joinWith('Agendatypes', $joinBehavior);

        return $this->getTourplanss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Tourplanss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans}> List of ChildTourplans objects
     */
    public function getTourplanssJoinBeats(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTourplansQuery::create(null, $criteria);
        $query->joinWith('Beats', $joinBehavior);

        return $this->getTourplanss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Tourplanss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans}> List of ChildTourplans objects
     */
    public function getTourplanssJoinMtpDay(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTourplansQuery::create(null, $criteria);
        $query->joinWith('MtpDay', $joinBehavior);

        return $this->getTourplanss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Tourplanss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans}> List of ChildTourplans objects
     */
    public function getTourplanssJoinGeoTowns(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTourplansQuery::create(null, $criteria);
        $query->joinWith('GeoTowns', $joinBehavior);

        return $this->getTourplanss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Tourplanss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans}> List of ChildTourplans objects
     */
    public function getTourplanssJoinMtp(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTourplansQuery::create(null, $criteria);
        $query->joinWith('Mtp', $joinBehavior);

        return $this->getTourplanss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Tourplanss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans}> List of ChildTourplans objects
     */
    public function getTourplanssJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTourplansQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getTourplanss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Tourplanss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans}> List of ChildTourplans objects
     */
    public function getTourplanssJoinPositions(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTourplansQuery::create(null, $criteria);
        $query->joinWith('Positions', $joinBehavior);

        return $this->getTourplanss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Tourplanss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTourplans[] List of ChildTourplans objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTourplans}> List of ChildTourplans objects
     */
    public function getTourplanssJoinBrandCampiagnVisitPlan(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTourplansQuery::create(null, $criteria);
        $query->joinWith('BrandCampiagnVisitPlan', $joinBehavior);

        return $this->getTourplanss($query, $con);
    }

    /**
     * Clears out the collTransactionss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addTransactionss()
     */
    public function clearTransactionss()
    {
        $this->collTransactionss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collTransactionss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialTransactionss($v = true): void
    {
        $this->collTransactionssPartial = $v;
    }

    /**
     * Initializes the collTransactionss collection.
     *
     * By default this just sets the collTransactionss collection to an empty array (like clearcollTransactionss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initTransactionss(bool $overrideExisting = true): void
    {
        if (null !== $this->collTransactionss && !$overrideExisting) {
            return;
        }

        $collectionClassName = TransactionsTableMap::getTableMap()->getCollectionClassName();

        $this->collTransactionss = new $collectionClassName;
        $this->collTransactionss->setModel('\entities\Transactions');
    }

    /**
     * Gets an array of ChildTransactions objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildTransactions[] List of ChildTransactions objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTransactions> List of ChildTransactions objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getTransactionss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collTransactionssPartial && !$this->isNew();
        if (null === $this->collTransactionss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collTransactionss) {
                    $this->initTransactionss();
                } else {
                    $collectionClassName = TransactionsTableMap::getTableMap()->getCollectionClassName();

                    $collTransactionss = new $collectionClassName;
                    $collTransactionss->setModel('\entities\Transactions');

                    return $collTransactionss;
                }
            } else {
                $collTransactionss = ChildTransactionsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collTransactionssPartial && count($collTransactionss)) {
                        $this->initTransactionss(false);

                        foreach ($collTransactionss as $obj) {
                            if (false == $this->collTransactionss->contains($obj)) {
                                $this->collTransactionss->append($obj);
                            }
                        }

                        $this->collTransactionssPartial = true;
                    }

                    return $collTransactionss;
                }

                if ($partial && $this->collTransactionss) {
                    foreach ($this->collTransactionss as $obj) {
                        if ($obj->isNew()) {
                            $collTransactionss[] = $obj;
                        }
                    }
                }

                $this->collTransactionss = $collTransactionss;
                $this->collTransactionssPartial = false;
            }
        }

        return $this->collTransactionss;
    }

    /**
     * Sets a collection of ChildTransactions objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $transactionss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setTransactionss(Collection $transactionss, ?ConnectionInterface $con = null)
    {
        /** @var ChildTransactions[] $transactionssToDelete */
        $transactionssToDelete = $this->getTransactionss(new Criteria(), $con)->diff($transactionss);


        $this->transactionssScheduledForDeletion = $transactionssToDelete;

        foreach ($transactionssToDelete as $transactionsRemoved) {
            $transactionsRemoved->setCompany(null);
        }

        $this->collTransactionss = null;
        foreach ($transactionss as $transactions) {
            $this->addTransactions($transactions);
        }

        $this->collTransactionss = $transactionss;
        $this->collTransactionssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Transactions objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Transactions objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countTransactionss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collTransactionssPartial && !$this->isNew();
        if (null === $this->collTransactionss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collTransactionss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getTransactionss());
            }

            $query = ChildTransactionsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collTransactionss);
    }

    /**
     * Method called to associate a ChildTransactions object to this object
     * through the ChildTransactions foreign key attribute.
     *
     * @param ChildTransactions $l ChildTransactions
     * @return $this The current object (for fluent API support)
     */
    public function addTransactions(ChildTransactions $l)
    {
        if ($this->collTransactionss === null) {
            $this->initTransactionss();
            $this->collTransactionssPartial = true;
        }

        if (!$this->collTransactionss->contains($l)) {
            $this->doAddTransactions($l);

            if ($this->transactionssScheduledForDeletion and $this->transactionssScheduledForDeletion->contains($l)) {
                $this->transactionssScheduledForDeletion->remove($this->transactionssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildTransactions $transactions The ChildTransactions object to add.
     */
    protected function doAddTransactions(ChildTransactions $transactions): void
    {
        $this->collTransactionss[]= $transactions;
        $transactions->setCompany($this);
    }

    /**
     * @param ChildTransactions $transactions The ChildTransactions object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeTransactions(ChildTransactions $transactions)
    {
        if ($this->getTransactionss()->contains($transactions)) {
            $pos = $this->collTransactionss->search($transactions);
            $this->collTransactionss->remove($pos);
            if (null === $this->transactionssScheduledForDeletion) {
                $this->transactionssScheduledForDeletion = clone $this->collTransactionss;
                $this->transactionssScheduledForDeletion->clear();
            }
            $this->transactionssScheduledForDeletion[]= clone $transactions;
            $transactions->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Transactionss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTransactions[] List of ChildTransactions objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTransactions}> List of ChildTransactions objects
     */
    public function getTransactionssJoinEmployeeRelatedByEmployeeId(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTransactionsQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByEmployeeId', $joinBehavior);

        return $this->getTransactionss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Transactionss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildTransactions[] List of ChildTransactions objects
     * @phpstan-return ObjectCollection&\Traversable<ChildTransactions}> List of ChildTransactions objects
     */
    public function getTransactionssJoinEmployeeRelatedByCreatedBy(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildTransactionsQuery::create(null, $criteria);
        $query->joinWith('EmployeeRelatedByCreatedBy', $joinBehavior);

        return $this->getTransactionss($query, $con);
    }

    /**
     * Clears out the collUserss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addUserss()
     */
    public function clearUserss()
    {
        $this->collUserss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collUserss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialUserss($v = true): void
    {
        $this->collUserssPartial = $v;
    }

    /**
     * Initializes the collUserss collection.
     *
     * By default this just sets the collUserss collection to an empty array (like clearcollUserss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initUserss(bool $overrideExisting = true): void
    {
        if (null !== $this->collUserss && !$overrideExisting) {
            return;
        }

        $collectionClassName = UsersTableMap::getTableMap()->getCollectionClassName();

        $this->collUserss = new $collectionClassName;
        $this->collUserss->setModel('\entities\Users');
    }

    /**
     * Gets an array of ChildUsers objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildUsers[] List of ChildUsers objects
     * @phpstan-return ObjectCollection&\Traversable<ChildUsers> List of ChildUsers objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getUserss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collUserssPartial && !$this->isNew();
        if (null === $this->collUserss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collUserss) {
                    $this->initUserss();
                } else {
                    $collectionClassName = UsersTableMap::getTableMap()->getCollectionClassName();

                    $collUserss = new $collectionClassName;
                    $collUserss->setModel('\entities\Users');

                    return $collUserss;
                }
            } else {
                $collUserss = ChildUsersQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collUserssPartial && count($collUserss)) {
                        $this->initUserss(false);

                        foreach ($collUserss as $obj) {
                            if (false == $this->collUserss->contains($obj)) {
                                $this->collUserss->append($obj);
                            }
                        }

                        $this->collUserssPartial = true;
                    }

                    return $collUserss;
                }

                if ($partial && $this->collUserss) {
                    foreach ($this->collUserss as $obj) {
                        if ($obj->isNew()) {
                            $collUserss[] = $obj;
                        }
                    }
                }

                $this->collUserss = $collUserss;
                $this->collUserssPartial = false;
            }
        }

        return $this->collUserss;
    }

    /**
     * Sets a collection of ChildUsers objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $userss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setUserss(Collection $userss, ?ConnectionInterface $con = null)
    {
        /** @var ChildUsers[] $userssToDelete */
        $userssToDelete = $this->getUserss(new Criteria(), $con)->diff($userss);


        $this->userssScheduledForDeletion = $userssToDelete;

        foreach ($userssToDelete as $usersRemoved) {
            $usersRemoved->setCompany(null);
        }

        $this->collUserss = null;
        foreach ($userss as $users) {
            $this->addUsers($users);
        }

        $this->collUserss = $userss;
        $this->collUserssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Users objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Users objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countUserss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collUserssPartial && !$this->isNew();
        if (null === $this->collUserss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collUserss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getUserss());
            }

            $query = ChildUsersQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collUserss);
    }

    /**
     * Method called to associate a ChildUsers object to this object
     * through the ChildUsers foreign key attribute.
     *
     * @param ChildUsers $l ChildUsers
     * @return $this The current object (for fluent API support)
     */
    public function addUsers(ChildUsers $l)
    {
        if ($this->collUserss === null) {
            $this->initUserss();
            $this->collUserssPartial = true;
        }

        if (!$this->collUserss->contains($l)) {
            $this->doAddUsers($l);

            if ($this->userssScheduledForDeletion and $this->userssScheduledForDeletion->contains($l)) {
                $this->userssScheduledForDeletion->remove($this->userssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildUsers $users The ChildUsers object to add.
     */
    protected function doAddUsers(ChildUsers $users): void
    {
        $this->collUserss[]= $users;
        $users->setCompany($this);
    }

    /**
     * @param ChildUsers $users The ChildUsers object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeUsers(ChildUsers $users)
    {
        if ($this->getUserss()->contains($users)) {
            $pos = $this->collUserss->search($users);
            $this->collUserss->remove($pos);
            if (null === $this->userssScheduledForDeletion) {
                $this->userssScheduledForDeletion = clone $this->collUserss;
                $this->userssScheduledForDeletion->clear();
            }
            $this->userssScheduledForDeletion[]= $users;
            $users->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Userss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildUsers[] List of ChildUsers objects
     * @phpstan-return ObjectCollection&\Traversable<ChildUsers}> List of ChildUsers objects
     */
    public function getUserssJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildUsersQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getUserss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Userss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildUsers[] List of ChildUsers objects
     * @phpstan-return ObjectCollection&\Traversable<ChildUsers}> List of ChildUsers objects
     */
    public function getUserssJoinRoles(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildUsersQuery::create(null, $criteria);
        $query->joinWith('Roles', $joinBehavior);

        return $this->getUserss($query, $con);
    }

    /**
     * Clears out the collWdbSyncLogs collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addWdbSyncLogs()
     */
    public function clearWdbSyncLogs()
    {
        $this->collWdbSyncLogs = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collWdbSyncLogs collection loaded partially.
     *
     * @return void
     */
    public function resetPartialWdbSyncLogs($v = true): void
    {
        $this->collWdbSyncLogsPartial = $v;
    }

    /**
     * Initializes the collWdbSyncLogs collection.
     *
     * By default this just sets the collWdbSyncLogs collection to an empty array (like clearcollWdbSyncLogs());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initWdbSyncLogs(bool $overrideExisting = true): void
    {
        if (null !== $this->collWdbSyncLogs && !$overrideExisting) {
            return;
        }

        $collectionClassName = WdbSyncLogTableMap::getTableMap()->getCollectionClassName();

        $this->collWdbSyncLogs = new $collectionClassName;
        $this->collWdbSyncLogs->setModel('\entities\WdbSyncLog');
    }

    /**
     * Gets an array of ChildWdbSyncLog objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildWdbSyncLog[] List of ChildWdbSyncLog objects
     * @phpstan-return ObjectCollection&\Traversable<ChildWdbSyncLog> List of ChildWdbSyncLog objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getWdbSyncLogs(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collWdbSyncLogsPartial && !$this->isNew();
        if (null === $this->collWdbSyncLogs || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collWdbSyncLogs) {
                    $this->initWdbSyncLogs();
                } else {
                    $collectionClassName = WdbSyncLogTableMap::getTableMap()->getCollectionClassName();

                    $collWdbSyncLogs = new $collectionClassName;
                    $collWdbSyncLogs->setModel('\entities\WdbSyncLog');

                    return $collWdbSyncLogs;
                }
            } else {
                $collWdbSyncLogs = ChildWdbSyncLogQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collWdbSyncLogsPartial && count($collWdbSyncLogs)) {
                        $this->initWdbSyncLogs(false);

                        foreach ($collWdbSyncLogs as $obj) {
                            if (false == $this->collWdbSyncLogs->contains($obj)) {
                                $this->collWdbSyncLogs->append($obj);
                            }
                        }

                        $this->collWdbSyncLogsPartial = true;
                    }

                    return $collWdbSyncLogs;
                }

                if ($partial && $this->collWdbSyncLogs) {
                    foreach ($this->collWdbSyncLogs as $obj) {
                        if ($obj->isNew()) {
                            $collWdbSyncLogs[] = $obj;
                        }
                    }
                }

                $this->collWdbSyncLogs = $collWdbSyncLogs;
                $this->collWdbSyncLogsPartial = false;
            }
        }

        return $this->collWdbSyncLogs;
    }

    /**
     * Sets a collection of ChildWdbSyncLog objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $wdbSyncLogs A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setWdbSyncLogs(Collection $wdbSyncLogs, ?ConnectionInterface $con = null)
    {
        /** @var ChildWdbSyncLog[] $wdbSyncLogsToDelete */
        $wdbSyncLogsToDelete = $this->getWdbSyncLogs(new Criteria(), $con)->diff($wdbSyncLogs);


        $this->wdbSyncLogsScheduledForDeletion = $wdbSyncLogsToDelete;

        foreach ($wdbSyncLogsToDelete as $wdbSyncLogRemoved) {
            $wdbSyncLogRemoved->setCompany(null);
        }

        $this->collWdbSyncLogs = null;
        foreach ($wdbSyncLogs as $wdbSyncLog) {
            $this->addWdbSyncLog($wdbSyncLog);
        }

        $this->collWdbSyncLogs = $wdbSyncLogs;
        $this->collWdbSyncLogsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related WdbSyncLog objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related WdbSyncLog objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countWdbSyncLogs(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collWdbSyncLogsPartial && !$this->isNew();
        if (null === $this->collWdbSyncLogs || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collWdbSyncLogs) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getWdbSyncLogs());
            }

            $query = ChildWdbSyncLogQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collWdbSyncLogs);
    }

    /**
     * Method called to associate a ChildWdbSyncLog object to this object
     * through the ChildWdbSyncLog foreign key attribute.
     *
     * @param ChildWdbSyncLog $l ChildWdbSyncLog
     * @return $this The current object (for fluent API support)
     */
    public function addWdbSyncLog(ChildWdbSyncLog $l)
    {
        if ($this->collWdbSyncLogs === null) {
            $this->initWdbSyncLogs();
            $this->collWdbSyncLogsPartial = true;
        }

        if (!$this->collWdbSyncLogs->contains($l)) {
            $this->doAddWdbSyncLog($l);

            if ($this->wdbSyncLogsScheduledForDeletion and $this->wdbSyncLogsScheduledForDeletion->contains($l)) {
                $this->wdbSyncLogsScheduledForDeletion->remove($this->wdbSyncLogsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildWdbSyncLog $wdbSyncLog The ChildWdbSyncLog object to add.
     */
    protected function doAddWdbSyncLog(ChildWdbSyncLog $wdbSyncLog): void
    {
        $this->collWdbSyncLogs[]= $wdbSyncLog;
        $wdbSyncLog->setCompany($this);
    }

    /**
     * @param ChildWdbSyncLog $wdbSyncLog The ChildWdbSyncLog object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeWdbSyncLog(ChildWdbSyncLog $wdbSyncLog)
    {
        if ($this->getWdbSyncLogs()->contains($wdbSyncLog)) {
            $pos = $this->collWdbSyncLogs->search($wdbSyncLog);
            $this->collWdbSyncLogs->remove($pos);
            if (null === $this->wdbSyncLogsScheduledForDeletion) {
                $this->wdbSyncLogsScheduledForDeletion = clone $this->collWdbSyncLogs;
                $this->wdbSyncLogsScheduledForDeletion->clear();
            }
            $this->wdbSyncLogsScheduledForDeletion[]= clone $wdbSyncLog;
            $wdbSyncLog->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related WdbSyncLogs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildWdbSyncLog[] List of ChildWdbSyncLog objects
     * @phpstan-return ObjectCollection&\Traversable<ChildWdbSyncLog}> List of ChildWdbSyncLog objects
     */
    public function getWdbSyncLogsJoinUsers(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildWdbSyncLogQuery::create(null, $criteria);
        $query->joinWith('Users', $joinBehavior);

        return $this->getWdbSyncLogs($query, $con);
    }

    /**
     * Clears out the collWfRequestss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addWfRequestss()
     */
    public function clearWfRequestss()
    {
        $this->collWfRequestss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collWfRequestss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialWfRequestss($v = true): void
    {
        $this->collWfRequestssPartial = $v;
    }

    /**
     * Initializes the collWfRequestss collection.
     *
     * By default this just sets the collWfRequestss collection to an empty array (like clearcollWfRequestss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initWfRequestss(bool $overrideExisting = true): void
    {
        if (null !== $this->collWfRequestss && !$overrideExisting) {
            return;
        }

        $collectionClassName = WfRequestsTableMap::getTableMap()->getCollectionClassName();

        $this->collWfRequestss = new $collectionClassName;
        $this->collWfRequestss->setModel('\entities\WfRequests');
    }

    /**
     * Gets an array of ChildWfRequests objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildWfRequests[] List of ChildWfRequests objects
     * @phpstan-return ObjectCollection&\Traversable<ChildWfRequests> List of ChildWfRequests objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getWfRequestss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collWfRequestssPartial && !$this->isNew();
        if (null === $this->collWfRequestss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collWfRequestss) {
                    $this->initWfRequestss();
                } else {
                    $collectionClassName = WfRequestsTableMap::getTableMap()->getCollectionClassName();

                    $collWfRequestss = new $collectionClassName;
                    $collWfRequestss->setModel('\entities\WfRequests');

                    return $collWfRequestss;
                }
            } else {
                $collWfRequestss = ChildWfRequestsQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collWfRequestssPartial && count($collWfRequestss)) {
                        $this->initWfRequestss(false);

                        foreach ($collWfRequestss as $obj) {
                            if (false == $this->collWfRequestss->contains($obj)) {
                                $this->collWfRequestss->append($obj);
                            }
                        }

                        $this->collWfRequestssPartial = true;
                    }

                    return $collWfRequestss;
                }

                if ($partial && $this->collWfRequestss) {
                    foreach ($this->collWfRequestss as $obj) {
                        if ($obj->isNew()) {
                            $collWfRequestss[] = $obj;
                        }
                    }
                }

                $this->collWfRequestss = $collWfRequestss;
                $this->collWfRequestssPartial = false;
            }
        }

        return $this->collWfRequestss;
    }

    /**
     * Sets a collection of ChildWfRequests objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $wfRequestss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setWfRequestss(Collection $wfRequestss, ?ConnectionInterface $con = null)
    {
        /** @var ChildWfRequests[] $wfRequestssToDelete */
        $wfRequestssToDelete = $this->getWfRequestss(new Criteria(), $con)->diff($wfRequestss);


        $this->wfRequestssScheduledForDeletion = $wfRequestssToDelete;

        foreach ($wfRequestssToDelete as $wfRequestsRemoved) {
            $wfRequestsRemoved->setCompany(null);
        }

        $this->collWfRequestss = null;
        foreach ($wfRequestss as $wfRequests) {
            $this->addWfRequests($wfRequests);
        }

        $this->collWfRequestss = $wfRequestss;
        $this->collWfRequestssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related WfRequests objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related WfRequests objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countWfRequestss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collWfRequestssPartial && !$this->isNew();
        if (null === $this->collWfRequestss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collWfRequestss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getWfRequestss());
            }

            $query = ChildWfRequestsQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collWfRequestss);
    }

    /**
     * Method called to associate a ChildWfRequests object to this object
     * through the ChildWfRequests foreign key attribute.
     *
     * @param ChildWfRequests $l ChildWfRequests
     * @return $this The current object (for fluent API support)
     */
    public function addWfRequests(ChildWfRequests $l)
    {
        if ($this->collWfRequestss === null) {
            $this->initWfRequestss();
            $this->collWfRequestssPartial = true;
        }

        if (!$this->collWfRequestss->contains($l)) {
            $this->doAddWfRequests($l);

            if ($this->wfRequestssScheduledForDeletion and $this->wfRequestssScheduledForDeletion->contains($l)) {
                $this->wfRequestssScheduledForDeletion->remove($this->wfRequestssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildWfRequests $wfRequests The ChildWfRequests object to add.
     */
    protected function doAddWfRequests(ChildWfRequests $wfRequests): void
    {
        $this->collWfRequestss[]= $wfRequests;
        $wfRequests->setCompany($this);
    }

    /**
     * @param ChildWfRequests $wfRequests The ChildWfRequests object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeWfRequests(ChildWfRequests $wfRequests)
    {
        if ($this->getWfRequestss()->contains($wfRequests)) {
            $pos = $this->collWfRequestss->search($wfRequests);
            $this->collWfRequestss->remove($pos);
            if (null === $this->wfRequestssScheduledForDeletion) {
                $this->wfRequestssScheduledForDeletion = clone $this->collWfRequestss;
                $this->wfRequestssScheduledForDeletion->clear();
            }
            $this->wfRequestssScheduledForDeletion[]= clone $wfRequests;
            $wfRequests->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related WfRequestss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildWfRequests[] List of ChildWfRequests objects
     * @phpstan-return ObjectCollection&\Traversable<ChildWfRequests}> List of ChildWfRequests objects
     */
    public function getWfRequestssJoinEmployee(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildWfRequestsQuery::create(null, $criteria);
        $query->joinWith('Employee', $joinBehavior);

        return $this->getWfRequestss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related WfRequestss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildWfRequests[] List of ChildWfRequests objects
     * @phpstan-return ObjectCollection&\Traversable<ChildWfRequests}> List of ChildWfRequests objects
     */
    public function getWfRequestssJoinWfDocuments(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildWfRequestsQuery::create(null, $criteria);
        $query->joinWith('WfDocuments', $joinBehavior);

        return $this->getWfRequestss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related WfRequestss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildWfRequests[] List of ChildWfRequests objects
     * @phpstan-return ObjectCollection&\Traversable<ChildWfRequests}> List of ChildWfRequests objects
     */
    public function getWfRequestssJoinWfMaster(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildWfRequestsQuery::create(null, $criteria);
        $query->joinWith('WfMaster', $joinBehavior);

        return $this->getWfRequestss($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related WfRequestss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildWfRequests[] List of ChildWfRequests objects
     * @phpstan-return ObjectCollection&\Traversable<ChildWfRequests}> List of ChildWfRequests objects
     */
    public function getWfRequestssJoinWfSteps(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildWfRequestsQuery::create(null, $criteria);
        $query->joinWith('WfSteps', $joinBehavior);

        return $this->getWfRequestss($query, $con);
    }

    /**
     * Clears out the collStps collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addStps()
     */
    public function clearStps()
    {
        $this->collStps = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collStps collection loaded partially.
     *
     * @return void
     */
    public function resetPartialStps($v = true): void
    {
        $this->collStpsPartial = $v;
    }

    /**
     * Initializes the collStps collection.
     *
     * By default this just sets the collStps collection to an empty array (like clearcollStps());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initStps(bool $overrideExisting = true): void
    {
        if (null !== $this->collStps && !$overrideExisting) {
            return;
        }

        $collectionClassName = StpTableMap::getTableMap()->getCollectionClassName();

        $this->collStps = new $collectionClassName;
        $this->collStps->setModel('\entities\Stp');
    }

    /**
     * Gets an array of ChildStp objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildStp[] List of ChildStp objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStp> List of ChildStp objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getStps(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collStpsPartial && !$this->isNew();
        if (null === $this->collStps || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collStps) {
                    $this->initStps();
                } else {
                    $collectionClassName = StpTableMap::getTableMap()->getCollectionClassName();

                    $collStps = new $collectionClassName;
                    $collStps->setModel('\entities\Stp');

                    return $collStps;
                }
            } else {
                $collStps = ChildStpQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collStpsPartial && count($collStps)) {
                        $this->initStps(false);

                        foreach ($collStps as $obj) {
                            if (false == $this->collStps->contains($obj)) {
                                $this->collStps->append($obj);
                            }
                        }

                        $this->collStpsPartial = true;
                    }

                    return $collStps;
                }

                if ($partial && $this->collStps) {
                    foreach ($this->collStps as $obj) {
                        if ($obj->isNew()) {
                            $collStps[] = $obj;
                        }
                    }
                }

                $this->collStps = $collStps;
                $this->collStpsPartial = false;
            }
        }

        return $this->collStps;
    }

    /**
     * Sets a collection of ChildStp objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $stps A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setStps(Collection $stps, ?ConnectionInterface $con = null)
    {
        /** @var ChildStp[] $stpsToDelete */
        $stpsToDelete = $this->getStps(new Criteria(), $con)->diff($stps);


        $this->stpsScheduledForDeletion = $stpsToDelete;

        foreach ($stpsToDelete as $stpRemoved) {
            $stpRemoved->setCompany(null);
        }

        $this->collStps = null;
        foreach ($stps as $stp) {
            $this->addStp($stp);
        }

        $this->collStps = $stps;
        $this->collStpsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related Stp objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related Stp objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countStps(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collStpsPartial && !$this->isNew();
        if (null === $this->collStps || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collStps) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getStps());
            }

            $query = ChildStpQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collStps);
    }

    /**
     * Method called to associate a ChildStp object to this object
     * through the ChildStp foreign key attribute.
     *
     * @param ChildStp $l ChildStp
     * @return $this The current object (for fluent API support)
     */
    public function addStp(ChildStp $l)
    {
        if ($this->collStps === null) {
            $this->initStps();
            $this->collStpsPartial = true;
        }

        if (!$this->collStps->contains($l)) {
            $this->doAddStp($l);

            if ($this->stpsScheduledForDeletion and $this->stpsScheduledForDeletion->contains($l)) {
                $this->stpsScheduledForDeletion->remove($this->stpsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildStp $stp The ChildStp object to add.
     */
    protected function doAddStp(ChildStp $stp): void
    {
        $this->collStps[]= $stp;
        $stp->setCompany($this);
    }

    /**
     * @param ChildStp $stp The ChildStp object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeStp(ChildStp $stp)
    {
        if ($this->getStps()->contains($stp)) {
            $pos = $this->collStps->search($stp);
            $this->collStps->remove($pos);
            if (null === $this->stpsScheduledForDeletion) {
                $this->stpsScheduledForDeletion = clone $this->collStps;
                $this->stpsScheduledForDeletion->clear();
            }
            $this->stpsScheduledForDeletion[]= clone $stp;
            $stp->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related Stps from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStp[] List of ChildStp objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStp}> List of ChildStp objects
     */
    public function getStpsJoinPositions(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStpQuery::create(null, $criteria);
        $query->joinWith('Positions', $joinBehavior);

        return $this->getStps($query, $con);
    }

    /**
     * Clears out the collStpWeeks collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addStpWeeks()
     */
    public function clearStpWeeks()
    {
        $this->collStpWeeks = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collStpWeeks collection loaded partially.
     *
     * @return void
     */
    public function resetPartialStpWeeks($v = true): void
    {
        $this->collStpWeeksPartial = $v;
    }

    /**
     * Initializes the collStpWeeks collection.
     *
     * By default this just sets the collStpWeeks collection to an empty array (like clearcollStpWeeks());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initStpWeeks(bool $overrideExisting = true): void
    {
        if (null !== $this->collStpWeeks && !$overrideExisting) {
            return;
        }

        $collectionClassName = StpWeekTableMap::getTableMap()->getCollectionClassName();

        $this->collStpWeeks = new $collectionClassName;
        $this->collStpWeeks->setModel('\entities\StpWeek');
    }

    /**
     * Gets an array of ChildStpWeek objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildStpWeek[] List of ChildStpWeek objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStpWeek> List of ChildStpWeek objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getStpWeeks(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collStpWeeksPartial && !$this->isNew();
        if (null === $this->collStpWeeks || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collStpWeeks) {
                    $this->initStpWeeks();
                } else {
                    $collectionClassName = StpWeekTableMap::getTableMap()->getCollectionClassName();

                    $collStpWeeks = new $collectionClassName;
                    $collStpWeeks->setModel('\entities\StpWeek');

                    return $collStpWeeks;
                }
            } else {
                $collStpWeeks = ChildStpWeekQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collStpWeeksPartial && count($collStpWeeks)) {
                        $this->initStpWeeks(false);

                        foreach ($collStpWeeks as $obj) {
                            if (false == $this->collStpWeeks->contains($obj)) {
                                $this->collStpWeeks->append($obj);
                            }
                        }

                        $this->collStpWeeksPartial = true;
                    }

                    return $collStpWeeks;
                }

                if ($partial && $this->collStpWeeks) {
                    foreach ($this->collStpWeeks as $obj) {
                        if ($obj->isNew()) {
                            $collStpWeeks[] = $obj;
                        }
                    }
                }

                $this->collStpWeeks = $collStpWeeks;
                $this->collStpWeeksPartial = false;
            }
        }

        return $this->collStpWeeks;
    }

    /**
     * Sets a collection of ChildStpWeek objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $stpWeeks A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setStpWeeks(Collection $stpWeeks, ?ConnectionInterface $con = null)
    {
        /** @var ChildStpWeek[] $stpWeeksToDelete */
        $stpWeeksToDelete = $this->getStpWeeks(new Criteria(), $con)->diff($stpWeeks);


        $this->stpWeeksScheduledForDeletion = $stpWeeksToDelete;

        foreach ($stpWeeksToDelete as $stpWeekRemoved) {
            $stpWeekRemoved->setCompany(null);
        }

        $this->collStpWeeks = null;
        foreach ($stpWeeks as $stpWeek) {
            $this->addStpWeek($stpWeek);
        }

        $this->collStpWeeks = $stpWeeks;
        $this->collStpWeeksPartial = false;

        return $this;
    }

    /**
     * Returns the number of related StpWeek objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related StpWeek objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countStpWeeks(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collStpWeeksPartial && !$this->isNew();
        if (null === $this->collStpWeeks || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collStpWeeks) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getStpWeeks());
            }

            $query = ChildStpWeekQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collStpWeeks);
    }

    /**
     * Method called to associate a ChildStpWeek object to this object
     * through the ChildStpWeek foreign key attribute.
     *
     * @param ChildStpWeek $l ChildStpWeek
     * @return $this The current object (for fluent API support)
     */
    public function addStpWeek(ChildStpWeek $l)
    {
        if ($this->collStpWeeks === null) {
            $this->initStpWeeks();
            $this->collStpWeeksPartial = true;
        }

        if (!$this->collStpWeeks->contains($l)) {
            $this->doAddStpWeek($l);

            if ($this->stpWeeksScheduledForDeletion and $this->stpWeeksScheduledForDeletion->contains($l)) {
                $this->stpWeeksScheduledForDeletion->remove($this->stpWeeksScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildStpWeek $stpWeek The ChildStpWeek object to add.
     */
    protected function doAddStpWeek(ChildStpWeek $stpWeek): void
    {
        $this->collStpWeeks[]= $stpWeek;
        $stpWeek->setCompany($this);
    }

    /**
     * @param ChildStpWeek $stpWeek The ChildStpWeek object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeStpWeek(ChildStpWeek $stpWeek)
    {
        if ($this->getStpWeeks()->contains($stpWeek)) {
            $pos = $this->collStpWeeks->search($stpWeek);
            $this->collStpWeeks->remove($pos);
            if (null === $this->stpWeeksScheduledForDeletion) {
                $this->stpWeeksScheduledForDeletion = clone $this->collStpWeeks;
                $this->stpWeeksScheduledForDeletion->clear();
            }
            $this->stpWeeksScheduledForDeletion[]= clone $stpWeek;
            $stpWeek->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related StpWeeks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStpWeek[] List of ChildStpWeek objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStpWeek}> List of ChildStpWeek objects
     */
    public function getStpWeeksJoinBeats(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStpWeekQuery::create(null, $criteria);
        $query->joinWith('Beats', $joinBehavior);

        return $this->getStpWeeks($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related StpWeeks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStpWeek[] List of ChildStpWeek objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStpWeek}> List of ChildStpWeek objects
     */
    public function getStpWeeksJoinTerritories(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStpWeekQuery::create(null, $criteria);
        $query->joinWith('Territories', $joinBehavior);

        return $this->getStpWeeks($query, $con);
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related StpWeeks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildStpWeek[] List of ChildStpWeek objects
     * @phpstan-return ObjectCollection&\Traversable<ChildStpWeek}> List of ChildStpWeek objects
     */
    public function getStpWeeksJoinStp(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildStpWeekQuery::create(null, $criteria);
        $query->joinWith('Stp', $joinBehavior);

        return $this->getStpWeeks($query, $con);
    }

    /**
     * Clears out the collOutletOrgDataKeyss collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addOutletOrgDataKeyss()
     */
    public function clearOutletOrgDataKeyss()
    {
        $this->collOutletOrgDataKeyss = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collOutletOrgDataKeyss collection loaded partially.
     *
     * @return void
     */
    public function resetPartialOutletOrgDataKeyss($v = true): void
    {
        $this->collOutletOrgDataKeyssPartial = $v;
    }

    /**
     * Initializes the collOutletOrgDataKeyss collection.
     *
     * By default this just sets the collOutletOrgDataKeyss collection to an empty array (like clearcollOutletOrgDataKeyss());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initOutletOrgDataKeyss(bool $overrideExisting = true): void
    {
        if (null !== $this->collOutletOrgDataKeyss && !$overrideExisting) {
            return;
        }

        $collectionClassName = OutletOrgDataKeysTableMap::getTableMap()->getCollectionClassName();

        $this->collOutletOrgDataKeyss = new $collectionClassName;
        $this->collOutletOrgDataKeyss->setModel('\entities\OutletOrgDataKeys');
    }

    /**
     * Gets an array of ChildOutletOrgDataKeys objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildOutletOrgDataKeys[] List of ChildOutletOrgDataKeys objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgDataKeys> List of ChildOutletOrgDataKeys objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getOutletOrgDataKeyss(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collOutletOrgDataKeyssPartial && !$this->isNew();
        if (null === $this->collOutletOrgDataKeyss || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collOutletOrgDataKeyss) {
                    $this->initOutletOrgDataKeyss();
                } else {
                    $collectionClassName = OutletOrgDataKeysTableMap::getTableMap()->getCollectionClassName();

                    $collOutletOrgDataKeyss = new $collectionClassName;
                    $collOutletOrgDataKeyss->setModel('\entities\OutletOrgDataKeys');

                    return $collOutletOrgDataKeyss;
                }
            } else {
                $collOutletOrgDataKeyss = ChildOutletOrgDataKeysQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collOutletOrgDataKeyssPartial && count($collOutletOrgDataKeyss)) {
                        $this->initOutletOrgDataKeyss(false);

                        foreach ($collOutletOrgDataKeyss as $obj) {
                            if (false == $this->collOutletOrgDataKeyss->contains($obj)) {
                                $this->collOutletOrgDataKeyss->append($obj);
                            }
                        }

                        $this->collOutletOrgDataKeyssPartial = true;
                    }

                    return $collOutletOrgDataKeyss;
                }

                if ($partial && $this->collOutletOrgDataKeyss) {
                    foreach ($this->collOutletOrgDataKeyss as $obj) {
                        if ($obj->isNew()) {
                            $collOutletOrgDataKeyss[] = $obj;
                        }
                    }
                }

                $this->collOutletOrgDataKeyss = $collOutletOrgDataKeyss;
                $this->collOutletOrgDataKeyssPartial = false;
            }
        }

        return $this->collOutletOrgDataKeyss;
    }

    /**
     * Sets a collection of ChildOutletOrgDataKeys objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $outletOrgDataKeyss A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setOutletOrgDataKeyss(Collection $outletOrgDataKeyss, ?ConnectionInterface $con = null)
    {
        /** @var ChildOutletOrgDataKeys[] $outletOrgDataKeyssToDelete */
        $outletOrgDataKeyssToDelete = $this->getOutletOrgDataKeyss(new Criteria(), $con)->diff($outletOrgDataKeyss);


        $this->outletOrgDataKeyssScheduledForDeletion = $outletOrgDataKeyssToDelete;

        foreach ($outletOrgDataKeyssToDelete as $outletOrgDataKeysRemoved) {
            $outletOrgDataKeysRemoved->setCompany(null);
        }

        $this->collOutletOrgDataKeyss = null;
        foreach ($outletOrgDataKeyss as $outletOrgDataKeys) {
            $this->addOutletOrgDataKeys($outletOrgDataKeys);
        }

        $this->collOutletOrgDataKeyss = $outletOrgDataKeyss;
        $this->collOutletOrgDataKeyssPartial = false;

        return $this;
    }

    /**
     * Returns the number of related OutletOrgDataKeys objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related OutletOrgDataKeys objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countOutletOrgDataKeyss(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collOutletOrgDataKeyssPartial && !$this->isNew();
        if (null === $this->collOutletOrgDataKeyss || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collOutletOrgDataKeyss) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getOutletOrgDataKeyss());
            }

            $query = ChildOutletOrgDataKeysQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collOutletOrgDataKeyss);
    }

    /**
     * Method called to associate a ChildOutletOrgDataKeys object to this object
     * through the ChildOutletOrgDataKeys foreign key attribute.
     *
     * @param ChildOutletOrgDataKeys $l ChildOutletOrgDataKeys
     * @return $this The current object (for fluent API support)
     */
    public function addOutletOrgDataKeys(ChildOutletOrgDataKeys $l)
    {
        if ($this->collOutletOrgDataKeyss === null) {
            $this->initOutletOrgDataKeyss();
            $this->collOutletOrgDataKeyssPartial = true;
        }

        if (!$this->collOutletOrgDataKeyss->contains($l)) {
            $this->doAddOutletOrgDataKeys($l);

            if ($this->outletOrgDataKeyssScheduledForDeletion and $this->outletOrgDataKeyssScheduledForDeletion->contains($l)) {
                $this->outletOrgDataKeyssScheduledForDeletion->remove($this->outletOrgDataKeyssScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildOutletOrgDataKeys $outletOrgDataKeys The ChildOutletOrgDataKeys object to add.
     */
    protected function doAddOutletOrgDataKeys(ChildOutletOrgDataKeys $outletOrgDataKeys): void
    {
        $this->collOutletOrgDataKeyss[]= $outletOrgDataKeys;
        $outletOrgDataKeys->setCompany($this);
    }

    /**
     * @param ChildOutletOrgDataKeys $outletOrgDataKeys The ChildOutletOrgDataKeys object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeOutletOrgDataKeys(ChildOutletOrgDataKeys $outletOrgDataKeys)
    {
        if ($this->getOutletOrgDataKeyss()->contains($outletOrgDataKeys)) {
            $pos = $this->collOutletOrgDataKeyss->search($outletOrgDataKeys);
            $this->collOutletOrgDataKeyss->remove($pos);
            if (null === $this->outletOrgDataKeyssScheduledForDeletion) {
                $this->outletOrgDataKeyssScheduledForDeletion = clone $this->collOutletOrgDataKeyss;
                $this->outletOrgDataKeyssScheduledForDeletion->clear();
            }
            $this->outletOrgDataKeyssScheduledForDeletion[]= clone $outletOrgDataKeys;
            $outletOrgDataKeys->setCompany(null);
        }

        return $this;
    }


    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Company is new, it will return
     * an empty collection; or if this Company has previously
     * been saved, it will retrieve related OutletOrgDataKeyss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Company.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @param string $joinBehavior optional join type to use (defaults to Criteria::LEFT_JOIN)
     * @return ObjectCollection|ChildOutletOrgDataKeys[] List of ChildOutletOrgDataKeys objects
     * @phpstan-return ObjectCollection&\Traversable<ChildOutletOrgDataKeys}> List of ChildOutletOrgDataKeys objects
     */
    public function getOutletOrgDataKeyssJoinOutletOrgData(?Criteria $criteria = null, ?ConnectionInterface $con = null, $joinBehavior = Criteria::LEFT_JOIN)
    {
        $query = ChildOutletOrgDataKeysQuery::create(null, $criteria);
        $query->joinWith('OutletOrgData', $joinBehavior);

        return $this->getOutletOrgDataKeyss($query, $con);
    }

    /**
     * Clears out the collNotificationConfigurations collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addNotificationConfigurations()
     */
    public function clearNotificationConfigurations()
    {
        $this->collNotificationConfigurations = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collNotificationConfigurations collection loaded partially.
     *
     * @return void
     */
    public function resetPartialNotificationConfigurations($v = true): void
    {
        $this->collNotificationConfigurationsPartial = $v;
    }

    /**
     * Initializes the collNotificationConfigurations collection.
     *
     * By default this just sets the collNotificationConfigurations collection to an empty array (like clearcollNotificationConfigurations());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initNotificationConfigurations(bool $overrideExisting = true): void
    {
        if (null !== $this->collNotificationConfigurations && !$overrideExisting) {
            return;
        }

        $collectionClassName = NotificationConfigurationTableMap::getTableMap()->getCollectionClassName();

        $this->collNotificationConfigurations = new $collectionClassName;
        $this->collNotificationConfigurations->setModel('\entities\NotificationConfiguration');
    }

    /**
     * Gets an array of ChildNotificationConfiguration objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildNotificationConfiguration[] List of ChildNotificationConfiguration objects
     * @phpstan-return ObjectCollection&\Traversable<ChildNotificationConfiguration> List of ChildNotificationConfiguration objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getNotificationConfigurations(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collNotificationConfigurationsPartial && !$this->isNew();
        if (null === $this->collNotificationConfigurations || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collNotificationConfigurations) {
                    $this->initNotificationConfigurations();
                } else {
                    $collectionClassName = NotificationConfigurationTableMap::getTableMap()->getCollectionClassName();

                    $collNotificationConfigurations = new $collectionClassName;
                    $collNotificationConfigurations->setModel('\entities\NotificationConfiguration');

                    return $collNotificationConfigurations;
                }
            } else {
                $collNotificationConfigurations = ChildNotificationConfigurationQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collNotificationConfigurationsPartial && count($collNotificationConfigurations)) {
                        $this->initNotificationConfigurations(false);

                        foreach ($collNotificationConfigurations as $obj) {
                            if (false == $this->collNotificationConfigurations->contains($obj)) {
                                $this->collNotificationConfigurations->append($obj);
                            }
                        }

                        $this->collNotificationConfigurationsPartial = true;
                    }

                    return $collNotificationConfigurations;
                }

                if ($partial && $this->collNotificationConfigurations) {
                    foreach ($this->collNotificationConfigurations as $obj) {
                        if ($obj->isNew()) {
                            $collNotificationConfigurations[] = $obj;
                        }
                    }
                }

                $this->collNotificationConfigurations = $collNotificationConfigurations;
                $this->collNotificationConfigurationsPartial = false;
            }
        }

        return $this->collNotificationConfigurations;
    }

    /**
     * Sets a collection of ChildNotificationConfiguration objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $notificationConfigurations A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setNotificationConfigurations(Collection $notificationConfigurations, ?ConnectionInterface $con = null)
    {
        /** @var ChildNotificationConfiguration[] $notificationConfigurationsToDelete */
        $notificationConfigurationsToDelete = $this->getNotificationConfigurations(new Criteria(), $con)->diff($notificationConfigurations);


        $this->notificationConfigurationsScheduledForDeletion = $notificationConfigurationsToDelete;

        foreach ($notificationConfigurationsToDelete as $notificationConfigurationRemoved) {
            $notificationConfigurationRemoved->setCompany(null);
        }

        $this->collNotificationConfigurations = null;
        foreach ($notificationConfigurations as $notificationConfiguration) {
            $this->addNotificationConfiguration($notificationConfiguration);
        }

        $this->collNotificationConfigurations = $notificationConfigurations;
        $this->collNotificationConfigurationsPartial = false;

        return $this;
    }

    /**
     * Returns the number of related NotificationConfiguration objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related NotificationConfiguration objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countNotificationConfigurations(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collNotificationConfigurationsPartial && !$this->isNew();
        if (null === $this->collNotificationConfigurations || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collNotificationConfigurations) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getNotificationConfigurations());
            }

            $query = ChildNotificationConfigurationQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collNotificationConfigurations);
    }

    /**
     * Method called to associate a ChildNotificationConfiguration object to this object
     * through the ChildNotificationConfiguration foreign key attribute.
     *
     * @param ChildNotificationConfiguration $l ChildNotificationConfiguration
     * @return $this The current object (for fluent API support)
     */
    public function addNotificationConfiguration(ChildNotificationConfiguration $l)
    {
        if ($this->collNotificationConfigurations === null) {
            $this->initNotificationConfigurations();
            $this->collNotificationConfigurationsPartial = true;
        }

        if (!$this->collNotificationConfigurations->contains($l)) {
            $this->doAddNotificationConfiguration($l);

            if ($this->notificationConfigurationsScheduledForDeletion and $this->notificationConfigurationsScheduledForDeletion->contains($l)) {
                $this->notificationConfigurationsScheduledForDeletion->remove($this->notificationConfigurationsScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildNotificationConfiguration $notificationConfiguration The ChildNotificationConfiguration object to add.
     */
    protected function doAddNotificationConfiguration(ChildNotificationConfiguration $notificationConfiguration): void
    {
        $this->collNotificationConfigurations[]= $notificationConfiguration;
        $notificationConfiguration->setCompany($this);
    }

    /**
     * @param ChildNotificationConfiguration $notificationConfiguration The ChildNotificationConfiguration object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeNotificationConfiguration(ChildNotificationConfiguration $notificationConfiguration)
    {
        if ($this->getNotificationConfigurations()->contains($notificationConfiguration)) {
            $pos = $this->collNotificationConfigurations->search($notificationConfiguration);
            $this->collNotificationConfigurations->remove($pos);
            if (null === $this->notificationConfigurationsScheduledForDeletion) {
                $this->notificationConfigurationsScheduledForDeletion = clone $this->collNotificationConfigurations;
                $this->notificationConfigurationsScheduledForDeletion->clear();
            }
            $this->notificationConfigurationsScheduledForDeletion[]= clone $notificationConfiguration;
            $notificationConfiguration->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears out the collLeaveTypes collection
     *
     * This does not modify the database; however, it will remove any associated objects, causing
     * them to be refetched by subsequent calls to accessor method.
     *
     * @return $this
     * @see addLeaveTypes()
     */
    public function clearLeaveTypes()
    {
        $this->collLeaveTypes = null; // important to set this to NULL since that means it is uninitialized

        return $this;
    }

    /**
     * Reset is the collLeaveTypes collection loaded partially.
     *
     * @return void
     */
    public function resetPartialLeaveTypes($v = true): void
    {
        $this->collLeaveTypesPartial = $v;
    }

    /**
     * Initializes the collLeaveTypes collection.
     *
     * By default this just sets the collLeaveTypes collection to an empty array (like clearcollLeaveTypes());
     * however, you may wish to override this method in your stub class to provide setting appropriate
     * to your application -- for example, setting the initial array to the values stored in database.
     *
     * @param bool $overrideExisting If set to true, the method call initializes
     *                                        the collection even if it is not empty
     *
     * @return void
     */
    public function initLeaveTypes(bool $overrideExisting = true): void
    {
        if (null !== $this->collLeaveTypes && !$overrideExisting) {
            return;
        }

        $collectionClassName = LeaveTypeTableMap::getTableMap()->getCollectionClassName();

        $this->collLeaveTypes = new $collectionClassName;
        $this->collLeaveTypes->setModel('\entities\LeaveType');
    }

    /**
     * Gets an array of ChildLeaveType objects which contain a foreign key that references this object.
     *
     * If the $criteria is not null, it is used to always fetch the results from the database.
     * Otherwise the results are fetched from the database the first time, then cached.
     * Next time the same method is called without $criteria, the cached collection is returned.
     * If this ChildCompany is new, it will return
     * an empty collection or the current collection; the criteria is ignored on a new object.
     *
     * @param Criteria $criteria optional Criteria object to narrow the query
     * @param ConnectionInterface $con optional connection object
     * @return ObjectCollection|ChildLeaveType[] List of ChildLeaveType objects
     * @phpstan-return ObjectCollection&\Traversable<ChildLeaveType> List of ChildLeaveType objects
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function getLeaveTypes(?Criteria $criteria = null, ?ConnectionInterface $con = null)
    {
        $partial = $this->collLeaveTypesPartial && !$this->isNew();
        if (null === $this->collLeaveTypes || null !== $criteria || $partial) {
            if ($this->isNew()) {
                // return empty collection
                if (null === $this->collLeaveTypes) {
                    $this->initLeaveTypes();
                } else {
                    $collectionClassName = LeaveTypeTableMap::getTableMap()->getCollectionClassName();

                    $collLeaveTypes = new $collectionClassName;
                    $collLeaveTypes->setModel('\entities\LeaveType');

                    return $collLeaveTypes;
                }
            } else {
                $collLeaveTypes = ChildLeaveTypeQuery::create(null, $criteria)
                    ->filterByCompany($this)
                    ->find($con);

                if (null !== $criteria) {
                    if (false !== $this->collLeaveTypesPartial && count($collLeaveTypes)) {
                        $this->initLeaveTypes(false);

                        foreach ($collLeaveTypes as $obj) {
                            if (false == $this->collLeaveTypes->contains($obj)) {
                                $this->collLeaveTypes->append($obj);
                            }
                        }

                        $this->collLeaveTypesPartial = true;
                    }

                    return $collLeaveTypes;
                }

                if ($partial && $this->collLeaveTypes) {
                    foreach ($this->collLeaveTypes as $obj) {
                        if ($obj->isNew()) {
                            $collLeaveTypes[] = $obj;
                        }
                    }
                }

                $this->collLeaveTypes = $collLeaveTypes;
                $this->collLeaveTypesPartial = false;
            }
        }

        return $this->collLeaveTypes;
    }

    /**
     * Sets a collection of ChildLeaveType objects related by a one-to-many relationship
     * to the current object.
     * It will also schedule objects for deletion based on a diff between old objects (aka persisted)
     * and new objects from the given Propel collection.
     *
     * @param Collection $leaveTypes A Propel collection.
     * @param ConnectionInterface $con Optional connection object
     * @return $this The current object (for fluent API support)
     */
    public function setLeaveTypes(Collection $leaveTypes, ?ConnectionInterface $con = null)
    {
        /** @var ChildLeaveType[] $leaveTypesToDelete */
        $leaveTypesToDelete = $this->getLeaveTypes(new Criteria(), $con)->diff($leaveTypes);


        $this->leaveTypesScheduledForDeletion = $leaveTypesToDelete;

        foreach ($leaveTypesToDelete as $leaveTypeRemoved) {
            $leaveTypeRemoved->setCompany(null);
        }

        $this->collLeaveTypes = null;
        foreach ($leaveTypes as $leaveType) {
            $this->addLeaveType($leaveType);
        }

        $this->collLeaveTypes = $leaveTypes;
        $this->collLeaveTypesPartial = false;

        return $this;
    }

    /**
     * Returns the number of related LeaveType objects.
     *
     * @param Criteria $criteria
     * @param bool $distinct
     * @param ConnectionInterface $con
     * @return int Count of related LeaveType objects.
     * @throws \Propel\Runtime\Exception\PropelException
     */
    public function countLeaveTypes(?Criteria $criteria = null, bool $distinct = false, ?ConnectionInterface $con = null): int
    {
        $partial = $this->collLeaveTypesPartial && !$this->isNew();
        if (null === $this->collLeaveTypes || null !== $criteria || $partial) {
            if ($this->isNew() && null === $this->collLeaveTypes) {
                return 0;
            }

            if ($partial && !$criteria) {
                return count($this->getLeaveTypes());
            }

            $query = ChildLeaveTypeQuery::create(null, $criteria);
            if ($distinct) {
                $query->distinct();
            }

            return $query
                ->filterByCompany($this)
                ->count($con);
        }

        return count($this->collLeaveTypes);
    }

    /**
     * Method called to associate a ChildLeaveType object to this object
     * through the ChildLeaveType foreign key attribute.
     *
     * @param ChildLeaveType $l ChildLeaveType
     * @return $this The current object (for fluent API support)
     */
    public function addLeaveType(ChildLeaveType $l)
    {
        if ($this->collLeaveTypes === null) {
            $this->initLeaveTypes();
            $this->collLeaveTypesPartial = true;
        }

        if (!$this->collLeaveTypes->contains($l)) {
            $this->doAddLeaveType($l);

            if ($this->leaveTypesScheduledForDeletion and $this->leaveTypesScheduledForDeletion->contains($l)) {
                $this->leaveTypesScheduledForDeletion->remove($this->leaveTypesScheduledForDeletion->search($l));
            }
        }

        return $this;
    }

    /**
     * @param ChildLeaveType $leaveType The ChildLeaveType object to add.
     */
    protected function doAddLeaveType(ChildLeaveType $leaveType): void
    {
        $this->collLeaveTypes[]= $leaveType;
        $leaveType->setCompany($this);
    }

    /**
     * @param ChildLeaveType $leaveType The ChildLeaveType object to remove.
     * @return $this The current object (for fluent API support)
     */
    public function removeLeaveType(ChildLeaveType $leaveType)
    {
        if ($this->getLeaveTypes()->contains($leaveType)) {
            $pos = $this->collLeaveTypes->search($leaveType);
            $this->collLeaveTypes->remove($pos);
            if (null === $this->leaveTypesScheduledForDeletion) {
                $this->leaveTypesScheduledForDeletion = clone $this->collLeaveTypes;
                $this->leaveTypesScheduledForDeletion->clear();
            }
            $this->leaveTypesScheduledForDeletion[]= clone $leaveType;
            $leaveType->setCompany(null);
        }

        return $this;
    }

    /**
     * Clears the current object, sets all attributes to their default values and removes
     * outgoing references as well as back-references (from other objects to this one. Results probably in a database
     * change of those foreign objects when you call `save` there).
     *
     * @return $this
     */
    public function clear()
    {
        if (null !== $this->aExpenseMasterRelatedByAutoCalculatedTa) {
            $this->aExpenseMasterRelatedByAutoCalculatedTa->removeCompanyRelatedByAutoCalculatedTa($this);
        }
        if (null !== $this->aCurrencies) {
            $this->aCurrencies->removeCompany($this);
        }
        $this->company_id = null;
        $this->company_code = null;
        $this->company_name = null;
        $this->owner_name = null;
        $this->company_phone_number = null;
        $this->company_contact_number = null;
        $this->company_logo = null;
        $this->company_address_1 = null;
        $this->company_address_2 = null;
        $this->company_default_currency = null;
        $this->timezone = null;
        $this->company_first_setup = null;
        $this->owner_email = null;
        $this->expense_reminder = null;
        $this->currentmonthsubmit = null;
        $this->tripapprovalreq = null;
        $this->expenseonlyontrip = null;
        $this->allowbackdatedtrip = null;
        $this->paymentsystem = null;
        $this->auto_settle = null;
        $this->allowradius = null;
        $this->order_seq = null;
        $this->shippingorder_seq = null;
        $this->googlemapkey = null;
        $this->workingdaysinweek = null;
        $this->auto_calculated_ta = null;
        $this->reporting_days = null;
        $this->expense_months = null;
        $this->alreadyInSave = false;
        $this->clearAllReferences();
        $this->applyDefaultValues();
        $this->resetModified();
        $this->setNew(true);
        $this->setDeleted(false);

        return $this;
    }

    /**
     * Resets all references and back-references to other model objects or collections of model objects.
     *
     * This method is used to reset all php object references (not the actual reference in the database).
     * Necessary for object serialisation.
     *
     * @param bool $deep Whether to also clear the references on all referrer objects.
     * @return $this
     */
    public function clearAllReferences(bool $deep = false)
    {
        if ($deep) {
            if ($this->collAgendatypess) {
                foreach ($this->collAgendatypess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collAnnouncementss) {
                foreach ($this->collAnnouncementss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collApiKeyss) {
                foreach ($this->collApiKeyss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collAttendances) {
                foreach ($this->collAttendances as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBeatOutletss) {
                foreach ($this->collBeatOutletss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBeatss) {
                foreach ($this->collBeatss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBranches) {
                foreach ($this->collBranches as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBrandCampiagns) {
                foreach ($this->collBrandCampiagns as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBrandCampiagnDoctorss) {
                foreach ($this->collBrandCampiagnDoctorss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBrandCampiagnVisitPlans) {
                foreach ($this->collBrandCampiagnVisitPlans as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBrandCompetitions) {
                foreach ($this->collBrandCompetitions as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBrandRcpas) {
                foreach ($this->collBrandRcpas as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBrandss) {
                foreach ($this->collBrandss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collBudgetGroups) {
                foreach ($this->collBudgetGroups as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collCategoriess) {
                foreach ($this->collCategoriess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collCheckinoutOutcomess) {
                foreach ($this->collCheckinoutOutcomess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collCitycategories) {
                foreach ($this->collCitycategories as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collClassifications) {
                foreach ($this->collClassifications as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collCompetitionMappings) {
                foreach ($this->collCompetitionMappings as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collCompetitors) {
                foreach ($this->collCompetitors as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collConfigurations) {
                foreach ($this->collConfigurations as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collCronCommandLogss) {
                foreach ($this->collCronCommandLogss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collCronCommandss) {
                foreach ($this->collCronCommandss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collDailycallss) {
                foreach ($this->collDailycallss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collDailycallsSgpiouts) {
                foreach ($this->collDailycallsSgpiouts as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collDataExceptionLogss) {
                foreach ($this->collDataExceptionLogss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collDataExceptionss) {
                foreach ($this->collDataExceptionss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collDesignationss) {
                foreach ($this->collDesignationss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEdFeedbackss) {
                foreach ($this->collEdFeedbackss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEdPlaylists) {
                foreach ($this->collEdPlaylists as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEdPresentationss) {
                foreach ($this->collEdPresentationss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEdSessions) {
                foreach ($this->collEdSessions as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEdStatss) {
                foreach ($this->collEdStatss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEmployees) {
                foreach ($this->collEmployees as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEmployeeIncentives) {
                foreach ($this->collEmployeeIncentives as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEventTypess) {
                foreach ($this->collEventTypess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collEventss) {
                foreach ($this->collEventss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collExpenseLists) {
                foreach ($this->collExpenseLists as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collExpenseMastersRelatedByCompanyId) {
                foreach ($this->collExpenseMastersRelatedByCompanyId as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collExpensePaymentss) {
                foreach ($this->collExpensePaymentss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collExpensess) {
                foreach ($this->collExpensess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collFtpConfigss) {
                foreach ($this->collFtpConfigss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collFtpExportBatchess) {
                foreach ($this->collFtpExportBatchess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collFtpExportLogss) {
                foreach ($this->collFtpExportLogss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collFtpImportBatchess) {
                foreach ($this->collFtpImportBatchess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collFtpImportLogss) {
                foreach ($this->collFtpImportLogss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collGradeMasters) {
                foreach ($this->collGradeMasters as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collHolidayss) {
                foreach ($this->collHolidayss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collIntegrationApiLogss) {
                foreach ($this->collIntegrationApiLogss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collLeaveRequests) {
                foreach ($this->collLeaveRequests as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collLeavess) {
                foreach ($this->collLeavess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMaterialFolderss) {
                foreach ($this->collMaterialFolderss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMediaFiless) {
                foreach ($this->collMediaFiless as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMediaFolderss) {
                foreach ($this->collMediaFolderss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMtps) {
                foreach ($this->collMtps as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMtpDays) {
                foreach ($this->collMtpDays as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collMtpLogss) {
                foreach ($this->collMtpLogss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOfferss) {
                foreach ($this->collOfferss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOnBoardRequests) {
                foreach ($this->collOnBoardRequests as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOnBoardRequestAddresses) {
                foreach ($this->collOnBoardRequestAddresses as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOnBoardRequiredFieldss) {
                foreach ($this->collOnBoardRequiredFieldss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOrderLogs) {
                foreach ($this->collOrderLogs as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOrderliness) {
                foreach ($this->collOrderliness as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOrderss) {
                foreach ($this->collOrderss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOrgUnits) {
                foreach ($this->collOrgUnits as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOtpRequestss) {
                foreach ($this->collOtpRequestss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletAddresses) {
                foreach ($this->collOutletAddresses as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletOrgDatas) {
                foreach ($this->collOutletOrgDatas as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletOrgNotess) {
                foreach ($this->collOutletOrgNotess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletOutcomess) {
                foreach ($this->collOutletOutcomess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletStocks) {
                foreach ($this->collOutletStocks as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletStockOtherSummaries) {
                foreach ($this->collOutletStockOtherSummaries as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletStockSummaries) {
                foreach ($this->collOutletStockSummaries as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletTagss) {
                foreach ($this->collOutletTagss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletTypes) {
                foreach ($this->collOutletTypes as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletss) {
                foreach ($this->collOutletss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPolicyMasters) {
                foreach ($this->collPolicyMasters as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPolicykeyss) {
                foreach ($this->collPolicykeyss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPositionss) {
                foreach ($this->collPositionss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPricebookliness) {
                foreach ($this->collPricebookliness as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collPricebookss) {
                foreach ($this->collPricebookss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collProductss) {
                foreach ($this->collProductss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collReminderss) {
                foreach ($this->collReminderss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSgpiAccountss) {
                foreach ($this->collSgpiAccountss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSgpiMasters) {
                foreach ($this->collSgpiMasters as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSgpiTranss) {
                foreach ($this->collSgpiTranss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collShiftTypess) {
                foreach ($this->collShiftTypess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collShippingliness) {
                foreach ($this->collShippingliness as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collShippingorders) {
                foreach ($this->collShippingorders as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collStockTransactions) {
                foreach ($this->collStockTransactions as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collStockVouchers) {
                foreach ($this->collStockVouchers as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSurveys) {
                foreach ($this->collSurveys as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSurveyCategories) {
                foreach ($this->collSurveyCategories as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSurveyQuestions) {
                foreach ($this->collSurveyQuestions as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collSurveySubmiteds) {
                foreach ($this->collSurveySubmiteds as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTaConfigurations) {
                foreach ($this->collTaConfigurations as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTagss) {
                foreach ($this->collTagss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTerritoriess) {
                foreach ($this->collTerritoriess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTerritoryTownss) {
                foreach ($this->collTerritoryTownss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTicketRepliess) {
                foreach ($this->collTicketRepliess as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTicketTypes) {
                foreach ($this->collTicketTypes as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTicketss) {
                foreach ($this->collTicketss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTourplanss) {
                foreach ($this->collTourplanss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collTransactionss) {
                foreach ($this->collTransactionss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collUserss) {
                foreach ($this->collUserss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collWdbSyncLogs) {
                foreach ($this->collWdbSyncLogs as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collWfRequestss) {
                foreach ($this->collWfRequestss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collStps) {
                foreach ($this->collStps as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collStpWeeks) {
                foreach ($this->collStpWeeks as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collOutletOrgDataKeyss) {
                foreach ($this->collOutletOrgDataKeyss as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collNotificationConfigurations) {
                foreach ($this->collNotificationConfigurations as $o) {
                    $o->clearAllReferences($deep);
                }
            }
            if ($this->collLeaveTypes) {
                foreach ($this->collLeaveTypes as $o) {
                    $o->clearAllReferences($deep);
                }
            }
        } // if ($deep)

        $this->collAgendatypess = null;
        $this->collAnnouncementss = null;
        $this->collApiKeyss = null;
        $this->collAttendances = null;
        $this->collBeatOutletss = null;
        $this->collBeatss = null;
        $this->collBranches = null;
        $this->collBrandCampiagns = null;
        $this->collBrandCampiagnDoctorss = null;
        $this->collBrandCampiagnVisitPlans = null;
        $this->collBrandCompetitions = null;
        $this->collBrandRcpas = null;
        $this->collBrandss = null;
        $this->collBudgetGroups = null;
        $this->collCategoriess = null;
        $this->collCheckinoutOutcomess = null;
        $this->collCitycategories = null;
        $this->collClassifications = null;
        $this->collCompetitionMappings = null;
        $this->collCompetitors = null;
        $this->collConfigurations = null;
        $this->collCronCommandLogss = null;
        $this->collCronCommandss = null;
        $this->collDailycallss = null;
        $this->collDailycallsSgpiouts = null;
        $this->collDataExceptionLogss = null;
        $this->collDataExceptionss = null;
        $this->collDesignationss = null;
        $this->collEdFeedbackss = null;
        $this->collEdPlaylists = null;
        $this->collEdPresentationss = null;
        $this->collEdSessions = null;
        $this->collEdStatss = null;
        $this->collEmployees = null;
        $this->collEmployeeIncentives = null;
        $this->collEventTypess = null;
        $this->collEventss = null;
        $this->collExpenseLists = null;
        $this->collExpenseMastersRelatedByCompanyId = null;
        $this->collExpensePaymentss = null;
        $this->collExpensess = null;
        $this->collFtpConfigss = null;
        $this->collFtpExportBatchess = null;
        $this->collFtpExportLogss = null;
        $this->collFtpImportBatchess = null;
        $this->collFtpImportLogss = null;
        $this->collGradeMasters = null;
        $this->collHolidayss = null;
        $this->collIntegrationApiLogss = null;
        $this->collLeaveRequests = null;
        $this->collLeavess = null;
        $this->collMaterialFolderss = null;
        $this->collMediaFiless = null;
        $this->collMediaFolderss = null;
        $this->collMtps = null;
        $this->collMtpDays = null;
        $this->collMtpLogss = null;
        $this->collOfferss = null;
        $this->collOnBoardRequests = null;
        $this->collOnBoardRequestAddresses = null;
        $this->collOnBoardRequiredFieldss = null;
        $this->collOrderLogs = null;
        $this->collOrderliness = null;
        $this->collOrderss = null;
        $this->collOrgUnits = null;
        $this->collOtpRequestss = null;
        $this->collOutletAddresses = null;
        $this->collOutletOrgDatas = null;
        $this->collOutletOrgNotess = null;
        $this->collOutletOutcomess = null;
        $this->collOutletStocks = null;
        $this->collOutletStockOtherSummaries = null;
        $this->collOutletStockSummaries = null;
        $this->collOutletTagss = null;
        $this->collOutletTypes = null;
        $this->collOutletss = null;
        $this->collPolicyMasters = null;
        $this->collPolicykeyss = null;
        $this->collPositionss = null;
        $this->collPricebookliness = null;
        $this->collPricebookss = null;
        $this->collProductss = null;
        $this->collReminderss = null;
        $this->collSgpiAccountss = null;
        $this->collSgpiMasters = null;
        $this->collSgpiTranss = null;
        $this->collShiftTypess = null;
        $this->collShippingliness = null;
        $this->collShippingorders = null;
        $this->collStockTransactions = null;
        $this->collStockVouchers = null;
        $this->collSurveys = null;
        $this->collSurveyCategories = null;
        $this->collSurveyQuestions = null;
        $this->collSurveySubmiteds = null;
        $this->collTaConfigurations = null;
        $this->collTagss = null;
        $this->collTerritoriess = null;
        $this->collTerritoryTownss = null;
        $this->collTicketRepliess = null;
        $this->collTicketTypes = null;
        $this->collTicketss = null;
        $this->collTourplanss = null;
        $this->collTransactionss = null;
        $this->collUserss = null;
        $this->collWdbSyncLogs = null;
        $this->collWfRequestss = null;
        $this->collStps = null;
        $this->collStpWeeks = null;
        $this->collOutletOrgDataKeyss = null;
        $this->collNotificationConfigurations = null;
        $this->collLeaveTypes = null;
        $this->aExpenseMasterRelatedByAutoCalculatedTa = null;
        $this->aCurrencies = null;
        return $this;
    }

    /**
     * Return the string representation of this object
     *
     * @return string
     */
    public function __toString()
    {
        return (string) $this->exportTo(CompanyTableMap::DEFAULT_STRING_FORMAT);
    }

    /**
     * Code to be run before persisting the object
     * @param ConnectionInterface|null $con
     * @return bool
     */
    public function preSave(?ConnectionInterface $con = null): bool
    {
                return true;
    }

    /**
     * Code to be run after persisting the object
     * @param ConnectionInterface|null $con
     * @return void
     */
    public function postSave(?ConnectionInterface $con = null): void
    {
            }

    /**
     * Code to be run before inserting to database
     * @param ConnectionInterface|null $con
     * @return bool
     */
    public function preInsert(?ConnectionInterface $con = null): bool
    {
                return true;
    }

    /**
     * Code to be run after inserting to database
     * @param ConnectionInterface|null $con
     * @return void
     */
    public function postInsert(?ConnectionInterface $con = null): void
    {
            }

    /**
     * Code to be run before updating the object in database
     * @param ConnectionInterface|null $con
     * @return bool
     */
    public function preUpdate(?ConnectionInterface $con = null): bool
    {
                return true;
    }

    /**
     * Code to be run after updating the object in database
     * @param ConnectionInterface|null $con
     * @return void
     */
    public function postUpdate(?ConnectionInterface $con = null): void
    {
            }

    /**
     * Code to be run before deleting the object in database
     * @param ConnectionInterface|null $con
     * @return bool
     */
    public function preDelete(?ConnectionInterface $con = null): bool
    {
                return true;
    }

    /**
     * Code to be run after deleting the object in database
     * @param ConnectionInterface|null $con
     * @return void
     */
    public function postDelete(?ConnectionInterface $con = null): void
    {
            }


    /**
     * Derived method to catches calls to undefined methods.
     *
     * Provides magic import/export method support (fromXML()/toXML(), fromYAML()/toYAML(), etc.).
     * Allows to define default __call() behavior if you overwrite __call()
     *
     * @param string $name
     * @param mixed $params
     *
     * @return array|string
     */
    public function __call($name, $params)
    {
        if (0 === strpos($name, 'get')) {
            $virtualColumn = substr($name, 3);
            if ($this->hasVirtualColumn($virtualColumn)) {
                return $this->getVirtualColumn($virtualColumn);
            }

            $virtualColumn = lcfirst($virtualColumn);
            if ($this->hasVirtualColumn($virtualColumn)) {
                return $this->getVirtualColumn($virtualColumn);
            }
        }

        if (0 === strpos($name, 'from')) {
            $format = substr($name, 4);
            $inputData = $params[0];
            $keyType = $params[1] ?? TableMap::TYPE_PHPNAME;

            return $this->importFrom($format, $inputData, $keyType);
        }

        if (0 === strpos($name, 'to')) {
            $format = substr($name, 2);
            $includeLazyLoadColumns = $params[0] ?? true;
            $keyType = $params[1] ?? TableMap::TYPE_PHPNAME;

            return $this->exportTo($format, $includeLazyLoadColumns, $keyType);
        }

        throw new BadMethodCallException(sprintf('Call to undefined method: %s.', $name));
    }

}
